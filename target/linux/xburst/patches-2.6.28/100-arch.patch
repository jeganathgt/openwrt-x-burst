--- linux-2.6.24.7.old/arch/mips/Kconfig	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/arch/mips/Kconfig	2009-04-12 18:13:57.000000000 +0200
@@ -16,6 +16,82 @@
 	prompt "System type"
 	default SGI_IP22

+config JZ4730_PMP
+	bool "Ingenic JZ4730 PMP board"
+	select DMA_NONCOHERENT
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SOC_JZ4730
+
+config JZ4740_PAVO
+	bool "Ingenic JZ4740 PAVO board"
+	select DMA_NONCOHERENT
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SOC_JZ4740
+
+config JZ4740_LEO
+	bool "Ingenic JZ4740 LEO board"
+	select DMA_NONCOHERENT
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SOC_JZ4740
+
+config JZ4740_LYRA
+	bool "Ingenic JZ4740 LYRA board"
+	select DMA_NONCOHERENT
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SOC_JZ4740
+
+config JZ4725_DIPPER
+	bool "Ingenic JZ4725 DIPPER board"
+	select DMA_NONCOHERENT
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SOC_JZ4740
+	select SOC_JZ4725
+
+config JZ4720_VIRGO
+	bool "Ingenic JZ4720 VIRGO board"
+	select DMA_NONCOHERENT
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SOC_JZ4740
+	select SOC_JZ4720
+
+config JZ4750_FUWA
+	bool "Ingenic JZ4750 FUWA board"
+	select DMA_NONCOHERENT
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SOC_JZ4750
+	select JZ_FPGA
+
+config JZ4750D_FUWA1
+	bool "Ingenic JZ4750d FUWA1 board"
+	select DMA_NONCOHERENT
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SOC_JZ4750D
+	select JZ_FPGA
+
+config JZ4750_APUS
+	bool "Ingenic JZ4750 APUS board"
+	select DMA_NONCOHERENT
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SOC_JZ4750
+
 config MACH_ALCHEMY
 	bool "Alchemy processor based machines"

@@ -701,6 +777,48 @@

 endmenu

+#####################################################
+# Ingenic SOC series
+#####################################################
+
+config SOC_JZ4730
+	bool
+	select JZSOC
+
+config SOC_JZ4740
+	bool
+	select JZSOC
+
+config SOC_JZ4725
+	bool
+	select JZSOC
+
+config SOC_JZ4720
+	bool
+	select JZSOC
+
+config SOC_JZ4750
+	bool
+	select JZSOC
+
+config SOC_JZ4750D
+	bool
+	select JZSOC
+
+config JZ_FPGA
+	bool
+
+config JZSOC
+	bool
+	select JZRISC
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_SUPPORTS_32BIT_KERNEL
+
+config JZRISC
+	bool
+
+####################################################
+
 config RWSEM_GENERIC_SPINLOCK
 	bool
 	default y
@@ -1770,6 +1888,14 @@

 source "kernel/time/Kconfig"

+# the value of (max order + 1)
+config FORCE_MAX_ZONEORDER
+	prompt "MAX_ZONEORDER"
+	int
+	default "12"
+	help
+	 The max memory that can be allocated = 4KB * 2^(CONFIG_FORCE_MAX_ZONEORDER - 1)
+
 #
 # Timer Interrupt Frequency Configuration
 #
@@ -2046,6 +2172,23 @@

 endmenu

+menu "CPU Frequency scaling"
+
+config CPU_FREQ_JZ
+	tristate "CPUfreq driver for JZ CPUs"
+	depends on JZSOC
+	default n
+	help
+	  This enables the CPUfreq driver for JZ CPUs.
+
+	  If in doubt, say N.
+
+if (CPU_FREQ_JZ)
+source "drivers/cpufreq/Kconfig"
+endif
+
+endmenu
+
 menu "Power management options"

 source "kernel/power/Kconfig"
--- linux-2.6.24.7.old/arch/mips/Makefile	2009-04-12 18:05:07.000000000 +0200
+++ linux-2.6.24.7/arch/mips/Makefile	2009-04-12 18:13:57.000000000 +0200
@@ -159,6 +159,37 @@
 #

 #
+# Commond Ingenic JZ4730 series
+#
+core-$(CONFIG_SOC_JZ4730)	+= arch/mips/jz4730/
+cflags-$(CONFIG_SOC_JZ4730)	+= -Iarch/mips/include/asm/mach-jz4730
+load-$(CONFIG_SOC_JZ4730)	+= 0xffffffff80010000
+
+#
+# Commond Ingenic JZ4740 series
+#
+
+core-$(CONFIG_SOC_JZ4740)	+= arch/mips/jz4740/
+cflags-$(CONFIG_SOC_JZ4740)	+= -Iarch/mips/include/asm/mach-jz4740
+load-$(CONFIG_SOC_JZ4740)	+= 0xffffffff80010000
+
+#
+# Commond Ingenic JZ4750 series
+#
+
+core-$(CONFIG_SOC_JZ4750)	+= arch/mips/jz4750/
+cflags-$(CONFIG_SOC_JZ4750)	+= -Iarch/mips/include/asm/mach-jz4750
+load-$(CONFIG_SOC_JZ4750)	+= 0xffffffff80010000
+
+#
+# Commond Ingenic JZ4750d series
+#
+
+core-$(CONFIG_SOC_JZ4750D)	+= arch/mips/jz4750d/
+cflags-$(CONFIG_SOC_JZ4750D)	+= -Iarch/mips/include/asm/mach-jz4750d
+load-$(CONFIG_SOC_JZ4750D)	+= 0xffffffff80010000
+
+#
 # Acer PICA 61, Mips Magnum 4000 and Olivetti M700.
 #
 core-$(CONFIG_MACH_JAZZ)	+= arch/mips/jazz/
@@ -673,6 +704,12 @@

 all:	$(all-y)

+uImage: $(vmlinux-32)
+	+@$(call makeboot,$@)
+
+zImage: $(vmlinux-32)
+	+@$(call makeboot,$@)
+
 vmlinux.bin: $(vmlinux-32)
 	+@$(call makeboot,$@)

@@ -697,12 +734,13 @@

 archclean:
 	@$(MAKE) $(clean)=arch/mips/boot
+	@$(MAKE) $(clean)=arch/mips/boot/compressed
 	@$(MAKE) $(clean)=arch/mips/lasat

 define archhelp
-	echo '  vmlinux.ecoff        - ECOFF boot image'
-	echo '  vmlinux.bin          - Raw binary boot image'
-	echo '  vmlinux.srec         - SREC boot image'
+	echo  '  uImage	- u-boot format image (arch/$(ARCH)/boot/uImage)'
+	echo  '  zImage	- Compressed binary image (arch/$(ARCH)/boot/compressed/zImage)'
+	echo  '  vmlinux.bin	- Uncompressed binary image (arch/$(ARCH)/boot/vmlinux.bin)'
 	echo
 	echo '  These will be default as apropriate for a configured platform.'
 endef
--- linux-2.6.24.7.old/arch/mips/boot/Makefile	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/arch/mips/boot/Makefile	2009-04-12 18:13:57.000000000 +0200
@@ -7,6 +7,9 @@
 # Copyright (C) 2004  Maciej W. Rozycki
 #

+# This one must match the LOADADDR in arch/mips/Makefile!
+LOADADDR=0x80010000
+
 #
 # Some DECstations need all possible sections of an ECOFF executable
 #
@@ -25,7 +28,7 @@

 VMLINUX = vmlinux

-all: vmlinux.ecoff vmlinux.srec addinitrd
+all: vmlinux.ecoff vmlinux.srec addinitrd uImage zImage

 vmlinux.ecoff: $(obj)/elf2ecoff $(VMLINUX)
 	$(obj)/elf2ecoff $(VMLINUX) vmlinux.ecoff $(E2EFLAGS)
@@ -42,8 +45,24 @@
 $(obj)/addinitrd: $(obj)/addinitrd.c
 	$(HOSTCC) -o $@ $^

+uImage: $(VMLINUX) vmlinux.bin
+	rm -f $(obj)/vmlinux.bin.gz
+	gzip -9 $(obj)/vmlinux.bin
+	mkimage -A mips -O linux -T kernel -C gzip \
+		-a $(LOADADDR) -e $(shell sh ./$(obj)/tools/entry $(NM) $(VMLINUX) ) \
+		-n 'Linux-$(KERNELRELEASE)' \
+		-d $(obj)/vmlinux.bin.gz $(obj)/uImage
+	@echo '  Kernel: arch/mips/boot/$@ is ready'
+
+zImage:
+	$(Q)$(MAKE) $(build)=$(obj)/compressed loadaddr=$(LOADADDR) $@
+	@echo '  Kernel: arch/mips/boot/compressed/$@ is ready'
+
 clean-files += addinitrd \
 	       elf2ecoff \
 	       vmlinux.bin \
 	       vmlinux.ecoff \
-	       vmlinux.srec
+	       vmlinux.srec \
+	       vmlinux.bin.gz \
+	       uImage \
+	       zImage
--- linux-2.6.24.7.old/arch/mips/boot/compressed/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/boot/compressed/Makefile	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,42 @@
+#
+# linux/arch/mips/boot/compressed/Makefile
+#
+# create a compressed zImage from the original vmlinux
+#
+
+targets		:= zImage vmlinuz vmlinux.bin.gz head.o misc.o piggy.o dummy.o
+
+OBJS 		:= $(obj)/head.o $(obj)/misc.o
+
+LD_ARGS 	:= -T $(obj)/ld.script -Ttext 0x80600000 -Bstatic
+OBJCOPY_ARGS 	:= -O elf32-tradlittlemips
+
+ENTRY 		:= $(obj)/../tools/entry
+FILESIZE 	:= $(obj)/../tools/filesize
+
+drop-sections	= .reginfo .mdebug .comment .note .pdr .options .MIPS.options
+strip-flags	= $(addprefix --remove-section=,$(drop-sections))
+
+
+$(obj)/vmlinux.bin.gz: vmlinux
+	rm -f $(obj)/vmlinux.bin.gz
+	$(OBJCOPY) -O binary $(strip-flags) vmlinux $(obj)/vmlinux.bin
+	gzip -v9f $(obj)/vmlinux.bin
+
+$(obj)/head.o: $(obj)/head.S $(obj)/vmlinux.bin.gz vmlinux
+	$(CC) $(KBUILD_AFLAGS) \
+	-DIMAGESIZE=$(shell sh $(FILESIZE) $(obj)/vmlinux.bin.gz) \
+	-DKERNEL_ENTRY=$(shell sh $(ENTRY) $(NM) vmlinux ) \
+	-DLOADADDR=$(loadaddr) \
+	-c -o $(obj)/head.o $<
+
+$(obj)/vmlinuz: $(OBJS) $(obj)/ld.script $(obj)/vmlinux.bin.gz $(obj)/dummy.o
+	$(OBJCOPY) \
+		--add-section=.image=$(obj)/vmlinux.bin.gz \
+		--set-section-flags=.image=contents,alloc,load,readonly,data \
+		$(obj)/dummy.o $(obj)/piggy.o
+	$(LD) $(LD_ARGS) -o $@ $(OBJS) $(obj)/piggy.o
+	$(OBJCOPY) $(OBJCOPY_ARGS) $@ $@ -R .comment -R .stab -R .stabstr -R .initrd -R .sysmap
+
+zImage: $(obj)/vmlinuz
+	$(OBJCOPY) -O binary $(obj)/vmlinuz $(obj)/zImage
--- linux-2.6.24.7.old/arch/mips/boot/compressed/dummy.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/boot/compressed/dummy.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,4 @@
+int main(void)
+{
+	return 0;
+}
--- linux-2.6.24.7.old/arch/mips/boot/compressed/head.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/boot/compressed/head.S	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,85 @@
+/*
+ *  linux/arch/mips/boot/compressed/head.S
+ *
+ *  Copyright (C) 2005-2008 Ingenic Semiconductor Inc.
+ */
+
+#include <asm/asm.h>
+#include <asm/cacheops.h>
+#include <asm/cachectl.h>
+#include <asm/regdef.h>
+
+#define IndexInvalidate_I       0x00
+#define IndexWriteBack_D        0x01
+
+	.set noreorder
+	LEAF(startup)
+startup:
+	move	s0, a0		/* Save the boot loader transfered args */
+	move	s1, a1
+	move	s2, a2
+	move	s3, a3
+
+	la	a0, _edata
+	la	a1, _end
+1:	sw	zero, 0(a0)	/* Clear BSS section */
+	bne	a1, a0, 1b
+	addu	a0, 4
+
+	la	sp, (.stack + 8192)
+
+	la	a0, __image_begin
+	la	a1, IMAGESIZE
+	la	a2, LOADADDR
+	la	ra, 1f
+	la	k0, decompress_kernel
+	jr	k0
+	nop
+1:
+
+	move	a0, s0
+	move	a1, s1
+	move	a2, s2
+	move	a3, s3
+	li	k0, KERNEL_ENTRY
+	jr	k0
+	nop
+2:
+	b 32
+	END(startup)
+
+
+	LEAF(flushcaches)
+	la	t0, 1f
+	la	t1, 0xa0000000
+	or	t0, t0, t1
+	jr	t0
+	nop
+1:
+	li	k0, 0x80000000  # start address
+	li	k1, 0x80004000  # end address (16KB I-Cache)
+	subu	k1, 128
+
+2:
+	.set mips3
+	cache	IndexWriteBack_D, 0(k0)
+	cache	IndexWriteBack_D, 32(k0)
+	cache	IndexWriteBack_D, 64(k0)
+	cache	IndexWriteBack_D, 96(k0)
+	cache	IndexInvalidate_I, 0(k0)
+	cache	IndexInvalidate_I, 32(k0)
+	cache	IndexInvalidate_I, 64(k0)
+	cache	IndexInvalidate_I, 96(k0)
+	.set mips0
+
+	bne	k0, k1, 2b
+	addu	k0, k0, 128
+	la	t0, 3f
+	jr	t0
+	nop
+3:
+	jr	ra
+	nop
+	END(flushcaches)
+
+	.comm .stack,4096*2,4
--- linux-2.6.24.7.old/arch/mips/boot/compressed/ld.script	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/boot/compressed/ld.script	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,151 @@
+OUTPUT_ARCH(mips)
+ENTRY(startup)
+SECTIONS
+{
+  /* Read-only sections, merged into text segment: */
+
+  .init          : { *(.init)		} =0
+  .text      :
+  {
+    _ftext = . ;
+    *(.text)
+    *(.rodata)
+    *(.rodata1)
+    /* .gnu.warning sections are handled specially by elf32.em.  */
+    *(.gnu.warning)
+  } =0
+  .kstrtab : { *(.kstrtab) }
+
+  . = ALIGN(16);		/* Exception table */
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  __start___dbe_table = .;	/* Exception table for data bus errors */
+  __dbe_table : { *(__dbe_table) }
+  __stop___dbe_table = .;
+
+  __start___ksymtab = .;	/* Kernel symbol table */
+  __ksymtab : { *(__ksymtab) }
+  __stop___ksymtab = .;
+
+  _etext = .;
+
+  . = ALIGN(8192);
+  .data.init_task : { *(.data.init_task) }
+
+  /* Startup code */
+  . = ALIGN(4096);
+  __init_begin = .;
+  .text.init : { *(.text.init) }
+  .data.init : { *(.data.init) }
+  . = ALIGN(16);
+  __setup_start = .;
+  .setup.init : { *(.setup.init) }
+  __setup_end = .;
+  __initcall_start = .;
+  .initcall.init : { *(.initcall.init) }
+  __initcall_end = .;
+  . = ALIGN(4096);	/* Align double page for init_task_union */
+  __init_end = .;
+
+  . = ALIGN(4096);
+  .data.page_aligned : { *(.data.idt) }
+
+  . = ALIGN(32);
+  .data.cacheline_aligned : { *(.data.cacheline_aligned) }
+
+  .fini      : { *(.fini)    } =0
+  .reginfo : { *(.reginfo) }
+  /* Adjust the address for the data segment.  We want to adjust up to
+     the same address within the page on the next page up.  It would
+     be more correct to do this:
+       . = .;
+     The current expression does not correctly handle the case of a
+     text segment ending precisely at the end of a page; it causes the
+     data segment to skip a page.  The above expression does not have
+     this problem, but it will currently (2/95) cause BFD to allocate
+     a single segment, combining both text and data, for this case.
+     This will prevent the text segment from being shared among
+     multiple executions of the program; I think that is more
+     important than losing a page of the virtual address space (note
+     that no actual memory is lost; the page which is skipped can not
+     be referenced).  */
+  . = .;
+  .data    :
+  {
+    _fdata = . ;
+    *(.data)
+
+   /* Put the compressed image here, so bss is on the end. */
+   __image_begin = .;
+   *(.image)
+   __image_end = .;
+   /* Align the initial ramdisk image (INITRD) on page boundaries. */
+   . = ALIGN(4096);
+   __ramdisk_begin = .;
+   *(.initrd)
+   __ramdisk_end = .;
+   . = ALIGN(4096);
+
+    CONSTRUCTORS
+  }
+  .data1   : { *(.data1) }
+  _gp = . + 0x8000;
+  .lit8 : { *(.lit8) }
+  .lit4 : { *(.lit4) }
+  .ctors         : { *(.ctors)   }
+  .dtors         : { *(.dtors)   }
+  .got           : { *(.got.plt) *(.got) }
+  .dynamic       : { *(.dynamic) }
+  /* We want the small data sections together, so single-instruction offsets
+     can access them all, and initialized data all before uninitialized, so
+     we can shorten the on-disk segment size.  */
+  .sdata     : { *(.sdata) }
+  . = ALIGN(4);
+  _edata  =  .;
+  PROVIDE (edata = .);
+
+  __bss_start = .;
+  _fbss = .;
+  .sbss      : { *(.sbss) *(.scommon) }
+  .bss       :
+  {
+   *(.dynbss)
+   *(.bss)
+   *(COMMON)
+   .  = ALIGN(4);
+  _end = . ;
+  PROVIDE (end = .);
+  }
+
+  /* Sections to be discarded */
+  /DISCARD/ :
+  {
+        *(.text.exit)
+        *(.data.exit)
+        *(.exitcall.exit)
+  }
+
+  /* This is the MIPS specific mdebug section.  */
+  .mdebug : { *(.mdebug) }
+  /* These are needed for ELF backends which have not yet been
+     converted to the new style linker.  */
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  /* DWARF debug sections.
+     Symbols in the .debug DWARF section are relative to the beginning of the
+     section so we begin .debug at 0.  It's not clear yet what needs to happen
+     for the others.   */
+  .debug          0 : { *(.debug) }
+  .debug_srcinfo  0 : { *(.debug_srcinfo) }
+  .debug_aranges  0 : { *(.debug_aranges) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+  .debug_sfnames  0 : { *(.debug_sfnames) }
+  .line           0 : { *(.line) }
+  /* These must appear regardless of  .  */
+  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }
+  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }
+  .comment : { *(.comment) }
+  .note : { *(.note) }
+}
--- linux-2.6.24.7.old/arch/mips/boot/compressed/misc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/boot/compressed/misc.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,242 @@
+/*
+ * linux/arch/mips/boot/compressed/misc.c
+ *
+ * This is a collection of several routines from gzip-1.0.3
+ * adapted for Linux.
+ *
+ * malloc by Hannu Savolainen 1993 and Matthias Urlichs 1994
+ *
+ * Adapted for JZSOC by Peter Wei, 2008
+ *
+ */
+
+#define size_t	int
+#define NULL 0
+
+/*
+ * gzip declarations
+ */
+
+#define OF(args)  args
+#define STATIC static
+
+#undef memset
+#undef memcpy
+#define memzero(s, n)     memset ((s), 0, (n))
+
+typedef unsigned char  uch;
+typedef unsigned short ush;
+typedef unsigned long  ulg;
+
+#define WSIZE 0x8000		/* Window size must be at least 32k, */
+				/* and a power of two */
+
+static uch *inbuf;	     /* input buffer */
+static uch window[WSIZE];    /* Sliding window buffer */
+
+static unsigned insize = 0;  /* valid bytes in inbuf */
+static unsigned inptr = 0;   /* index of next byte to be processed in inbuf */
+static unsigned outcnt = 0;  /* bytes in output buffer */
+
+/* gzip flag byte */
+#define ASCII_FLAG   0x01 /* bit 0 set: file probably ASCII text */
+#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */
+#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
+#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
+#define COMMENT      0x10 /* bit 4 set: file comment present */
+#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */
+#define RESERVED     0xC0 /* bit 6,7:   reserved */
+
+#define get_byte()  (inptr < insize ? inbuf[inptr++] : fill_inbuf())
+
+/* Diagnostic functions */
+#ifdef DEBUG
+#  define Assert(cond,msg) {if(!(cond)) error(msg);}
+#  define Trace(x) fprintf x
+#  define Tracev(x) {if (verbose) fprintf x ;}
+#  define Tracevv(x) {if (verbose>1) fprintf x ;}
+#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
+#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
+#else
+#  define Assert(cond,msg)
+#  define Trace(x)
+#  define Tracev(x)
+#  define Tracevv(x)
+#  define Tracec(c,x)
+#  define Tracecv(c,x)
+#endif
+
+static int  fill_inbuf(void);
+static void flush_window(void);
+static void error(char *m);
+static void gzip_mark(void **);
+static void gzip_release(void **);
+
+void* memset(void* s, int c, size_t n);
+void* memcpy(void* __dest, __const void* __src, size_t __n);
+
+extern void flushcaches(void); /* defined in head.S */
+
+char *input_data;
+int input_len;
+
+static long bytes_out = 0;
+static uch *output_data;
+static unsigned long output_ptr = 0;
+
+
+static void *malloc(int size);
+static void free(void *where);
+static void error(char *m);
+static void gzip_mark(void **);
+static void gzip_release(void **);
+
+static void puts(const char *str)
+{
+}
+
+extern unsigned char _end[];
+static unsigned long free_mem_ptr;
+static unsigned long free_mem_end_ptr;
+
+#define HEAP_SIZE             0x10000
+
+#include "../../../../lib/inflate.c"
+
+static void *malloc(int size)
+{
+	void *p;
+
+	if (size <0) error("Malloc error\n");
+	if (free_mem_ptr == 0) error("Memory error\n");
+
+	free_mem_ptr = (free_mem_ptr + 3) & ~3;	/* Align */
+
+	p = (void *)free_mem_ptr;
+	free_mem_ptr += size;
+
+	if (free_mem_ptr >= free_mem_end_ptr)
+		error("\nOut of memory\n");
+
+	return p;
+}
+
+static void free(void *where)
+{	/* Don't care */
+}
+
+static void gzip_mark(void **ptr)
+{
+	*ptr = (void *) free_mem_ptr;
+}
+
+static void gzip_release(void **ptr)
+{
+	free_mem_ptr = (long) *ptr;
+}
+
+void* memset(void* s, int c, size_t n)
+{
+	int i;
+	char *ss = (char*)s;
+
+	for (i=0;i<n;i++) ss[i] = c;
+	return s;
+}
+
+void* memcpy(void* __dest, __const void* __src, size_t __n)
+{
+	int i = 0;
+	unsigned char *d = (unsigned char *)__dest, *s = (unsigned char *)__src;
+
+	for (i = __n >> 3; i > 0; i--) {
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+	}
+
+	if (__n & 1 << 2) {
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+		*d++ = *s++;
+	}
+
+	if (__n & 1 << 1) {
+		*d++ = *s++;
+		*d++ = *s++;
+	}
+
+	if (__n & 1)
+		*d++ = *s++;
+
+	return __dest;
+}
+
+/* ===========================================================================
+ * Fill the input buffer. This is called only when the buffer is empty
+ * and at least one byte is really needed.
+ */
+static int fill_inbuf(void)
+{
+	if (insize != 0) {
+		error("ran out of input data\n");
+	}
+
+	inbuf = input_data;
+	insize = input_len;
+	inptr = 1;
+	return inbuf[0];
+}
+
+/* ===========================================================================
+ * Write the output window window[0..outcnt-1] and update crc and bytes_out.
+ * (Used for the decompressed data only.)
+ */
+static void flush_window(void)
+{
+    ulg c = crc;         /* temporary variable */
+    unsigned n;
+    uch *in, *out, ch;
+
+    in = window;
+    out = &output_data[output_ptr];
+    for (n = 0; n < outcnt; n++) {
+	    ch = *out++ = *in++;
+	    c = crc_32_tab[((int)c ^ ch) & 0xff] ^ (c >> 8);
+    }
+    crc = c;
+    bytes_out += (ulg)outcnt;
+    output_ptr += (ulg)outcnt;
+    outcnt = 0;
+}
+
+static void error(char *x)
+{
+	puts("\n\n");
+	puts(x);
+	puts("\n\n -- System halted");
+
+	while(1);	/* Halt */
+}
+
+void decompress_kernel(unsigned int imageaddr, unsigned int imagesize, unsigned int loadaddr)
+{
+	input_data = (char *)imageaddr;
+	input_len = imagesize;
+	output_ptr = 0;
+	output_data = (uch *)loadaddr;
+	free_mem_ptr = (unsigned long)_end;
+	free_mem_end_ptr = free_mem_ptr + HEAP_SIZE;
+
+	makecrc();
+	puts("Uncompressing Linux...");
+	gunzip();
+	flushcaches();
+	puts("Ok, booting the kernel.");
+}
--- linux-2.6.24.7.old/arch/mips/boot/tools/entry	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/boot/tools/entry	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+# grab the kernel_entry address from the vmlinux elf image
+entry=`$1 $2  | grep kernel_entry`
+
+fs=`echo $entry | grep ffffffff`  # check toolchain output
+
+if [ -n "$fs" ]; then
+	echo "0x"`$1 $2  | grep kernel_entry | cut -c9- | awk '{print $1}'`
+else
+	echo "0x"`$1 $2  | grep kernel_entry | cut -c1- | awk '{print $1}'`
+fi
--- linux-2.6.24.7.old/arch/mips/boot/tools/filesize	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/boot/tools/filesize	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,7 @@
+#!/bin/sh
+HOSTNAME=`uname`
+if [ "$HOSTNAME" = "Linux" ]; then
+echo `ls -l $1 | awk '{print $5}'`
+else
+echo `ls -l $1 | awk '{print $6}'`
+fi
--- linux-2.6.24.7.old/arch/mips/configs/apus_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/configs/apus_defconfig	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,1205 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.24.3
+# Fri Dec 12 17:16:48 2008
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+# CONFIG_JZ4730_PMP is not set
+# CONFIG_JZ4740_PAVO is not set
+# CONFIG_JZ4740_LEO is not set
+# CONFIG_JZ4740_LYRA is not set
+# CONFIG_JZ4725_DIPPER is not set
+# CONFIG_JZ4720_VIRGO is not set
+# CONFIG_JZ4750_FUWA is not set
+CONFIG_JZ4750_APUS=y
+# CONFIG_MACH_ALCHEMY is not set
+# CONFIG_BASLER_EXCITE is not set
+# CONFIG_BCM47XX is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_LEMOTE_FULONG is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MARKEINS is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_PNX8550_STB810 is not set
+# CONFIG_PMC_MSP is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SNI_RM is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_WR_PPMC is not set
+CONFIG_SOC_JZ4750=y
+CONFIG_JZSOC=y
+CONFIG_JZRISC=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_ARCH_SUPPORTS_OPROFILE=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+# CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ is not set
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_NO_IOPORT is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+# CONFIG_CPU_LOONGSON2 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_MIPS_MT_DISABLED=y
+# CONFIG_MIPS_MT_SMP is not set
+# CONFIG_MIPS_MT_SMTC is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_TICK_ONESHOT is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_FORCE_MAX_ZONEORDER=12
+# CONFIG_HZ_48 is not set
+CONFIG_HZ_100=y
+# CONFIG_HZ_128 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_256 is not set
+# CONFIG_HZ_1000 is not set
+# CONFIG_HZ_1024 is not set
+CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+CONFIG_HZ=100
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_BKL=y
+# CONFIG_KEXEC is not set
+CONFIG_SECCOMP=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_FAIR_USER_SCHED=y
+# CONFIG_FAIR_CGROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_RELAY=y
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_MMU=y
+# CONFIG_PCCARD is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ_JZ=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_LEGACY=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_SUSPEND_UP_POSSIBLE=y
+# CONFIG_SUSPEND is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=m
+CONFIG_INET_TCP_DIAG=m
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_JZ4750=y
+# CONFIG_MTD_NAND_CS2 is not set
+# CONFIG_MTD_NAND_CS3 is not set
+# CONFIG_MTD_NAND_CS4 is not set
+CONFIG_MTD_NAND_MULTI_PLANE=y
+# CONFIG_MTD_HW_HM_ECC is not set
+# CONFIG_MTD_SW_HM_ECC is not set
+# CONFIG_MTD_HW_RS_ECC is not set
+CONFIG_MTD_HW_BCH_ECC=y
+CONFIG_MTD_HW_BCH_4BIT=y
+# CONFIG_MTD_HW_BCH_8BIT is not set
+CONFIG_MTD_NAND_DMA=y
+# CONFIG_MTD_NAND_DMABUF is not set
+# CONFIG_MTD_MTDBLOCK_WRITE_VERIFY_ENABLE is not set
+CONFIG_MTD_OOB_COPIES=3
+CONFIG_MTD_BADBLOCK_FLAG_PAGE=127
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_MTD_UBI_BLKDEVS is not set
+# CONFIG_PARPORT is not set
+# CONFIG_PNP is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVICES_MULTIQUEUE is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_JZCS8900=y
+# CONFIG_AX88796 is not set
+# CONFIG_DM9000 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_JZ is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=2
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RTC is not set
+# CONFIG_RTC_PCF8563 is not set
+# CONFIG_RTC_JZ is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+
+#
+# JZSOC char device support
+#
+CONFIG_JZCHAR=y
+# CONFIG_JZ_CIM is not set
+# CONFIG_JZ_TPANEL_ATA2508 is not set
+CONFIG_JZ_TPANEL=y
+CONFIG_JZ_SADC=y
+# CONFIG_JZ_TPANEL_AK4182 is not set
+# CONFIG_JZ_TPANEL_UCB1400 is not set
+# CONFIG_JZ_TPANEL_WM9712 is not set
+# CONFIG_JZ_UDC_HOTPLUG is not set
+CONFIG_JZ_POWEROFF=y
+# CONFIG_JZ_OW is not set
+CONFIG_JZ_TCSM=y
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_WATCHDOG is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_JZSOC=y
+CONFIG_FB_JZ4750_TVE=y
+# CONFIG_IPU_JZ4750 is not set
+CONFIG_FB_JZ4750_LCD=y
+# CONFIG_FB_JZ4750_LCD_USE_2LAYER_FRAMEBUFFER is not set
+# CONFIG_FB_JZ4750_SLCD is not set
+# CONFIG_JZ4750_LCD_SAMSUNG_LTP400WQF01 is not set
+# CONFIG_JZ4750_LCD_SAMSUNG_LTP400WQF02 is not set
+CONFIG_JZ4750_LCD_AUO_A043FL01V2=y
+# CONFIG_JZ4750_LCD_FOXCONN_PT035TN01 is not set
+# CONFIG_JZ4750_LCD_INNOLUX_PT035TN01_SERIAL is not set
+# CONFIG_JZ4750_LCD_TOPPOLY_TD025THEA7_RGB_DELTA is not set
+# CONFIG_JZ4750_LCD_TRULY_TFTG320240DTSW_18BIT is not set
+# CONFIG_JZ4750_LCD_TRULY_TFT_GG1P0319LTSW_W is not set
+# CONFIG_JZ4750_SLCD_KGM701A3_TFT_SPFD5420A is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_CURSOR_FLASH is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+CONFIG_SOUND_PRIME=y
+CONFIG_OSS_OBSOLETE=y
+# CONFIG_SOUND_JZ_AC97 is not set
+CONFIG_SOUND_JZ_I2S=y
+# CONFIG_SOUND_JZ_PCM is not set
+# CONFIG_I2S_AK4642EN is not set
+# CONFIG_I2S_ICODEC is not set
+CONFIG_I2S_DLV=y
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+CONFIG_USB_HIDDEV=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_PERSIST is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+
+#
+# MMC/SD Host Controller Drivers
+#
+CONFIG_MSC0_JZ4750=y
+# CONFIG_JZ4750_MSC0_BUS_1 is not set
+CONFIG_JZ4750_MSC0_BUS_4=y
+# CONFIG_JZ4750_MSC0_BUS_8 is not set
+# CONFIG_MSC1_JZ4750 is not set
+# CONFIG_JZ4750_BOOT_FROM_MSC0 is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# Userspace I/O
+#
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_MINIX_FS=y
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_DIRECTIO=y
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_BIND34 is not set
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Yaffs2 Filesystems
+#
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+CONFIG_YAFFS_DISABLE_CHUNK_ERASED_CHECK=y
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS=10
+CONFIG_INSTRUMENTATION=y
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SAMPLES is not set
+CONFIG_CMDLINE=""
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_MANAGER=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_ECB is not set
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
--- linux-2.6.24.7.old/arch/mips/configs/dipper_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/configs/dipper_defconfig	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,1281 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.24.3
+# Thu Jun 12 13:55:45 2008
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+# CONFIG_JZ4730_PMP is not set
+# CONFIG_JZ4740_PAVO is not set
+# CONFIG_JZ4740_LEO is not set
+# CONFIG_JZ4740_LYRA is not set
+CONFIG_JZ4725_DIPPER=y
+# CONFIG_JZ4720_VIRGO is not set
+# CONFIG_JZ4750_FUWA is not set
+# CONFIG_MACH_ALCHEMY is not set
+# CONFIG_BASLER_EXCITE is not set
+# CONFIG_BCM47XX is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_LEMOTE_FULONG is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MARKEINS is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_PNX8550_STB810 is not set
+# CONFIG_PMC_MSP is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SNI_RM is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_WR_PPMC is not set
+CONFIG_SOC_JZ4740=y
+CONFIG_SOC_JZ4725=y
+CONFIG_JZSOC=y
+CONFIG_JZRISC=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_ARCH_SUPPORTS_OPROFILE=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+# CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ is not set
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_NO_IOPORT is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+# CONFIG_CPU_LOONGSON2 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_MIPS_MT_DISABLED=y
+# CONFIG_MIPS_MT_SMP is not set
+# CONFIG_MIPS_MT_SMTC is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_TICK_ONESHOT is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_HZ_48 is not set
+CONFIG_HZ_100=y
+# CONFIG_HZ_128 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_256 is not set
+# CONFIG_HZ_1000 is not set
+# CONFIG_HZ_1024 is not set
+CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+CONFIG_HZ=100
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_BKL=y
+# CONFIG_KEXEC is not set
+CONFIG_SECCOMP=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_FAIR_USER_SCHED=y
+# CONFIG_FAIR_CGROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_RELAY=y
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_MMU=y
+# CONFIG_PCCARD is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ_JZ=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_LEGACY=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_SUSPEND_UP_POSSIBLE=y
+# CONFIG_SUSPEND is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_JZ4740=y
+# CONFIG_MTD_HW_HM_ECC is not set
+# CONFIG_MTD_SW_HM_ECC is not set
+CONFIG_MTD_HW_RS_ECC=y
+# CONFIG_MTD_MTDBLOCK_WRITE_VERIFY_ENABLE is not set
+CONFIG_MTD_OOB_COPIES=3
+CONFIG_MTD_BADBLOCK_FLAG_PAGE=0
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=m
+CONFIG_MTD_UBI_WL_THRESHOLD=256
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+CONFIG_MTD_UBI_BLKDEVS=m
+CONFIG_MTD_UBI_BLOCK=m
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG is not set
+
+#
+# Protocols
+#
+# CONFIG_PNPACPI is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVICES_MULTIQUEUE is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_NET_SB1000 is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_JZCS8900=y
+# CONFIG_AX88796 is not set
+# CONFIG_DM9000 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_NR_UARTS=2
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=2
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RTC is not set
+# CONFIG_RTC_PCF8563 is not set
+CONFIG_RTC_JZ=y
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+
+#
+# JZSOC char device support
+#
+CONFIG_JZCHAR=y
+# CONFIG_JZ_CIM is not set
+# CONFIG_JZ_TPANEL_ATA2508 is not set
+CONFIG_JZ_TPANEL=y
+CONFIG_JZ_SADC=y
+# CONFIG_JZ_TPANEL_AK4182 is not set
+# CONFIG_JZ_TPANEL_UCB1400 is not set
+# CONFIG_JZ_TPANEL_WM9712 is not set
+CONFIG_JZ_UDC_HOTPLUG=y
+CONFIG_JZ_POWEROFF=y
+# CONFIG_JZ_OW is not set
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_JZ_WDT=y
+# CONFIG_SOFT_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CPIA2 is not set
+CONFIG_VIDEO_JZ_CIM=y
+CONFIG_VIDEO_JZ_SENSOR=y
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_USB_VICAM is not set
+# CONFIG_USB_IBMCAM is not set
+# CONFIG_USB_KONICAWC is not set
+# CONFIG_USB_QUICKCAM_MESSENGER is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_OV511 is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_STV680 is not set
+# CONFIG_USB_ZC0301 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_USB_ZR364XX is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_USB_DSBR is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_JZSOC=y
+# CONFIG_FB_JZ4740_SLCD is not set
+CONFIG_FB_JZLCD_4730_4740=y
+CONFIG_JZLCD_FRAMEBUFFER_MAX=1
+# CONFIG_JZLCD_FRAMEBUFFER_ROTATE_SUPPORT is not set
+# CONFIG_JZLCD_SHARP_LQ035Q7 is not set
+# CONFIG_JZLCD_SAMSUNG_LTS350Q1 is not set
+# CONFIG_JZLCD_SAMSUNG_LTV350QVF04 is not set
+# CONFIG_JZLCD_SAMSUNG_LTP400WQF01 is not set
+CONFIG_JZLCD_SAMSUNG_LTP400WQF02=y
+# CONFIG_JZLCD_AUO_A030FL01_V1 is not set
+# CONFIG_JZLCD_TRULY_TFTG320240DTSW is not set
+# CONFIG_JZLCD_TRULY_TFTG320240DTSW_SERIAL is not set
+# CONFIG_JZLCD_TRULY_TFTG240320UTSW_63W_E is not set
+# CONFIG_JZLCD_FOXCONN_PT035TN01 is not set
+# CONFIG_JZLCD_INNOLUX_PT035TN01_SERIAL is not set
+# CONFIG_JZLCD_TOSHIBA_LTM084P363 is not set
+# CONFIG_JZLCD_HYNIX_HT10X21 is not set
+# CONFIG_JZLCD_INNOLUX_AT080TN42 is not set
+# CONFIG_JZLCD_CSTN_800x600 is not set
+# CONFIG_JZLCD_CSTN_320x240 is not set
+# CONFIG_JZLCD_MSTN_480x320 is not set
+# CONFIG_JZLCD_MSTN_320x240 is not set
+# CONFIG_JZLCD_MSTN_240x128 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_CURSOR_FLASH is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+CONFIG_SOUND_PRIME=y
+CONFIG_OSS_OBSOLETE=y
+# CONFIG_SOUND_JZ_AC97 is not set
+CONFIG_SOUND_JZ_I2S=y
+# CONFIG_SOUND_JZ_PCM is not set
+# CONFIG_I2S_AK4642EN is not set
+CONFIG_I2S_ICODEC=y
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_PERSIST is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_SELECTED=y
+CONFIG_USB_GADGET_JZ4740=y
+CONFIG_USB_JZ4740=m
+# CONFIG_USB_GADGET_JZ4730 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+
+#
+# MMC/SD Host Controller Drivers
+#
+CONFIG_MMC_JZ=y
+# CONFIG_JZ_MMC_BUS_4 is not set
+CONFIG_JZ_MMC_BUS_1=y
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# Userspace I/O
+#
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_MINIX_FS=y
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=m
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_DIRECTIO=y
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_BIND34 is not set
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Yaffs2 Filesystems
+#
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+CONFIG_YAFFS_DISABLE_CHUNK_ERASED_CHECK=y
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS=10
+CONFIG_INSTRUMENTATION=y
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SAMPLES is not set
+CONFIG_CMDLINE=""
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_MANAGER=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_ECB is not set
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_SEED is not set
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+CONFIG_CRYPTO_LZO=m
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_LZO_COMPRESS=m
+CONFIG_LZO_DECOMPRESS=m
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
--- linux-2.6.24.7.old/arch/mips/configs/fuwa_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/configs/fuwa_defconfig	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,928 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.24.3
+# Fri Jul  4 19:20:22 2008
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+# CONFIG_JZ4730_PMP is not set
+# CONFIG_JZ4740_PAVO is not set
+# CONFIG_JZ4740_LEO is not set
+# CONFIG_JZ4740_LYRA is not set
+# CONFIG_JZ4725_DIPPER is not set
+# CONFIG_JZ4720_VIRGO is not set
+CONFIG_JZ4750_FUWA=y
+# CONFIG_MACH_ALCHEMY is not set
+# CONFIG_BASLER_EXCITE is not set
+# CONFIG_BCM47XX is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_LEMOTE_FULONG is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MARKEINS is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_PNX8550_STB810 is not set
+# CONFIG_PMC_MSP is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SNI_RM is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_WR_PPMC is not set
+CONFIG_SOC_JZ4750=y
+CONFIG_JZ_FPGA=y
+CONFIG_JZSOC=y
+CONFIG_JZRISC=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_ARCH_SUPPORTS_OPROFILE=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+# CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ is not set
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_NO_IOPORT is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+# CONFIG_CPU_LOONGSON2 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_MIPS_MT_DISABLED=y
+# CONFIG_MIPS_MT_SMP is not set
+# CONFIG_MIPS_MT_SMTC is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_TICK_ONESHOT is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_HZ_48 is not set
+CONFIG_HZ_100=y
+# CONFIG_HZ_128 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_256 is not set
+# CONFIG_HZ_1000 is not set
+# CONFIG_HZ_1024 is not set
+CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+CONFIG_HZ=100
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_BKL=y
+# CONFIG_KEXEC is not set
+CONFIG_SECCOMP=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_FAIR_USER_SCHED=y
+# CONFIG_FAIR_CGROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_RELAY=y
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_MMU=y
+# CONFIG_PCCARD is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ_JZ is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_SUSPEND_UP_POSSIBLE=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=m
+CONFIG_INET_TCP_DIAG=m
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_EXT is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+CONFIG_MTD_NAND_JZ4750=y
+# CONFIG_MTD_HW_HM_ECC is not set
+# CONFIG_MTD_SW_HM_ECC is not set
+# CONFIG_MTD_HW_RS_ECC is not set
+CONFIG_MTD_HW_BCH_ECC=y
+CONFIG_MTD_NAND_DMA=y
+# CONFIG_MTD_NAND_NO_DMA is not set
+CONFIG_MTD_HW_BCH_4BIT=y
+# CONFIG_MTD_HW_BCH_8BIT is not set
+# CONFIG_MTD_MTDBLOCK_WRITE_VERIFY_ENABLE is not set
+CONFIG_MTD_OOB_COPIES=0
+CONFIG_MTD_BADBLOCK_FLAG_PAGE=127
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_MTD_UBI_BLKDEVS is not set
+# CONFIG_PARPORT is not set
+# CONFIG_PNP is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVICES_MULTIQUEUE is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_JZ_ETH=y
+# CONFIG_AX88796 is not set
+# CONFIG_DM9000 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_B44 is not set
+CONFIG_NETDEV_1000=y
+CONFIG_NETDEV_10000=y
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=2
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RTC is not set
+# CONFIG_RTC_PCF8563 is not set
+# CONFIG_RTC_JZ is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+
+#
+# JZSOC char device support
+#
+# CONFIG_JZCHAR is not set
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_WATCHDOG is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+# CONFIG_MMC is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# Userspace I/O
+#
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_MINIX_FS=y
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_DIRECTIO=y
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_BIND34 is not set
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Yaffs2 Filesystems
+#
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+CONFIG_YAFFS_DISABLE_CHUNK_ERASED_CHECK=y
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS=10
+CONFIG_INSTRUMENTATION=y
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SAMPLES is not set
+CONFIG_CMDLINE=""
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_MANAGER=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_ECB is not set
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
--- linux-2.6.24.7.old/arch/mips/configs/leo_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/configs/leo_defconfig	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,1256 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.24.3
+# Thu Jun 12 13:59:18 2008
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+# CONFIG_JZ4730_PMP is not set
+# CONFIG_JZ4740_PAVO is not set
+CONFIG_JZ4740_LEO=y
+# CONFIG_JZ4740_LYRA is not set
+# CONFIG_JZ4725_DIPPER is not set
+# CONFIG_JZ4720_VIRGO is not set
+# CONFIG_JZ4750_FUWA is not set
+# CONFIG_MACH_ALCHEMY is not set
+# CONFIG_BASLER_EXCITE is not set
+# CONFIG_BCM47XX is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_LEMOTE_FULONG is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MARKEINS is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_PNX8550_STB810 is not set
+# CONFIG_PMC_MSP is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SNI_RM is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_WR_PPMC is not set
+CONFIG_SOC_JZ4740=y
+CONFIG_JZSOC=y
+CONFIG_JZRISC=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_ARCH_SUPPORTS_OPROFILE=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+# CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ is not set
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_NO_IOPORT is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+# CONFIG_CPU_LOONGSON2 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_MIPS_MT_DISABLED=y
+# CONFIG_MIPS_MT_SMP is not set
+# CONFIG_MIPS_MT_SMTC is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_TICK_ONESHOT is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_HZ_48 is not set
+CONFIG_HZ_100=y
+# CONFIG_HZ_128 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_256 is not set
+# CONFIG_HZ_1000 is not set
+# CONFIG_HZ_1024 is not set
+CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+CONFIG_HZ=100
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_BKL=y
+# CONFIG_KEXEC is not set
+CONFIG_SECCOMP=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_FAIR_USER_SCHED=y
+# CONFIG_FAIR_CGROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_RELAY=y
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_MMU=y
+# CONFIG_PCCARD is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ_JZ=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_LEGACY=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_SUSPEND_UP_POSSIBLE=y
+# CONFIG_SUSPEND is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+CONFIG_MTD_BLOCK2MTD=y
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_JZ4740=y
+# CONFIG_MTD_HW_HM_ECC is not set
+CONFIG_MTD_SW_HM_ECC=y
+# CONFIG_MTD_HW_RS_ECC is not set
+# CONFIG_MTD_MTDBLOCK_WRITE_VERIFY_ENABLE is not set
+CONFIG_MTD_OOB_COPIES=3
+CONFIG_MTD_BADBLOCK_FLAG_PAGE=0
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=m
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+CONFIG_MTD_UBI_BLKDEVS=m
+CONFIG_MTD_UBI_BLOCK=m
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG is not set
+
+#
+# Protocols
+#
+# CONFIG_PNPACPI is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_NETDEVICES is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_NR_UARTS=2
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=2
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RTC is not set
+# CONFIG_RTC_PCF8563 is not set
+CONFIG_RTC_JZ=y
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+
+#
+# JZSOC char device support
+#
+CONFIG_JZCHAR=y
+# CONFIG_JZ_CIM is not set
+# CONFIG_JZ_TPANEL_ATA2508 is not set
+CONFIG_JZ_TPANEL=y
+CONFIG_JZ_SADC=y
+# CONFIG_JZ_TPANEL_AK4182 is not set
+# CONFIG_JZ_TPANEL_UCB1400 is not set
+# CONFIG_JZ_TPANEL_WM9712 is not set
+CONFIG_JZ_UDC_HOTPLUG=y
+CONFIG_JZ_POWEROFF=y
+# CONFIG_JZ_OW is not set
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_JZ_WDT=y
+# CONFIG_SOFT_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CPIA2 is not set
+CONFIG_VIDEO_JZ_CIM=y
+CONFIG_VIDEO_JZ_SENSOR=y
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_USB_VICAM is not set
+# CONFIG_USB_IBMCAM is not set
+# CONFIG_USB_KONICAWC is not set
+# CONFIG_USB_QUICKCAM_MESSENGER is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_OV511 is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_STV680 is not set
+# CONFIG_USB_ZC0301 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_USB_ZR364XX is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_USB_DSBR is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_JZSOC=y
+# CONFIG_FB_JZ4740_SLCD is not set
+CONFIG_FB_JZLCD_4730_4740=y
+CONFIG_JZLCD_FRAMEBUFFER_MAX=1
+# CONFIG_JZLCD_FRAMEBUFFER_ROTATE_SUPPORT is not set
+# CONFIG_JZLCD_SHARP_LQ035Q7 is not set
+# CONFIG_JZLCD_SAMSUNG_LTS350Q1 is not set
+# CONFIG_JZLCD_SAMSUNG_LTV350QVF04 is not set
+# CONFIG_JZLCD_SAMSUNG_LTP400WQF01 is not set
+CONFIG_JZLCD_SAMSUNG_LTP400WQF02=y
+# CONFIG_JZLCD_AUO_A030FL01_V1 is not set
+# CONFIG_JZLCD_TRULY_TFTG320240DTSW is not set
+# CONFIG_JZLCD_TRULY_TFTG320240DTSW_SERIAL is not set
+# CONFIG_JZLCD_TRULY_TFTG240320UTSW_63W_E is not set
+# CONFIG_JZLCD_FOXCONN_PT035TN01 is not set
+# CONFIG_JZLCD_INNOLUX_PT035TN01_SERIAL is not set
+# CONFIG_JZLCD_TOSHIBA_LTM084P363 is not set
+# CONFIG_JZLCD_HYNIX_HT10X21 is not set
+# CONFIG_JZLCD_INNOLUX_AT080TN42 is not set
+# CONFIG_JZLCD_CSTN_800x600 is not set
+# CONFIG_JZLCD_CSTN_320x240 is not set
+# CONFIG_JZLCD_MSTN_480x320 is not set
+# CONFIG_JZLCD_MSTN_320x240 is not set
+# CONFIG_JZLCD_MSTN_240x128 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_CURSOR_FLASH is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA MIPS devices
+#
+
+#
+# USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+
+#
+# System on Chip audio support
+#
+CONFIG_SND_SOC=y
+
+#
+# SoC Audio support for SuperH
+#
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_PERSIST is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_SELECTED=y
+CONFIG_USB_GADGET_JZ4740=y
+CONFIG_USB_JZ4740=m
+# CONFIG_USB_GADGET_JZ4730 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+CONFIG_USB_FILE_STORAGE_TEST=y
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+
+#
+# MMC/SD Host Controller Drivers
+#
+CONFIG_MMC_JZ=y
+CONFIG_JZ_MMC_BUS_4=y
+# CONFIG_JZ_MMC_BUS_1 is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# Userspace I/O
+#
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_MINIX_FS=y
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=m
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+CONFIG_UBIFS_FS_DEBUG=y
+CONFIG_UBIFS_FS_DEBUG_MSG_LVL=0
+# CONFIG_UBIFS_FS_DEBUG_CHKS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_DIRECTIO=y
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_BIND34 is not set
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Yaffs2 Filesystems
+#
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+CONFIG_YAFFS_DISABLE_CHUNK_ERASED_CHECK=y
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS=10
+CONFIG_INSTRUMENTATION=y
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SAMPLES is not set
+CONFIG_CMDLINE=""
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_MANAGER=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_ECB is not set
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_SEED is not set
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+CONFIG_CRYPTO_LZO=m
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_LZO_COMPRESS=m
+CONFIG_LZO_DECOMPRESS=m
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
--- linux-2.6.24.7.old/arch/mips/configs/lyra_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/configs/lyra_defconfig	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,981 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.24.3
+# Thu Jun 12 13:53:57 2008
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+# CONFIG_JZ4730_PMP is not set
+# CONFIG_JZ4740_PAVO is not set
+# CONFIG_JZ4740_LEO is not set
+CONFIG_JZ4740_LYRA=y
+# CONFIG_JZ4725_DIPPER is not set
+# CONFIG_JZ4720_VIRGO is not set
+# CONFIG_JZ4750_FUWA is not set
+# CONFIG_MACH_ALCHEMY is not set
+# CONFIG_BASLER_EXCITE is not set
+# CONFIG_BCM47XX is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_LEMOTE_FULONG is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MARKEINS is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_PNX8550_STB810 is not set
+# CONFIG_PMC_MSP is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SNI_RM is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_WR_PPMC is not set
+CONFIG_SOC_JZ4740=y
+CONFIG_JZSOC=y
+CONFIG_JZRISC=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_ARCH_SUPPORTS_OPROFILE=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+# CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ is not set
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_NO_IOPORT is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+# CONFIG_CPU_LOONGSON2 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_MIPS_MT_DISABLED=y
+# CONFIG_MIPS_MT_SMP is not set
+# CONFIG_MIPS_MT_SMTC is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_TICK_ONESHOT is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_HZ_48 is not set
+CONFIG_HZ_100=y
+# CONFIG_HZ_128 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_256 is not set
+# CONFIG_HZ_1000 is not set
+# CONFIG_HZ_1024 is not set
+CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+CONFIG_HZ=100
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_BKL=y
+# CONFIG_KEXEC is not set
+CONFIG_SECCOMP=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_FAIR_USER_SCHED=y
+# CONFIG_FAIR_CGROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_RELAY=y
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_MMU=y
+# CONFIG_PCCARD is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ_JZ=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_LEGACY=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND_UP_POSSIBLE=y
+CONFIG_SUSPEND=y
+
+#
+# Networking
+#
+# CONFIG_NET is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+CONFIG_MTD_BLOCK2MTD=y
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+CONFIG_MTD_NAND_JZ4740=y
+# CONFIG_MTD_HW_HM_ECC is not set
+# CONFIG_MTD_SW_HM_ECC is not set
+CONFIG_MTD_HW_RS_ECC=y
+# CONFIG_MTD_MTDBLOCK_WRITE_VERIFY_ENABLE is not set
+CONFIG_MTD_OOB_COPIES=3
+CONFIG_MTD_BADBLOCK_FLAG_PAGE=127
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=m
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+CONFIG_MTD_UBI_GLUEBI=y
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_MTD_UBI_BLKDEVS is not set
+# CONFIG_PARPORT is not set
+# CONFIG_PNP is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RTC is not set
+# CONFIG_RTC_PCF8563 is not set
+CONFIG_RTC_JZ=y
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+
+#
+# JZSOC char device support
+#
+CONFIG_JZCHAR=y
+# CONFIG_JZ_CIM is not set
+CONFIG_JZ_TPANEL_ATA2508=y
+# CONFIG_JZ_TPANEL is not set
+CONFIG_JZ_UDC_HOTPLUG=y
+CONFIG_JZ_POWEROFF=y
+# CONFIG_JZ_OW is not set
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_JZ_WDT=y
+# CONFIG_SOFT_WATCHDOG is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_JZSOC=y
+# CONFIG_FB_JZ4740_SLCD is not set
+CONFIG_FB_JZLCD_4730_4740=y
+CONFIG_JZLCD_FRAMEBUFFER_MAX=1
+# CONFIG_JZLCD_FRAMEBUFFER_ROTATE_SUPPORT is not set
+# CONFIG_JZLCD_SHARP_LQ035Q7 is not set
+# CONFIG_JZLCD_SAMSUNG_LTS350Q1 is not set
+# CONFIG_JZLCD_SAMSUNG_LTV350QVF04 is not set
+# CONFIG_JZLCD_SAMSUNG_LTP400WQF01 is not set
+# CONFIG_JZLCD_SAMSUNG_LTP400WQF02 is not set
+CONFIG_JZLCD_AUO_A030FL01_V1=y
+# CONFIG_JZLCD_TRULY_TFTG320240DTSW is not set
+# CONFIG_JZLCD_TRULY_TFTG320240DTSW_SERIAL is not set
+# CONFIG_JZLCD_TRULY_TFTG240320UTSW_63W_E is not set
+# CONFIG_JZLCD_FOXCONN_PT035TN01 is not set
+# CONFIG_JZLCD_INNOLUX_PT035TN01_SERIAL is not set
+# CONFIG_JZLCD_TOSHIBA_LTM084P363 is not set
+# CONFIG_JZLCD_HYNIX_HT10X21 is not set
+# CONFIG_JZLCD_INNOLUX_AT080TN42 is not set
+# CONFIG_JZLCD_CSTN_800x600 is not set
+# CONFIG_JZLCD_CSTN_320x240 is not set
+# CONFIG_JZLCD_MSTN_480x320 is not set
+# CONFIG_JZLCD_MSTN_320x240 is not set
+# CONFIG_JZLCD_MSTN_240x128 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_CURSOR_FLASH is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+CONFIG_SOUND_PRIME=y
+CONFIG_OSS_OBSOLETE=y
+# CONFIG_SOUND_JZ_AC97 is not set
+CONFIG_SOUND_JZ_I2S=y
+# CONFIG_SOUND_JZ_PCM is not set
+# CONFIG_I2S_AK4642EN is not set
+CONFIG_I2S_ICODEC=y
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=m
+CONFIG_USB_GADGET_DEBUG_FILES=y
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_SELECTED=y
+CONFIG_USB_GADGET_JZ4740=y
+CONFIG_USB_JZ4740=m
+# CONFIG_USB_GADGET_JZ4730 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+
+#
+# MMC/SD Host Controller Drivers
+#
+# CONFIG_MMC_JZ is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# Userspace I/O
+#
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+CONFIG_MINIX_FS=y
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=m
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+CONFIG_UBIFS_FS_DEBUG=y
+CONFIG_UBIFS_FS_DEBUG_MSG_LVL=0
+# CONFIG_UBIFS_FS_DEBUG_CHKS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Yaffs2 Filesystems
+#
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+CONFIG_YAFFS_DISABLE_CHUNK_ERASED_CHECK=y
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS=10
+CONFIG_INSTRUMENTATION=y
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SAMPLES is not set
+CONFIG_CMDLINE=""
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_MANAGER=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_ECB is not set
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_SEED is not set
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+CONFIG_CRYPTO_LZO=m
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_LZO_COMPRESS=m
+CONFIG_LZO_DECOMPRESS=m
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
--- linux-2.6.24.7.old/arch/mips/configs/pavo_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/configs/pavo_defconfig	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,1293 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.24.3
+# Sat Nov 15 16:15:17 2008
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+# CONFIG_JZ4730_PMP is not set
+CONFIG_JZ4740_PAVO=y
+# CONFIG_JZ4740_LEO is not set
+# CONFIG_JZ4740_LYRA is not set
+# CONFIG_JZ4725_DIPPER is not set
+# CONFIG_JZ4720_VIRGO is not set
+# CONFIG_JZ4750_FUWA is not set
+# CONFIG_JZ4750_APUS is not set
+# CONFIG_MACH_ALCHEMY is not set
+# CONFIG_BASLER_EXCITE is not set
+# CONFIG_BCM47XX is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_LEMOTE_FULONG is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MARKEINS is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_PNX8550_STB810 is not set
+# CONFIG_PMC_MSP is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SNI_RM is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_WR_PPMC is not set
+CONFIG_SOC_JZ4740=y
+CONFIG_JZSOC=y
+CONFIG_JZRISC=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_ARCH_SUPPORTS_OPROFILE=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+# CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ is not set
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_NO_IOPORT is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+# CONFIG_CPU_LOONGSON2 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_MIPS_MT_DISABLED=y
+# CONFIG_MIPS_MT_SMP is not set
+# CONFIG_MIPS_MT_SMTC is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_TICK_ONESHOT is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_HZ_48 is not set
+CONFIG_HZ_100=y
+# CONFIG_HZ_128 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_256 is not set
+# CONFIG_HZ_1000 is not set
+# CONFIG_HZ_1024 is not set
+CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+CONFIG_HZ=100
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_BKL=y
+# CONFIG_KEXEC is not set
+CONFIG_SECCOMP=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_FAIR_USER_SCHED=y
+# CONFIG_FAIR_CGROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_RELAY=y
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_MMU=y
+# CONFIG_PCCARD is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ_JZ=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_LEGACY=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_SUSPEND_UP_POSSIBLE=y
+# CONFIG_SUSPEND is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_JZ4740=y
+# CONFIG_MTD_NAND_CS2 is not set
+# CONFIG_MTD_NAND_CS3 is not set
+# CONFIG_MTD_NAND_CS4 is not set
+CONFIG_MTD_NAND_MULTI_PLANE=y
+# CONFIG_MTD_HW_HM_ECC is not set
+# CONFIG_MTD_SW_HM_ECC is not set
+CONFIG_MTD_HW_RS_ECC=y
+# CONFIG_MTD_HW_BCH_ECC is not set
+# CONFIG_MTD_MTDBLOCK_WRITE_VERIFY_ENABLE is not set
+CONFIG_MTD_OOB_COPIES=3
+CONFIG_MTD_BADBLOCK_FLAG_PAGE=127
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=m
+CONFIG_MTD_UBI_WL_THRESHOLD=256
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+CONFIG_MTD_UBI_BLKDEVS=m
+CONFIG_MTD_UBI_BLOCK=m
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG is not set
+
+#
+# Protocols
+#
+# CONFIG_PNPACPI is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVICES_MULTIQUEUE is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_NET_SB1000 is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_JZCS8900=y
+# CONFIG_AX88796 is not set
+# CONFIG_DM9000 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_NR_UARTS=2
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=2
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RTC is not set
+# CONFIG_RTC_PCF8563 is not set
+CONFIG_RTC_JZ=y
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+
+#
+# JZSOC char device support
+#
+CONFIG_JZCHAR=y
+# CONFIG_JZ_CIM is not set
+# CONFIG_JZ_TPANEL_ATA2508 is not set
+CONFIG_JZ_TPANEL=y
+CONFIG_JZ_SADC=y
+# CONFIG_JZ_TPANEL_AK4182 is not set
+# CONFIG_JZ_TPANEL_UCB1400 is not set
+# CONFIG_JZ_TPANEL_WM9712 is not set
+CONFIG_JZ_UDC_HOTPLUG=y
+CONFIG_JZ_POWEROFF=y
+# CONFIG_JZ_OW is not set
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_JZ_WDT=y
+# CONFIG_SOFT_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CPIA2 is not set
+CONFIG_VIDEO_JZ_CIM=y
+CONFIG_VIDEO_JZ_SENSOR=y
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_USB_VICAM is not set
+# CONFIG_USB_IBMCAM is not set
+# CONFIG_USB_KONICAWC is not set
+# CONFIG_USB_QUICKCAM_MESSENGER is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_OV511 is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_STV680 is not set
+# CONFIG_USB_ZC0301 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_USB_ZR364XX is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_USB_DSBR is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_JZSOC=y
+# CONFIG_FB_JZ4740_SLCD is not set
+CONFIG_FB_JZLCD_4730_4740=y
+CONFIG_JZLCD_FRAMEBUFFER_MAX=1
+# CONFIG_JZLCD_FRAMEBUFFER_ROTATE_SUPPORT is not set
+# CONFIG_JZLCD_SHARP_LQ035Q7 is not set
+# CONFIG_JZLCD_SAMSUNG_LTS350Q1 is not set
+# CONFIG_JZLCD_SAMSUNG_LTV350QVF04 is not set
+# CONFIG_JZLCD_SAMSUNG_LTP400WQF01 is not set
+CONFIG_JZLCD_SAMSUNG_LTP400WQF02=y
+# CONFIG_JZLCD_AUO_A030FL01_V1 is not set
+# CONFIG_JZLCD_TRULY_TFTG320240DTSW is not set
+# CONFIG_JZLCD_TRULY_TFTG320240DTSW_SERIAL is not set
+# CONFIG_JZLCD_TRULY_TFTG240320UTSW_63W_E is not set
+# CONFIG_JZLCD_FOXCONN_PT035TN01 is not set
+# CONFIG_JZLCD_INNOLUX_PT035TN01_SERIAL is not set
+# CONFIG_JZLCD_TOSHIBA_LTM084P363 is not set
+# CONFIG_JZLCD_HYNIX_HT10X21 is not set
+# CONFIG_JZLCD_INNOLUX_AT080TN42 is not set
+# CONFIG_JZLCD_CSTN_800x600 is not set
+# CONFIG_JZLCD_CSTN_320x240 is not set
+# CONFIG_JZLCD_MSTN_480x320 is not set
+# CONFIG_JZLCD_MSTN_320x240 is not set
+# CONFIG_JZLCD_MSTN_240x128 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_CURSOR_FLASH is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+CONFIG_SOUND_PRIME=y
+CONFIG_OSS_OBSOLETE=y
+# CONFIG_SOUND_JZ_AC97 is not set
+CONFIG_SOUND_JZ_I2S=y
+# CONFIG_SOUND_JZ_PCM is not set
+# CONFIG_I2S_AK4642EN is not set
+CONFIG_I2S_ICODEC=y
+# CONFIG_I2S_DLV is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_PERSIST is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_SELECTED=y
+CONFIG_USB_GADGET_JZ4740=y
+CONFIG_USB_JZ4740=m
+# CONFIG_USB_GADGET_JZ4730 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+
+#
+# MMC/SD Host Controller Drivers
+#
+CONFIG_MMC_JZ=y
+# CONFIG_JZ_MMC_BUS_1 is not set
+CONFIG_JZ_MMC_BUS_4=y
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# Userspace I/O
+#
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_MINIX_FS=y
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=m
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_DIRECTIO=y
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_BIND34 is not set
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Yaffs2 Filesystems
+#
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+# CONFIG_YAFFS_ECC_BCH is not set
+CONFIG_YAFFS_ECC_RS=y
+# CONFIG_YAFFS_ECC_HAMMING is not set
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+CONFIG_YAFFS_DISABLE_CHUNK_ERASED_CHECK=y
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS=10
+CONFIG_INSTRUMENTATION=y
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SAMPLES is not set
+CONFIG_CMDLINE=""
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_MANAGER=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_ECB is not set
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_SEED is not set
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+CONFIG_CRYPTO_LZO=m
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_LZO_COMPRESS=m
+CONFIG_LZO_DECOMPRESS=m
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
--- linux-2.6.24.7.old/arch/mips/configs/pmp_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/configs/pmp_defconfig	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,1212 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.24.3
+# Thu Jun 12 13:37:10 2008
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+CONFIG_JZ4730_PMP=y
+# CONFIG_JZ4740_PAVO is not set
+# CONFIG_JZ4740_LEO is not set
+# CONFIG_JZ4740_LYRA is not set
+# CONFIG_JZ4725_DIPPER is not set
+# CONFIG_JZ4720_VIRGO is not set
+# CONFIG_JZ4750_FUWA is not set
+# CONFIG_MACH_ALCHEMY is not set
+# CONFIG_BASLER_EXCITE is not set
+# CONFIG_BCM47XX is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_LEMOTE_FULONG is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MARKEINS is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_PNX8550_STB810 is not set
+# CONFIG_PMC_MSP is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SNI_RM is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_WR_PPMC is not set
+CONFIG_SOC_JZ4730=y
+CONFIG_JZSOC=y
+CONFIG_JZRISC=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_ARCH_SUPPORTS_OPROFILE=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+# CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ is not set
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_NO_IOPORT is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+# CONFIG_CPU_LOONGSON2 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_MIPS_MT_DISABLED=y
+# CONFIG_MIPS_MT_SMP is not set
+# CONFIG_MIPS_MT_SMTC is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_TICK_ONESHOT is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_HZ_48 is not set
+CONFIG_HZ_100=y
+# CONFIG_HZ_128 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_256 is not set
+# CONFIG_HZ_1000 is not set
+# CONFIG_HZ_1024 is not set
+CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+CONFIG_HZ=100
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_BKL=y
+# CONFIG_KEXEC is not set
+CONFIG_SECCOMP=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_FAIR_USER_SCHED=y
+# CONFIG_FAIR_CGROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_RELAY=y
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_MMU=y
+# CONFIG_PCCARD is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ_JZ=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_LEGACY=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND_UP_POSSIBLE=y
+CONFIG_SUSPEND=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_EXT is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_JZ4730=y
+CONFIG_MTD_HW_HM_ECC=y
+# CONFIG_MTD_SW_HM_ECC is not set
+# CONFIG_MTD_HW_RS_ECC is not set
+# CONFIG_MTD_MTDBLOCK_WRITE_VERIFY_ENABLE is not set
+CONFIG_MTD_OOB_COPIES=3
+CONFIG_MTD_BADBLOCK_FLAG_PAGE=0
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_MTD_UBI_BLKDEVS is not set
+# CONFIG_PARPORT is not set
+# CONFIG_PNP is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVICES_MULTIQUEUE is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_JZ_ETH=y
+# CONFIG_AX88796 is not set
+# CONFIG_DM9000 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RTC is not set
+CONFIG_RTC_PCF8563=y
+# CONFIG_RTC_JZ is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+
+#
+# JZSOC char device support
+#
+CONFIG_JZCHAR=y
+# CONFIG_JZ_CIM is not set
+# CONFIG_JZ_TPANEL_ATA2508 is not set
+CONFIG_JZ_TPANEL=y
+# CONFIG_JZ_SADC is not set
+CONFIG_JZ_TPANEL_AK4182=y
+# CONFIG_JZ_TPANEL_UCB1400 is not set
+# CONFIG_JZ_TPANEL_WM9712 is not set
+# CONFIG_JZ_UDC_HOTPLUG is not set
+CONFIG_JZ_POWEROFF=y
+# CONFIG_JZ_OW is not set
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_JZ_WDT=y
+# CONFIG_SOFT_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=y
+# CONFIG_VIDEO_V4L1 is not set
+# CONFIG_VIDEO_V4L1_COMPAT is not set
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+
+#
+# Encoders/decoders and other helper chips
+#
+
+#
+# Audio decoders
+#
+
+#
+# Video decoders
+#
+
+#
+# Video and audio decoders
+#
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_VIVI is not set
+CONFIG_VIDEO_JZ_CIM=m
+CONFIG_VIDEO_JZ_SENSOR=m
+# CONFIG_V4L_USB_DRIVERS is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_USB_DSBR is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_JZSOC=y
+CONFIG_FB_JZLCD_4730_4740=y
+CONFIG_JZLCD_FRAMEBUFFER_MAX=1
+# CONFIG_JZLCD_FRAMEBUFFER_ROTATE_SUPPORT is not set
+# CONFIG_JZLCD_SHARP_LQ035Q7 is not set
+# CONFIG_JZLCD_SAMSUNG_LTS350Q1 is not set
+# CONFIG_JZLCD_SAMSUNG_LTV350QVF04 is not set
+CONFIG_JZLCD_SAMSUNG_LTP400WQF01=y
+# CONFIG_JZLCD_SAMSUNG_LTP400WQF02 is not set
+# CONFIG_JZLCD_AUO_A030FL01_V1 is not set
+# CONFIG_JZLCD_TRULY_TFTG320240DTSW is not set
+# CONFIG_JZLCD_TRULY_TFTG320240DTSW_SERIAL is not set
+# CONFIG_JZLCD_TRULY_TFTG240320UTSW_63W_E is not set
+# CONFIG_JZLCD_FOXCONN_PT035TN01 is not set
+# CONFIG_JZLCD_INNOLUX_PT035TN01_SERIAL is not set
+# CONFIG_JZLCD_TOSHIBA_LTM084P363 is not set
+# CONFIG_JZLCD_HYNIX_HT10X21 is not set
+# CONFIG_JZLCD_INNOLUX_AT080TN42 is not set
+# CONFIG_JZLCD_CSTN_800x600 is not set
+# CONFIG_JZLCD_CSTN_320x240 is not set
+# CONFIG_JZLCD_MSTN_480x320 is not set
+# CONFIG_JZLCD_MSTN_320x240 is not set
+# CONFIG_JZLCD_MSTN_240x128 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_CURSOR_FLASH is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+CONFIG_USB_HIDDEV=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_PERSIST is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_MON is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_JZ4740 is not set
+CONFIG_USB_GADGET_JZ4730=y
+CONFIG_USB_JZ4730=m
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_GADGET_DUALSPEED is not set
+# CONFIG_USB_ZERO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+
+#
+# MMC/SD Host Controller Drivers
+#
+CONFIG_MMC_JZ=y
+CONFIG_JZ_MMC_BUS_4=y
+# CONFIG_JZ_MMC_BUS_1 is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# Userspace I/O
+#
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_JBD=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_MINIX_FS=y
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_BIND34 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Yaffs2 Filesystems
+#
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+CONFIG_YAFFS_DISABLE_CHUNK_ERASED_CHECK=y
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS=10
+CONFIG_INSTRUMENTATION=y
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SAMPLES is not set
+CONFIG_CMDLINE=""
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
--- linux-2.6.24.7.old/arch/mips/configs/slt50_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/configs/slt50_defconfig	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,1036 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.24.3
+# Tue Nov 25 09:38:56 2008
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+# CONFIG_JZ4730_PMP is not set
+# CONFIG_JZ4740_PAVO is not set
+# CONFIG_JZ4740_LEO is not set
+# CONFIG_JZ4740_LYRA is not set
+# CONFIG_JZ4725_DIPPER is not set
+# CONFIG_JZ4720_VIRGO is not set
+# CONFIG_JZ4750_FUWA is not set
+# CONFIG_JZ4750_APUS is not set
+CONFIG_JZ4750_SLT50=y
+# CONFIG_MACH_ALCHEMY is not set
+# CONFIG_BASLER_EXCITE is not set
+# CONFIG_BCM47XX is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_LEMOTE_FULONG is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MARKEINS is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_PNX8550_STB810 is not set
+# CONFIG_PMC_MSP is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SNI_RM is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_WR_PPMC is not set
+CONFIG_SOC_JZ4750=y
+CONFIG_JZSOC=y
+CONFIG_JZRISC=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_ARCH_SUPPORTS_OPROFILE=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+# CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ is not set
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_NO_IOPORT is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+# CONFIG_CPU_LOONGSON2 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_MIPS_MT_DISABLED=y
+# CONFIG_MIPS_MT_SMP is not set
+# CONFIG_MIPS_MT_SMTC is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_TICK_ONESHOT is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_HZ_48 is not set
+CONFIG_HZ_100=y
+# CONFIG_HZ_128 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_256 is not set
+# CONFIG_HZ_1000 is not set
+# CONFIG_HZ_1024 is not set
+CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+CONFIG_HZ=100
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_BKL=y
+# CONFIG_KEXEC is not set
+CONFIG_SECCOMP=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_FAIR_USER_SCHED=y
+# CONFIG_FAIR_CGROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_RELAY=y
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_MMU=y
+# CONFIG_PCCARD is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ_JZ is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_SUSPEND_UP_POSSIBLE=y
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=m
+CONFIG_INET_TCP_DIAG=m
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_JZ4750=y
+# CONFIG_MTD_NAND_CS2 is not set
+# CONFIG_MTD_NAND_CS3 is not set
+# CONFIG_MTD_NAND_CS4 is not set
+# CONFIG_MTD_NAND_MULTI_PLANE is not set
+# CONFIG_MTD_HW_HM_ECC is not set
+# CONFIG_MTD_SW_HM_ECC is not set
+# CONFIG_MTD_HW_RS_ECC is not set
+CONFIG_MTD_HW_BCH_ECC=y
+CONFIG_MTD_HW_BCH_4BIT=y
+# CONFIG_MTD_HW_BCH_8BIT is not set
+CONFIG_MTD_NAND_DMA=y
+# CONFIG_MTD_NAND_DMABUF is not set
+# CONFIG_MTD_MTDBLOCK_WRITE_VERIFY_ENABLE is not set
+CONFIG_MTD_OOB_COPIES=3
+CONFIG_MTD_BADBLOCK_FLAG_PAGE=127
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_MTD_UBI_BLKDEVS is not set
+# CONFIG_PARPORT is not set
+# CONFIG_PNP is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_NETDEVICES is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_JZ is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=2
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RTC is not set
+# CONFIG_RTC_PCF8563 is not set
+# CONFIG_RTC_JZ is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+
+#
+# JZSOC char device support
+#
+CONFIG_JZCHAR=y
+# CONFIG_JZ_CIM is not set
+# CONFIG_JZ_TPANEL_ATA2508 is not set
+# CONFIG_JZ_TPANEL is not set
+CONFIG_JZ_UDC_HOTPLUG=y
+# CONFIG_JZ_POWEROFF is not set
+# CONFIG_JZ_OW is not set
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_WATCHDOG is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+CONFIG_USB_HIDDEV=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+# CONFIG_MMC is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# Userspace I/O
+#
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_MINIX_FS=y
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_DIRECTIO=y
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_BIND34 is not set
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Yaffs2 Filesystems
+#
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+# CONFIG_YAFFS_ECC_BCH is not set
+CONFIG_YAFFS_ECC_RS=y
+# CONFIG_YAFFS_ECC_HAMMING is not set
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+CONFIG_YAFFS_DISABLE_CHUNK_ERASED_CHECK=y
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS=10
+CONFIG_INSTRUMENTATION=y
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SAMPLES is not set
+CONFIG_CMDLINE=""
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_MANAGER=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_ECB is not set
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
--- linux-2.6.24.7.old/arch/mips/configs/virgo_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/configs/virgo_defconfig	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,1281 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.24.3
+# Thu Jun 12 13:52:15 2008
+#
+CONFIG_MIPS=y
+
+#
+# Machine selection
+#
+# CONFIG_JZ4730_PMP is not set
+# CONFIG_JZ4740_PAVO is not set
+# CONFIG_JZ4740_LEO is not set
+# CONFIG_JZ4740_LYRA is not set
+# CONFIG_JZ4725_DIPPER is not set
+CONFIG_JZ4720_VIRGO=y
+# CONFIG_JZ4750_FUWA is not set
+# CONFIG_MACH_ALCHEMY is not set
+# CONFIG_BASLER_EXCITE is not set
+# CONFIG_BCM47XX is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
+# CONFIG_LEMOTE_FULONG is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MIPS_SIM is not set
+# CONFIG_MARKEINS is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PNX8550_JBS is not set
+# CONFIG_PNX8550_STB810 is not set
+# CONFIG_PMC_MSP is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_QEMU is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_BIGSUR is not set
+# CONFIG_SNI_RM is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_TOSHIBA_RBTX4938 is not set
+# CONFIG_WR_PPMC is not set
+CONFIG_SOC_JZ4740=y
+CONFIG_SOC_JZ4720=y
+CONFIG_JZSOC=y
+CONFIG_JZRISC=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_ARCH_SUPPORTS_OPROFILE=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER=y
+# CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ is not set
+CONFIG_DMA_NONCOHERENT=y
+CONFIG_DMA_NEED_PCI_MAP_STATE=y
+# CONFIG_HOTPLUG_CPU is not set
+# CONFIG_NO_IOPORT is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+
+#
+# CPU selection
+#
+# CONFIG_CPU_LOONGSON2 is not set
+CONFIG_CPU_MIPS32_R1=y
+# CONFIG_CPU_MIPS32_R2 is not set
+# CONFIG_CPU_MIPS64_R1 is not set
+# CONFIG_CPU_MIPS64_R2 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_CPU_MIPS32=y
+CONFIG_CPU_MIPSR1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+# CONFIG_64BIT is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_MIPS_MT_DISABLED=y
+# CONFIG_MIPS_MT_SMP is not set
+# CONFIG_MIPS_MT_SMTC is not set
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_TICK_ONESHOT is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_HZ_48 is not set
+CONFIG_HZ_100=y
+# CONFIG_HZ_128 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_256 is not set
+# CONFIG_HZ_1000 is not set
+# CONFIG_HZ_1024 is not set
+CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+CONFIG_HZ=100
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_BKL=y
+# CONFIG_KEXEC is not set
+CONFIG_SECCOMP=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_FAIR_USER_SCHED=y
+# CONFIG_FAIR_CGROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_RELAY=y
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+CONFIG_MMU=y
+# CONFIG_PCCARD is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_TRAD_SIGNALS=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ_JZ=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+CONFIG_PM_LEGACY=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_SUSPEND_UP_POSSIBLE=y
+# CONFIG_SUSPEND is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT=y
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_JZ4740=y
+# CONFIG_MTD_HW_HM_ECC is not set
+# CONFIG_MTD_SW_HM_ECC is not set
+CONFIG_MTD_HW_RS_ECC=y
+# CONFIG_MTD_MTDBLOCK_WRITE_VERIFY_ENABLE is not set
+CONFIG_MTD_OOB_COPIES=3
+CONFIG_MTD_BADBLOCK_FLAG_PAGE=127
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=m
+CONFIG_MTD_UBI_WL_THRESHOLD=256
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+CONFIG_MTD_UBI_BLKDEVS=m
+CONFIG_MTD_UBI_BLOCK=m
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG is not set
+
+#
+# Protocols
+#
+# CONFIG_PNPACPI is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_NETDEVICES_MULTIQUEUE is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_NET_SB1000 is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_JZCS8900=y
+# CONFIG_AX88796 is not set
+# CONFIG_DM9000 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_NR_UARTS=2
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=2
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RTC is not set
+# CONFIG_RTC_PCF8563 is not set
+CONFIG_RTC_JZ=y
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+
+#
+# JZSOC char device support
+#
+CONFIG_JZCHAR=y
+# CONFIG_JZ_CIM is not set
+# CONFIG_JZ_TPANEL_ATA2508 is not set
+CONFIG_JZ_TPANEL=y
+CONFIG_JZ_SADC=y
+# CONFIG_JZ_TPANEL_AK4182 is not set
+# CONFIG_JZ_TPANEL_UCB1400 is not set
+# CONFIG_JZ_TPANEL_WM9712 is not set
+CONFIG_JZ_UDC_HOTPLUG=y
+CONFIG_JZ_POWEROFF=y
+# CONFIG_JZ_OW is not set
+# CONFIG_I2C is not set
+
+#
+# SPI support
+#
+# CONFIG_SPI is not set
+# CONFIG_SPI_MASTER is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_JZ_WDT=y
+# CONFIG_SOFT_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CPIA2 is not set
+CONFIG_VIDEO_JZ_CIM=y
+CONFIG_VIDEO_JZ_SENSOR=y
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_USB_VICAM is not set
+# CONFIG_USB_IBMCAM is not set
+# CONFIG_USB_KONICAWC is not set
+# CONFIG_USB_QUICKCAM_MESSENGER is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_OV511 is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_STV680 is not set
+# CONFIG_USB_ZC0301 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_USB_ZR364XX is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_USB_DSBR is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_JZSOC=y
+# CONFIG_FB_JZ4740_SLCD is not set
+CONFIG_FB_JZLCD_4730_4740=y
+CONFIG_JZLCD_FRAMEBUFFER_MAX=1
+# CONFIG_JZLCD_FRAMEBUFFER_ROTATE_SUPPORT is not set
+# CONFIG_JZLCD_SHARP_LQ035Q7 is not set
+# CONFIG_JZLCD_SAMSUNG_LTS350Q1 is not set
+# CONFIG_JZLCD_SAMSUNG_LTV350QVF04 is not set
+# CONFIG_JZLCD_SAMSUNG_LTP400WQF01 is not set
+CONFIG_JZLCD_SAMSUNG_LTP400WQF02=y
+# CONFIG_JZLCD_AUO_A030FL01_V1 is not set
+# CONFIG_JZLCD_TRULY_TFTG320240DTSW is not set
+# CONFIG_JZLCD_TRULY_TFTG320240DTSW_SERIAL is not set
+# CONFIG_JZLCD_TRULY_TFTG240320UTSW_63W_E is not set
+# CONFIG_JZLCD_FOXCONN_PT035TN01 is not set
+# CONFIG_JZLCD_INNOLUX_PT035TN01_SERIAL is not set
+# CONFIG_JZLCD_TOSHIBA_LTM084P363 is not set
+# CONFIG_JZLCD_HYNIX_HT10X21 is not set
+# CONFIG_JZLCD_INNOLUX_AT080TN42 is not set
+# CONFIG_JZLCD_CSTN_800x600 is not set
+# CONFIG_JZLCD_CSTN_320x240 is not set
+# CONFIG_JZLCD_MSTN_480x320 is not set
+# CONFIG_JZLCD_MSTN_320x240 is not set
+# CONFIG_JZLCD_MSTN_240x128 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_CURSOR_FLASH is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+CONFIG_SOUND_PRIME=y
+CONFIG_OSS_OBSOLETE=y
+# CONFIG_SOUND_JZ_AC97 is not set
+CONFIG_SOUND_JZ_I2S=y
+# CONFIG_SOUND_JZ_PCM is not set
+# CONFIG_I2S_AK4642EN is not set
+CONFIG_I2S_ICODEC=y
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_PERSIST is not set
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_SELECTED=y
+CONFIG_USB_GADGET_JZ4740=y
+CONFIG_USB_JZ4740=m
+# CONFIG_USB_GADGET_JZ4730 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+
+#
+# MMC/SD Host Controller Drivers
+#
+CONFIG_MMC_JZ=y
+CONFIG_JZ_MMC_BUS_4=y
+# CONFIG_JZ_MMC_BUS_1 is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# Userspace I/O
+#
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_MINIX_FS=y
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=m
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_DIRECTIO=y
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_BIND34 is not set
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Yaffs2 Filesystems
+#
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+CONFIG_YAFFS_DISABLE_CHUNK_ERASED_CHECK=y
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS=10
+CONFIG_INSTRUMENTATION=y
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SAMPLES is not set
+CONFIG_CMDLINE=""
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_MANAGER=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_ECB is not set
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_SEED is not set
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+CONFIG_CRYPTO_LZO=m
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=m
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_LZO_COMPRESS=m
+CONFIG_LZO_DECOMPRESS=m
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
--- linux-2.6.24.7.old/arch/mips/jz4730/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4730/Makefile	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,22 @@
+#
+# Makefile for the Ingenic JZ4730.
+#
+
+# Object file lists.
+
+obj-y += prom.o irq.o time.o reset.o setup.o dma.o \
+	platform.o i2c.o
+
+obj-$(CONFIG_PROC_FS)		+= proc.o
+
+# board specific support
+
+obj-$(CONFIG_JZ4730_PMP)	+= board-pmp.o
+
+# CPU Frequency scaling support
+
+obj-$(CONFIG_CPU_FREQ_JZ)       +=cpufreq.o
+
+# PM support
+
+obj-$(CONFIG_PM_LEGACY)         +=pm.o sleep.o
--- linux-2.6.24.7.old/arch/mips/jz4730/board-pmp.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4730/board-pmp.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,109 @@
+/*
+ * linux/arch/mips/jz4730/board-pmp.c
+ *
+ * JZ4730 PMP board setup routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+
+#include <asm/jzsoc.h>
+
+extern void (*jz_timer_callback)(void);
+
+static void dancing(void)
+{
+	static unsigned int count = 0;
+
+	count ++;
+	count &= 1;
+	if (count)
+		__gpio_set_pin(GPIO_LED_EN);
+	else
+		__gpio_clear_pin(GPIO_LED_EN);
+}
+
+static void pmp_timer_ack(void)
+{
+	static unsigned int count = 0;
+	count ++;
+	if (count % 100 == 0) {
+		count = 0;
+		dancing();
+	}
+}
+
+static void __init board_cpm_setup(void)
+{
+	__cpm_start_all();
+}
+
+static void __init board_gpio_setup(void)
+{
+	/*
+	 * Most of the gpios have been setup in the bootloader.
+	 */
+
+	__harb_usb0_uhc();
+	__gpio_as_dma();
+	__gpio_as_eth();
+	__gpio_as_usb();
+	__gpio_as_lcd_master();
+#if defined(CONFIG_I2S_AK4642EN)
+	__gpio_as_scc1();
+#endif
+#if defined(CONFIG_I2S_TSC2301) || defined(CONFIG_I2S_TLC320AIC23)
+	__gpio_as_ssi();
+#endif
+	//__gpio_as_ac97();
+#if defined(CONFIG_I2S_TSC2301) || defined(CONFIG_I2S_TLC320AIC23) || defined(CONFIG_I2S_CS42L51)
+	__gpio_as_i2s_slave();
+#endif
+	__gpio_as_cim();
+	__gpio_as_msc();
+
+	__gpio_as_output(GPIO_LED_EN);
+	__gpio_set_pin(GPIO_LED_EN);
+
+	 __gpio_as_output(GPIO_DISP_OFF_N);
+	__gpio_set_pin(GPIO_DISP_OFF_N);
+	__gpio_as_output(GPIO_PWM0);
+	__gpio_set_pin(GPIO_PWM0);
+
+	__gpio_as_input(GPIO_RTC_IRQ);
+	__gpio_as_output(GPIO_USB_CLK_EN);
+	__gpio_set_pin(GPIO_USB_CLK_EN);
+
+	__gpio_as_input(GPIO_CHARG_STAT);
+	__gpio_disable_pull(GPIO_CHARG_STAT);
+
+        __gpio_as_input(GPIO_UDC_HOTPLUG);
+        __gpio_disable_pull(GPIO_UDC_HOTPLUG);
+        __gpio_disable_pull(54); /* fixed ic bug, the pull of gpio pin 86 is as pin 54 */
+}
+
+void __init jz_board_setup(void)
+{
+	printk("JZ4730 PMP board setup\n");
+
+	board_cpm_setup();
+	board_gpio_setup();
+
+	jz_timer_callback = pmp_timer_ack;
+}
--- linux-2.6.24.7.old/arch/mips/jz4730/cpufreq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4730/cpufreq.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,596 @@
+
+/*
+ * linux/arch/mips/jz4730/cpufreq.c
+ *
+ * cpufreq driver for JZ4730
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <linux/cpufreq.h>
+
+#include <asm/jzsoc.h>
+#include <asm/processor.h>
+
+#define dprintk(msg...) cpufreq_debug_printk(CPUFREQ_DEBUG_DRIVER, \
+						"cpufreq-jz4730", msg)
+
+#undef CHANGE_PLL
+
+#define PLL_UNCHANGED 0
+#define PLL_GOES_UP   1
+#define PLL_GOES_DOWN 2
+
+#define PLL_WAIT_500NS (500*(__cpm_get_iclk()/1000000000))
+
+/* Saved the boot-time parameters */
+static struct {
+	/* SDRAM parameters */
+	unsigned int mclk;  /* memory clock, KHz */
+	unsigned int tras;  /* RAS pulse width, cycles of mclk */
+	unsigned int rcd;   /* RAS to CAS Delay, cycles of mclk */
+	unsigned int tpc;   /* RAS Precharge time, cycles of mclk */
+	unsigned int trwl;  /* Write Precharge Time, cycles of mclk */
+	unsigned int trc;   /* RAS Cycle Time, cycles of mclk */
+	unsigned int rtcor; /* Refresh Time Constant */
+	unsigned int sdram_initialized;
+
+	/* LCD parameters */
+	unsigned int lcd_clk;    /* LCD clock, Hz */
+	unsigned int lcdpix_clk; /* LCD Pixel clock, Hz */
+	unsigned int lcd_clks_initialized;
+} boot_config;
+
+struct jz4730_freq_percpu_info {
+	struct cpufreq_frequency_table table[7];
+};
+
+static struct jz4730_freq_percpu_info jz4730_freq_table;
+
+/*
+ * This contains the registers value for an operating point.
+ * If only part of a register needs to change then there is
+ * a mask value for that register.
+ * When going to a new operating point the current register
+ * value is ANDed with the ~mask and ORed with the new value.
+ */
+struct dpm_regs {
+	u32 cfcr;         /* Clock Freq Control Register */
+	u32 cfcr_mask;    /* Clock Freq Control Register mask */
+	u32 cfcr2;        /* Clock Freq Control Register 2 */
+	u32 cfcr2_mask;   /* Clock Freq Control Register 2 mask */
+	u32 plcr1;        /* PLL1 Control Register */
+	u32 plcr1_mask;   /* PLL1 Control Register mask */
+	u32 pll_up_flag;  /* New PLL freq is higher than current or not */
+};
+
+extern jz_clocks_t jz_clocks;
+
+static void jz_update_clocks(void)
+{
+	/* Next clocks must be updated if we have changed
+	 * the PLL or divisors.
+	 */
+	jz_clocks.iclk = __cpm_get_iclk();
+	jz_clocks.sclk = __cpm_get_sclk();
+	jz_clocks.mclk = __cpm_get_mclk();
+	jz_clocks.pclk = __cpm_get_pclk();
+	jz_clocks.lcdclk = __cpm_get_lcdclk();
+	jz_clocks.pixclk = __cpm_get_pixclk();
+}
+
+static void
+jz_init_boot_config(void)
+{
+	if (!boot_config.lcd_clks_initialized) {
+		/* the first time to scale pll */
+		boot_config.lcd_clk = __cpm_get_lcdclk();
+		boot_config.lcdpix_clk = __cpm_get_pixclk();
+		boot_config.lcd_clks_initialized = 1;
+	}
+
+	if (!boot_config.sdram_initialized) {
+		/* the first time to scale frequencies */
+		unsigned int dmcr, rtcor;
+		unsigned int tras, rcd, tpc, trwl, trc;
+
+		dmcr = REG_EMC_DMCR;
+		rtcor = REG_EMC_RTCOR;
+
+		tras = (dmcr >> 13) & 0x7;
+		rcd = (dmcr >> 11) & 0x3;
+		tpc = (dmcr >> 8) & 0x7;
+		trwl = (dmcr >> 5) & 0x3;
+		trc = (dmcr >> 2) & 0x7;
+
+		boot_config.mclk = __cpm_get_mclk() / 1000;
+		boot_config.tras = tras + 4;
+		boot_config.rcd = rcd + 1;
+		boot_config.tpc = tpc + 1;
+		boot_config.trwl = trwl + 1;
+		boot_config.trc = trc * 2 + 1;
+		boot_config.rtcor = rtcor;
+
+		boot_config.sdram_initialized = 1;
+	}
+}
+
+static void jz_update_dram_rtcor(unsigned int new_mclk)
+{
+	unsigned int rtcor;
+
+	new_mclk /= 1000;
+	rtcor = boot_config.rtcor * new_mclk / boot_config.mclk;
+	rtcor--;
+
+	if (rtcor < 1) rtcor = 1;
+	if (rtcor > 255) rtcor = 255;
+
+	REG_EMC_RTCOR = rtcor;
+	REG_EMC_RTCNT = rtcor;
+}
+
+static void jz_update_dram_dmcr(unsigned int new_mclk)
+{
+	unsigned int dmcr;
+	unsigned int tras, rcd, tpc, trwl, trc;
+	unsigned int valid_time, new_time; /* ns */
+
+	new_mclk /= 1000;
+	tras = boot_config.tras * new_mclk / boot_config.mclk;
+	rcd = boot_config.rcd * new_mclk / boot_config.mclk;
+	tpc = boot_config.tpc * new_mclk / boot_config.mclk;
+	trwl = boot_config.trwl * new_mclk / boot_config.mclk;
+	trc = boot_config.trc * new_mclk / boot_config.mclk;
+
+	/* Validation checking */
+	valid_time = (boot_config.tras * 1000000) / boot_config.mclk;
+	new_time = (tras * 1000000) / new_mclk;
+	if (new_time < valid_time) tras += 1;
+
+	valid_time = (boot_config.rcd * 1000000) / boot_config.mclk;
+	new_time = (rcd * 1000000) / new_mclk;
+	if (new_time < valid_time) rcd += 1;
+
+	valid_time = (boot_config.tpc * 1000000) / boot_config.mclk;
+	new_time = (tpc * 1000000) / new_mclk;
+	if (new_time < valid_time) tpc += 1;
+
+	valid_time = (boot_config.trwl * 1000000) / boot_config.mclk;
+	new_time = (trwl * 1000000) / new_mclk;
+	if (new_time < valid_time) trwl += 1;
+
+	valid_time = (boot_config.trc * 1000000) / boot_config.mclk;
+	new_time = (trc * 1000000) / new_mclk;
+	if (new_time < valid_time) trc += 2;
+
+	tras = (tras < 4) ? 4: tras;
+	tras = (tras > 11) ? 11: tras;
+	tras -= 4;
+
+	rcd = (rcd < 1) ? 1: rcd;
+	rcd = (rcd > 4) ? 4: rcd;
+	rcd -= 1;
+
+	tpc = (tpc < 1) ? 1: tpc;
+	tpc = (tpc > 8) ? 8: tpc;
+	tpc -= 1;
+
+	trwl = (trwl < 1) ? 1: trwl;
+	trwl = (trwl > 4) ? 4: trwl;
+	trwl -= 1;
+
+	trc = (trc < 1) ? 1: trc;
+	trc = (trc > 15) ? 15: trc;
+	trc /= 2;
+
+	dmcr = REG_EMC_DMCR;
+
+	dmcr &= ~(EMC_DMCR_TRAS_MASK | EMC_DMCR_RCD_MASK | EMC_DMCR_TPC_MASK | EMC_DMCR_TRWL_MASK | EMC_DMCR_TRC_MASK);
+	dmcr |= ((tras << EMC_DMCR_TRAS_BIT) | (rcd << EMC_DMCR_RCD_BIT) | (tpc << EMC_DMCR_TPC_BIT) | (trwl << EMC_DMCR_TRWL_BIT) | (trc << EMC_DMCR_TRC_BIT));
+
+	REG_EMC_DMCR = dmcr;
+}
+
+static void jz_update_dram_prev(unsigned int cur_mclk, unsigned int new_mclk)
+{
+	/* No risk, no fun: run with interrupts on! */
+	if (new_mclk > cur_mclk) {
+		/* We're going FASTER, so first update TRAS, RCD, TPC, TRWL
+		 * and TRC of DMCR before changing the frequency.
+		 */
+		jz_update_dram_dmcr(new_mclk);
+	} else {
+		/* We're going SLOWER: first update RTCOR value
+		 * before changing the frequency.
+		 */
+		jz_update_dram_rtcor(new_mclk);
+	}
+}
+
+static void jz_update_dram_post(unsigned int cur_mclk, unsigned int new_mclk)
+{
+	/* No risk, no fun: run with interrupts on! */
+	if (new_mclk > cur_mclk) {
+		/* We're going FASTER, so update RTCOR
+		 * after changing the frequency
+		 */
+		jz_update_dram_rtcor(new_mclk);
+	} else {
+		/* We're going SLOWER: so update TRAS, RCD, TPC, TRWL
+		 * and TRC of DMCR after changing the frequency.
+		 */
+		jz_update_dram_dmcr(new_mclk);
+	}
+}
+
+static void jz_scale_divisors(struct dpm_regs *regs)
+{
+	unsigned int cfcr;
+	unsigned int cur_mclk, new_mclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned int tmp = 0, wait = PLL_WAIT_500NS;
+
+	cfcr = REG_CPM_CFCR;
+	cfcr &= ~((unsigned long)regs->cfcr_mask);
+	cfcr |= regs->cfcr;
+	cfcr |= CPM_CFCR_UPE;       /* update immediately */
+
+	cur_mclk = __cpm_get_mclk();
+	new_mclk = __cpm_get_pllout() / div[(cfcr & CPM_CFCR_MFR_MASK) >> CPM_CFCR_MFR_BIT];
+
+	/* Update some DRAM parameters before changing frequency */
+	jz_update_dram_prev(cur_mclk, new_mclk);
+
+	/* update register to change the clocks.
+	 * align this code to a cache line.
+	 */
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".align 5\n"
+		"sw %1,0(%0)\n\t"
+		"li %3,0\n\t"
+		"1:\n\t"
+		"bne %3,%2,1b\n\t"
+		"addi %3, 1\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set reorder\n\t"
+		:
+		: "r" (CPM_CFCR), "r" (cfcr), "r" (wait), "r" (tmp));
+
+	/* Update some other DRAM parameters after changing frequency */
+	jz_update_dram_post(cur_mclk, new_mclk);
+}
+
+#ifdef CHANGE_PLL
+/* Maintain the LCD clock and pixel clock */
+static void jz_scale_lcd_divisors(struct dpm_regs *regs)
+{
+	unsigned int new_pll, new_lcd_div, new_lcdpix_div;
+	unsigned int cfcr;
+	unsigned int tmp = 0, wait = PLL_WAIT_500NS;
+
+	if (!boot_config.lcd_clks_initialized) return;
+
+	new_pll = __cpm_get_pllout();
+	new_lcd_div = new_pll / boot_config.lcd_clk;
+	new_lcdpix_div = new_pll / boot_config.lcdpix_clk;
+
+	if (new_lcd_div < 1)
+		new_lcd_div = 1;
+	if (new_lcd_div > 16)
+		new_lcd_div = 16;
+
+	if (new_lcdpix_div < 1)
+		new_lcdpix_div = 1;
+	if (new_lcdpix_div > 512)
+		new_lcdpix_div = 512;
+
+	REG_CPM_CFCR2 = new_lcdpix_div - 1;
+
+	cfcr = REG_CPM_CFCR;
+	cfcr &= ~CPM_CFCR_LFR_MASK;
+	cfcr |= ((new_lcd_div - 1) << CPM_CFCR_LFR_BIT);
+	cfcr |= CPM_CFCR_UPE;       /* update immediately */
+
+	/* update register to change the clocks.
+	 * align this code to a cache line.
+	 */
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".align 5\n"
+		"sw %1,0(%0)\n\t"
+		"li %3,0\n\t"
+		"1:\n\t"
+		"bne %3,%2,1b\n\t"
+		"addi %3, 1\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set reorder\n\t"
+		:
+		: "r" (CPM_CFCR), "r" (cfcr), "r" (wait), "r" (tmp));
+}
+
+static void jz_scale_pll(struct dpm_regs *regs)
+{
+	unsigned int plcr1;
+	unsigned int cur_mclk, new_mclk, new_pll;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	int od[] = {1, 2, 2, 4};
+
+	plcr1 = REG_CPM_PLCR1;
+	plcr1 &= ~(regs->plcr1_mask | CPM_PLCR1_PLL1S | CPM_PLCR1_PLL1EN | CPM_PLCR1_PLL1ST_MASK);
+	regs->plcr1 &= ~CPM_PLCR1_PLL1EN;
+	plcr1 |= (regs->plcr1 | 0xff);
+
+	/* Update some DRAM parameters before changing frequency */
+	new_pll = JZ_EXTAL * ((plcr1>>23)+2) / ((((plcr1>>18)&0x1f)+2) * od[(plcr1>>16)&0x03]);
+	cur_mclk = __cpm_get_mclk();
+	new_mclk = new_pll / div[(REG_CPM_CFCR>>16) & 0xf];
+
+	/*
+	 * Update some SDRAM parameters
+	 */
+	jz_update_dram_prev(cur_mclk, new_mclk);
+
+	/*
+	 * Update PLL, align code to cache line.
+	 */
+	plcr1 |= CPM_PLCR1_PLL1EN;
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".align 5\n"
+		"sw %1,0(%0)\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set reorder\n\t"
+		:
+		: "r" (CPM_PLCR1), "r" (plcr1));
+
+	/* Update some other DRAM parameters after changing frequency */
+	jz_update_dram_post(cur_mclk, new_mclk);
+}
+#endif
+
+static void jz4730_transition(struct dpm_regs *regs)
+{
+	/*
+	 * Get and save some boot-time conditions.
+	 */
+	jz_init_boot_config();
+
+#ifdef CHANGE_PLL
+	/*
+	 * Disable LCD before scaling pll.
+	 * LCD and LCD pixel clocks should not be changed even if the PLL
+	 * output frequency has been changed.
+	 */
+	REG_LCD_CTRL &= ~LCD_CTRL_ENA;
+#endif
+	/*
+	 * Stop module clocks before scaling PLL
+	 */
+	__cpm_stop_eth();
+	__cpm_stop_aic_pclk();
+	__cpm_stop_aic_bitclk();
+
+	/* ... add more as necessary */
+
+	if (regs->pll_up_flag == PLL_GOES_UP) {
+		/* the pll frequency is going up, so change dividors first */
+		jz_scale_divisors(regs);
+#ifdef CHANGE_PLL
+		jz_scale_pll(regs);
+#endif
+	}
+	else if (regs->pll_up_flag == PLL_GOES_DOWN) {
+		/* the pll frequency is going down, so change pll first */
+#ifdef CHANGE_PLL
+		jz_scale_pll(regs);
+#endif
+		jz_scale_divisors(regs);
+	}
+	else {
+		/* the pll frequency is unchanged, so change divisors only */
+		jz_scale_divisors(regs);
+	}
+
+	/*
+	 * Restart module clocks before scaling PLL
+	 */
+	__cpm_start_eth();
+ 	__cpm_start_aic_pclk();
+	__cpm_start_aic_bitclk();
+
+	/* ... add more as necessary */
+
+#ifdef CHANGE_PLL
+	/* Scale the LCD divisors after scaling pll */
+	if (regs->pll_up_flag != PLL_UNCHANGED) {
+		jz_scale_lcd_divisors(regs);
+	}
+
+	/* Enable LCD controller */
+	REG_LCD_CTRL &= ~LCD_CTRL_DIS;
+	REG_LCD_CTRL |= LCD_CTRL_ENA;
+#endif
+
+	/* Update system clocks */
+	jz_update_clocks();
+}
+
+extern unsigned int idle_times;
+static unsigned int jz4730_freq_get(unsigned int cpu)
+{
+	return  (__cpm_get_iclk() / 1000);
+}
+
+static unsigned int index_to_divisor(unsigned int index, struct dpm_regs *regs)
+{
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[4] = {1, 2, 2, 2}; /* divisors of I:S:P:M */
+	unsigned int div_of_cclk, new_freq, i;
+
+	regs->pll_up_flag = PLL_UNCHANGED;
+	regs->cfcr_mask = CPM_CFCR_IFR_MASK | CPM_CFCR_SFR_MASK | CPM_CFCR_PFR_MASK | CPM_CFCR_MFR_MASK;
+
+	new_freq = jz4730_freq_table.table[index].frequency;
+
+	do {
+		div_of_cclk = __cpm_get_pllout() / (1000 * new_freq);
+	} while (div_of_cclk==0);
+
+	if(div_of_cclk == 1 || div_of_cclk == 2 || div_of_cclk == 4) {
+		for(i = 1; i<4; i++) {
+			div[i] = 3;
+		}
+	} else {
+		for(i = 1; i<4; i++) {
+			div[i] = 2;
+		}
+	}
+
+	for(i = 0; i<4; i++) {
+		div[i] *= div_of_cclk;
+	}
+
+	dprintk("divisors of I:S:P:M = %d:%d:%d:%d\n", div[0], div[1], div[2], div[3]);
+
+	regs->cfcr = (n2FR[div[0]] << CPM_CFCR_IFR_BIT) |
+		(n2FR[div[1]] << CPM_CFCR_SFR_BIT) |
+		(n2FR[div[2]] << CPM_CFCR_PFR_BIT) |
+		(n2FR[div[3]] << CPM_CFCR_MFR_BIT);
+
+	return  div_of_cclk;
+}
+
+static void jz4730_set_cpu_divider_index(unsigned int cpu, unsigned int index)
+{
+	unsigned long divisor, old_divisor;
+	struct cpufreq_freqs freqs;
+	struct dpm_regs regs;
+
+	old_divisor = __cpm_get_pllout() /  __cpm_get_iclk();
+	divisor = index_to_divisor(index, &regs);
+
+	freqs.old = __cpm_get_iclk() / 1000;
+	freqs.new =  __cpm_get_pllout() / (1000 * divisor);
+	freqs.cpu = cpu;
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+	if (old_divisor != divisor)
+		jz4730_transition(&regs);
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+}
+
+static int jz4730_freq_target(struct cpufreq_policy *policy,
+			  unsigned int target_freq,
+			  unsigned int relation)
+{
+	unsigned int new_index = 0;
+
+	if (cpufreq_frequency_table_target(policy,
+					   &jz4730_freq_table.table[0],
+					   target_freq, relation, &new_index))
+		return -EINVAL;
+
+	jz4730_set_cpu_divider_index(policy->cpu, new_index);
+
+	dprintk("new frequency is %d KHz (REG_CPM_CFCR:0x%x)\n", __cpm_get_iclk() / 1000, REG_CPM_CFCR);
+
+	return 0;
+}
+
+static int jz4730_freq_verify(struct cpufreq_policy *policy)
+{
+	return cpufreq_frequency_table_verify(policy,
+					      &jz4730_freq_table.table[0]);
+}
+
+static int __init jz4730_cpufreq_driver_init(struct cpufreq_policy *policy)
+{
+
+	struct cpufreq_frequency_table *table =	&jz4730_freq_table.table[0];
+	unsigned int MAX_FREQ;
+
+	dprintk(KERN_INFO "Jz4730 cpufreq driver\n");
+
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	policy->cur = MAX_FREQ = __cpm_get_iclk() / 1000; /* in kHz. Current and max frequency is determined by u-boot */
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+
+	policy->cpuinfo.min_freq = MAX_FREQ/8;
+	policy->cpuinfo.max_freq = MAX_FREQ;
+	policy->cpuinfo.transition_latency = 100000; /* in 10^(-9) s = nanoseconds */
+
+	table[0].index = 0;
+	table[0].frequency = MAX_FREQ/8;
+	table[1].index = 1;
+	table[1].frequency = MAX_FREQ/6;
+	table[2].index = 2;
+	table[2].frequency = MAX_FREQ/4;
+	table[3].index = 3;
+	table[3].frequency = MAX_FREQ/3;
+	table[4].index = 4;
+	table[4].frequency = MAX_FREQ/2;
+	table[5].index = 5;
+	table[5].frequency = MAX_FREQ;
+	table[6].index = 6;
+	table[6].frequency = CPUFREQ_TABLE_END;
+
+	return  cpufreq_frequency_table_cpuinfo(policy, table);
+}
+
+static struct cpufreq_driver cpufreq_jz4730_driver = {
+//	.flags		= CPUFREQ_STICKY,
+	.init		= jz4730_cpufreq_driver_init,
+	.verify		= jz4730_freq_verify,
+	.target		= jz4730_freq_target,
+	.get		= jz4730_freq_get,
+	.name		= "jz4730",
+};
+
+static int __init jz4730_cpufreq_init(void)
+{
+	return cpufreq_register_driver(&cpufreq_jz4730_driver);
+}
+
+static void __exit jz4730_cpufreq_exit(void)
+{
+		cpufreq_unregister_driver(&cpufreq_jz4730_driver);
+}
+
+module_init(jz4730_cpufreq_init);
+module_exit(jz4730_cpufreq_exit);
+
+MODULE_AUTHOR("Regen <lhhuang@ingenic.cn>");
+MODULE_DESCRIPTION("cpufreq driver for Jz4730");
+MODULE_LICENSE("GPL");
+
--- linux-2.6.24.7.old/arch/mips/jz4730/dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4730/dma.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,509 @@
+/*
+ * linux/arch/mips/jz4730/dma.c
+ *
+ * JZ4730 DMA PC-like APIs.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/soundcard.h>
+
+#include <asm/system.h>
+#include <asm/addrspace.h>
+#include <asm/jzsoc.h>
+
+/*
+ * A note on resource allocation:
+ *
+ * All drivers needing DMA channels, should allocate and release them
+ * through the public routines `jz_request_dma()' and `jz_free_dma()'.
+ *
+ * In order to avoid problems, all processes should allocate resources in
+ * the same sequence and release them in the reverse order.
+ *
+ * So, when allocating DMAs and IRQs, first allocate the DMA, then the IRQ.
+ * When releasing them, first release the IRQ, then release the DMA. The
+ * main reason for this order is that, if you are requesting the DMA buffer
+ * done interrupt, you won't know the irq number until the DMA channel is
+ * returned from jz_request_dma().
+ */
+
+struct jz_dma_chan jz_dma_table[NUM_DMA] = {
+	{dev_id:-1,},
+	{dev_id:-1,},
+	{dev_id:-1,},
+	{dev_id:-1,},
+	{dev_id:-1,},
+	{dev_id:-1,},
+};
+
+
+// Device FIFO addresses and default DMA modes
+static const struct {
+	unsigned int fifo_addr;
+	unsigned int dma_mode;
+	unsigned int dma_source;
+} dma_dev_table[NUM_DMA_DEV] = {
+	{CPHYSADDR(UART0_BASE), DMA_8bit_TX_CONF|DMA_MODE_WRITE, DMAC_DRSR_RS_UART0OUT},
+	{CPHYSADDR(UART0_BASE), DMA_8bit_RX_CONF|DMA_MODE_READ, DMAC_DRSR_RS_UART0IN},
+	{CPHYSADDR(UART1_BASE), DMA_8bit_TX_CONF|DMA_MODE_WRITE, DMAC_DRSR_RS_UART1OUT},
+	{CPHYSADDR(UART1_BASE), DMA_8bit_RX_CONF|DMA_MODE_READ, DMAC_DRSR_RS_UART1IN},
+	{CPHYSADDR(UART2_BASE), DMA_8bit_TX_CONF|DMA_MODE_WRITE, DMAC_DRSR_RS_UART2OUT},
+	{CPHYSADDR(UART2_BASE), DMA_8bit_RX_CONF|DMA_MODE_READ, DMAC_DRSR_RS_UART2IN},
+	{CPHYSADDR(UART3_BASE), DMA_8bit_TX_CONF|DMA_MODE_WRITE, DMAC_DRSR_RS_UART3OUT},
+	{CPHYSADDR(UART3_BASE), DMA_8bit_RX_CONF|DMA_MODE_READ, DMAC_DRSR_RS_UART3IN},
+	{CPHYSADDR(SSI_DR), DMA_32bit_TX_CONF|DMA_MODE_WRITE, DMAC_DRSR_RS_SSIOUT},
+	{CPHYSADDR(SSI_DR), DMA_32bit_RX_CONF|DMA_MODE_READ, DMAC_DRSR_RS_SSIIN},
+	{CPHYSADDR(MSC_TXFIFO), DMA_32bit_TX_CONF|DMA_MODE_WRITE, DMAC_DRSR_RS_MSCOUT},
+	{CPHYSADDR(MSC_RXFIFO), DMA_32bit_RX_CONF|DMA_MODE_READ, DMAC_DRSR_RS_MSCIN},
+	{CPHYSADDR(AIC_DR), DMA_32bit_TX_CONF|DMA_MODE_WRITE, DMAC_DRSR_RS_AICOUT},
+	{CPHYSADDR(AIC_DR), DMA_32bit_RX_CONF|DMA_MODE_READ, DMAC_DRSR_RS_AICIN},
+	{0, DMA_AUTOINIT, 0},
+};
+
+
+int jz_dma_read_proc(char *buf, char **start, off_t fpos,
+			 int length, int *eof, void *data)
+{
+	int i, len = 0;
+	struct jz_dma_chan *chan;
+
+	for (i = 0; i < NUM_DMA; i++) {
+		if ((chan = get_dma_chan(i)) != NULL) {
+			len += sprintf(buf + len, "%2d: %s\n",
+				       i, chan->dev_str);
+		}
+	}
+
+	if (fpos >= len) {
+		*start = buf;
+		*eof = 1;
+		return 0;
+	}
+	*start = buf + fpos;
+	if ((len -= fpos) > length)
+		return length;
+	*eof = 1;
+	return len;
+}
+
+
+void dump_jz_dma_channel(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan;
+
+	if (dmanr > NUM_DMA)
+		return;
+	chan = &jz_dma_table[dmanr];
+
+	printk(KERN_INFO "DMA%d Register Dump:\n", dmanr);
+	printk(KERN_INFO "  DMACR= 0x%08x\n", REG_DMAC_DMACR);
+	printk(KERN_INFO "  DSAR = 0x%08x\n", REG_DMAC_DSAR(dmanr));
+	printk(KERN_INFO "  DDAR = 0x%08x\n", REG_DMAC_DDAR(dmanr));
+	printk(KERN_INFO "  DTCR = 0x%08x\n", REG_DMAC_DTCR(dmanr));
+	printk(KERN_INFO "  DRSR = 0x%08x\n", REG_DMAC_DRSR(dmanr));
+	printk(KERN_INFO "  DCCSR = 0x%08x\n", REG_DMAC_DCCSR(dmanr));
+}
+
+
+/**
+ * jz_request_dma - dynamically allcate an idle DMA channel to return
+ * @dev_id: the specified dma device id or DMA_ID_RAW_REQ
+ * @dev_str: the specified dma device string name
+ * @irqhandler: the irq handler, or NULL
+ * @irqflags: the irq handler flags
+ * @irq_dev_id: the irq handler device id for shared irq
+ *
+ * Finds a free channel, and binds the requested device to it.
+ * Returns the allocated channel number, or negative on error.
+ * Requests the DMA done IRQ if irqhandler != NULL.
+ *
+*/
+int jz_request_dma(int dev_id, const char *dev_str,
+		     irqreturn_t (*irqhandler)(int, void *),
+		     unsigned long irqflags,
+		     void *irq_dev_id)
+{
+	struct jz_dma_chan *chan;
+	int i, ret;
+
+	if (dev_id < 0 || dev_id >= NUM_DMA_DEV)
+		return -EINVAL;
+
+	for (i = 0; i < NUM_DMA; i++) {
+		if (jz_dma_table[i].dev_id < 0)
+			break;
+	}
+	if (i == NUM_DMA)
+		return -ENODEV;
+
+	chan = &jz_dma_table[i];
+
+	if (irqhandler) {
+		chan->irq = IRQ_DMA_0 + i;	// see intc.h
+		chan->irq_dev = irq_dev_id;
+		if ((ret = request_irq(chan->irq, irqhandler, irqflags,
+				       dev_str, chan->irq_dev))) {
+			chan->irq = 0;
+			chan->irq_dev = NULL;
+			return ret;
+		}
+	} else {
+		chan->irq = 0;
+		chan->irq_dev = NULL;
+	}
+
+	// fill it in
+	chan->io = i;
+	chan->dev_id = dev_id;
+	chan->dev_str = dev_str;
+	chan->fifo_addr = dma_dev_table[dev_id].fifo_addr;
+	chan->mode = dma_dev_table[dev_id].dma_mode;
+	chan->source = dma_dev_table[dev_id].dma_source;
+
+	return i;
+}
+
+void jz_free_dma(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan) {
+		printk("Trying to free DMA%d\n", dmanr);
+		return;
+	}
+
+	disable_dma(dmanr);
+	if (chan->irq)
+		free_irq(chan->irq, chan->irq_dev);
+
+	chan->irq = 0;
+	chan->irq_dev = NULL;
+	chan->dev_id = -1;
+}
+
+void jz_set_dma_dest_width(int dmanr, int nbit)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+	       	return;
+	chan->mode &= ~DMAC_DCCSR_DWDH_MASK;
+	switch (nbit) {
+	case 8:
+		chan->mode |= DMAC_DCCSR_DWDH_8;
+		break;
+	case 16:
+		chan->mode |= DMAC_DCCSR_DWDH_16;
+		break;
+	case 32:
+		chan->mode |= DMAC_DCCSR_DWDH_32;
+		break;
+	}
+}
+
+void jz_set_dma_src_width(int dmanr, int nbit)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+	       	return;
+	chan->mode &= ~DMAC_DCCSR_SWDH_MASK;
+	switch (nbit) {
+	case 8:
+		chan->mode |= DMAC_DCCSR_SWDH_8;
+		break;
+	case 16:
+		chan->mode |= DMAC_DCCSR_SWDH_16;
+		break;
+	case 32:
+		chan->mode |= DMAC_DCCSR_SWDH_32;
+		break;
+	}
+}
+
+void jz_set_dma_block_size(int dmanr, int nbyte)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	chan->mode &= ~DMAC_DCCSR_DS_MASK;
+	switch (nbyte) {
+	case 1:
+		chan->mode |= DMAC_DCCSR_DS_8b;
+		break;
+	case 2:
+		chan->mode |= DMAC_DCCSR_DS_16b;
+		break;
+	case 4:
+		chan->mode |= DMAC_DCCSR_DS_32b;
+		break;
+	case 16:
+		chan->mode |= DMAC_DCCSR_DS_16B;
+		break;
+	case 32:
+		chan->mode |= DMAC_DCCSR_DS_32B;
+		break;
+	}
+}
+
+/**
+ * jz_set_dma_mode - do the raw settings for the specified DMA channel
+ * @dmanr: the specified DMA channel
+ * @mode: dma operate mode, DMA_MODE_READ or DMA_MODE_WRITE
+ * @dma_mode: dma raw mode
+ * @dma_source: dma raw request source
+ * @fifo_addr: dma raw device fifo address
+ *
+ * Ensure call jz_request_dma(DMA_ID_RAW_REQ, ...) first, then call
+ * jz_set_dma_mode() rather than set_dma_mode() if you work with
+ * and external request dma device.
+ *
+ * NOTE: Don not dynamically allocate dma channel if one external request
+ *       dma device will occupy this channel.
+*/
+int jz_set_dma_mode(unsigned int dmanr, unsigned int mode,
+		      unsigned int dma_mode, unsigned int dma_source,
+		      unsigned int fifo_addr)
+{
+	int dev_id, i;
+	struct jz_dma_chan *chan;
+
+	if (dmanr > NUM_DMA)
+		return -ENODEV;
+	for (i = 0; i < NUM_DMA; i++) {
+		if (jz_dma_table[i].dev_id < 0)
+			break;
+	}
+	if (i == NUM_DMA)
+		return -ENODEV;
+
+	chan = &jz_dma_table[dmanr];
+	dev_id = chan->dev_id;
+	if (dev_id > 0) {
+		printk(KERN_DEBUG "%s sets the allocated DMA channel %d!\n",
+		       __FUNCTION__, dmanr);
+		return -ENODEV;
+	}
+
+	/* clone it from the dynamically allocated. */
+	if (i != dmanr) {
+		chan->irq = jz_dma_table[i].irq;
+		chan->irq_dev = jz_dma_table[i].irq_dev;
+		chan->dev_str = jz_dma_table[i].dev_str;
+		jz_dma_table[i].irq = 0;
+		jz_dma_table[i].irq_dev = NULL;
+		jz_dma_table[i].dev_id = -1;
+	}
+	chan->dev_id = DMA_ID_RAW_SET;
+	chan->io = dmanr;
+	chan->fifo_addr = fifo_addr;
+	chan->mode = dma_mode;
+	chan->source = dma_source;
+
+	set_dma_mode(dmanr, dma_mode);
+
+	return dmanr;
+}
+
+void enable_dma(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+
+	REG_DMAC_DCCSR(chan->io) &= ~(DMAC_DCCSR_HLT | DMAC_DCCSR_TC | DMAC_DCCSR_AR);
+	__dmac_enable_channel(dmanr);
+	if (chan->irq)
+		__dmac_channel_enable_irq(dmanr);
+}
+
+#define DMA_DISABLE_POLL 0x5000
+
+void disable_dma(unsigned int dmanr)
+{
+	int i;
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	if (!__dmac_channel_enabled(dmanr))
+		return;
+
+	for (i = 0; i < DMA_DISABLE_POLL; i++)
+		if (__dmac_channel_transmit_end_detected(dmanr))
+			break;
+#if 0
+	if (i == DMA_DISABLE_POLL)
+		printk(KERN_INFO "disable_dma: poll expired!\n");
+#endif
+
+	__dmac_disable_channel(dmanr);
+	if (chan->irq)
+		__dmac_channel_disable_irq(dmanr);
+}
+
+/* note: DMA_MODE_MASK is simulated by sw, DCCSR_MODE_MASK mask hw bits */
+void set_dma_mode(unsigned int dmanr, unsigned int mode)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	mode &= ~(DMAC_DCCSR_TC | DMAC_DCCSR_AR);
+	chan->mode |= mode & ~(DMAC_DCCSR_SAM | DMAC_DCCSR_EACKM | DMAC_DCCSR_DAM);
+	mode &= DMA_MODE_MASK;
+	if (mode == DMA_MODE_READ) {
+		chan->mode |= DMAC_DCCSR_DAM;
+		chan->mode &= ~DMAC_DCCSR_SAM;
+	} else if (mode == DMA_MODE_WRITE) {
+		chan->mode |= DMAC_DCCSR_SAM | DMAC_DCCSR_EACKM;
+		chan->mode &= ~DMAC_DCCSR_DAM;
+	} else {
+		printk(KERN_DEBUG "set_dma_mode() support DMA_MODE_READ or DMA_MODE_WRITE!\n");
+	}
+	REG_DMAC_DCCSR(chan->io) = chan->mode & ~DMA_MODE_MASK;
+	REG_DMAC_DRSR(chan->io) = chan->source;
+}
+
+void jz_set_oss_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	switch (audio_fmt) {
+	case AFMT_U8:
+		/* SNDRV_PCM_FORMAT_S8 burst mode : 32BIT */
+		break;
+	case AFMT_S16_LE:
+		/* SNDRV_PCM_FORMAT_S16_LE burst mode : 16BYTE */
+		if (mode == DMA_MODE_READ) {
+			mode &= ~(DMAC_DCCSR_TC | DMAC_DCCSR_AR);
+			chan->mode = DMA_AIC_32_16BYTE_RX_CMD | DMA_MODE_READ;
+			chan->mode |= mode & ~(DMAC_DCCSR_SAM | DMAC_DCCSR_EACKM | DMAC_DCCSR_DAM);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCCSR_DAM;
+			chan->mode &= ~DMAC_DCCSR_SAM;
+		} else if (mode == DMA_MODE_WRITE) {
+			mode &= ~(DMAC_DCCSR_TC | DMAC_DCCSR_AR);
+			chan->mode = DMA_AIC_32_16BYTE_TX_CMD | DMA_MODE_WRITE;
+			chan->mode |= mode & ~(DMAC_DCCSR_SAM | DMAC_DCCSR_EACKM |DMAC_DCCSR_DAM);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCCSR_SAM | DMAC_DCCSR_EACKM;
+			chan->mode &= ~DMAC_DCCSR_DAM;
+		} else
+			printk("jz_set_oss_dma() just supports DMA_MODE_READ or DMA_MODE_WRITE!\n");
+
+		REG_DMAC_DCCSR(chan->io) = chan->mode & ~DMA_MODE_MASK;
+		REG_DMAC_DRSR(chan->io) = chan->source;
+		break;
+	}
+}
+
+void jz_set_alsa_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	switch (audio_fmt) {
+	case 8:
+		/* SNDRV_PCM_FORMAT_S8 burst mode : 32BIT */
+		break;
+	case 16:
+		/* SNDRV_PCM_FORMAT_S16_LE burst mode : 16BYTE */
+		if (mode == DMA_MODE_READ) {
+			mode &= ~(DMAC_DCCSR_TC | DMAC_DCCSR_AR);
+			chan->mode = DMA_AIC_16BYTE_RX_CMD | DMA_MODE_READ;
+			chan->mode |= mode & ~(DMAC_DCCSR_SAM | DMAC_DCCSR_EACKM | DMAC_DCCSR_DAM);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCCSR_DAM;
+			chan->mode &= ~DMAC_DCCSR_SAM;
+		} else if (mode == DMA_MODE_WRITE) {
+			mode &= ~(DMAC_DCCSR_TC | DMAC_DCCSR_AR);
+			chan->mode = DMA_AIC_16BYTE_TX_CMD | DMA_MODE_WRITE;
+			chan->mode |= mode & ~(DMAC_DCCSR_SAM | DMAC_DCCSR_EACKM | DMAC_DCCSR_DAM);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCCSR_SAM | DMAC_DCCSR_EACKM;
+			chan->mode &= ~DMAC_DCCSR_DAM;
+		} else
+			printk("jz_set_alsa_dma() just supports DMA_MODE_READ or DMA_MODE_WRITE!\n");
+
+		REG_DMAC_DCCSR(chan->io) = chan->mode & ~DMA_MODE_MASK;
+		REG_DMAC_DRSR(chan->io) = chan->source;
+		break;
+	}
+}
+
+void set_dma_addr(unsigned int dmanr, unsigned int a)
+{
+	unsigned int mode;
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return;
+	mode = chan->mode & DMA_MODE_MASK;
+	if (mode == DMA_MODE_READ) {
+		REG_DMAC_DSAR(chan->io) = chan->fifo_addr;
+		REG_DMAC_DDAR(chan->io) = a;
+	} else if (mode == DMA_MODE_WRITE) {
+		REG_DMAC_DSAR(chan->io) = a;
+		REG_DMAC_DDAR(chan->io) = chan->fifo_addr;
+	} else
+		printk(KERN_DEBUG "Driver should call set_dma_mode() ahead set_dma_addr()!\n");
+}
+
+void set_dma_count(unsigned int dmanr, unsigned int count)
+{
+	unsigned int mode;
+	int dma_ds[] = {4, 1, 2, 16, 32};
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+	       	return;
+       	mode = (chan->mode & DMAC_DCCSR_DS_MASK) >> DMAC_DCCSR_DS_BIT;
+	count = count / dma_ds[mode];
+	REG_DMAC_DTCR(chan->io) = count;
+}
+
+int get_dma_residue(unsigned int dmanr)
+{
+	int count;
+	unsigned int mode;
+	int dma_ds[] = {4, 1, 2, 16, 32};
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 0;
+
+	mode = (chan->mode & DMAC_DCCSR_DS_MASK) >> DMAC_DCCSR_DS_BIT;
+	count = REG_DMAC_DTCR(chan->io);
+	count = count * dma_ds[mode];
+
+	return count;
+}
+
+EXPORT_SYMBOL(jz_dma_table);
+EXPORT_SYMBOL(jz_request_dma);
+EXPORT_SYMBOL(jz_free_dma);
+EXPORT_SYMBOL(jz_set_dma_src_width);
+EXPORT_SYMBOL(jz_set_dma_dest_width);
+EXPORT_SYMBOL(jz_set_dma_block_size);
+EXPORT_SYMBOL(jz_set_dma_mode);
+EXPORT_SYMBOL(set_dma_mode);
+EXPORT_SYMBOL(jz_set_oss_dma);
+EXPORT_SYMBOL(jz_set_alsa_dma);
+EXPORT_SYMBOL(set_dma_addr);
+EXPORT_SYMBOL(set_dma_count);
+EXPORT_SYMBOL(get_dma_residue);
+EXPORT_SYMBOL(enable_dma);
+EXPORT_SYMBOL(disable_dma);
+EXPORT_SYMBOL(dump_jz_dma_channel);
--- linux-2.6.24.7.old/arch/mips/jz4730/i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4730/i2c.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,214 @@
+/*
+ * linux/arch/mips/jz4730/i2c.c
+ *
+ * JZ4730 I2C APIs.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <asm/addrspace.h>
+
+#include <asm/jzsoc.h>
+
+/* I2C protocol */
+#define I2C_READ	1
+#define I2C_WRITE	0
+
+#define TIMEOUT         1000
+
+/*
+ * I2C bus protocol basic routines
+ */
+static int i2c_put_data(unsigned char data)
+{
+	unsigned int timeout = TIMEOUT * 10;
+
+	__i2c_write(data);
+	__i2c_set_drf();
+	while (__i2c_check_drf() != 0);
+	while (!__i2c_transmit_ended());
+	while (!__i2c_received_ack() && timeout)
+		timeout--;
+
+	if (timeout)
+		return 0;
+	else
+		return -ETIMEDOUT;
+}
+
+static int i2c_get_data(unsigned char *data, int ack)
+{
+	int timeout = TIMEOUT*10;
+
+	if (!ack)
+		__i2c_send_nack();
+	else
+		__i2c_send_ack();
+
+	while (__i2c_check_drf() == 0 && timeout)
+		timeout--;
+
+	if (timeout) {
+		if (!ack)
+			__i2c_send_stop();
+		*data = __i2c_read();
+		__i2c_clear_drf();
+		return 0;
+	} else
+		return -ETIMEDOUT;
+}
+
+/*
+ * I2C interface
+ */
+void i2c_open(void)
+{
+	__i2c_set_clk(jz_clocks.devclk, 10000); /* default 10 KHz */
+	__i2c_enable();
+}
+
+void i2c_close(void)
+{
+	udelay(300); /* wait for STOP goes over. */
+	__i2c_disable();
+}
+
+void i2c_setclk(unsigned int i2cclk)
+{
+	__i2c_set_clk(jz_clocks.devclk, i2cclk);
+}
+
+int i2c_lseek(unsigned char device, unsigned char offset)
+{
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_err;
+	if (i2c_put_data(offset) < 0)
+		goto address_err;
+	return 0;
+ device_err:
+	printk(KERN_DEBUG "No I2C device (0x%02x) installed.\n", device);
+	__i2c_send_stop();
+	return -ENODEV;
+ address_err:
+	printk(KERN_DEBUG "No I2C device (0x%02x) response.\n", device);
+	__i2c_send_stop();
+	return -EREMOTEIO;
+}
+
+int i2c_read(unsigned char device, unsigned char *buf,
+	     unsigned char address, int count)
+{
+	int cnt = count;
+	int timeout = 5;
+
+L_try_again:
+
+	if (timeout < 0)
+		goto L_timeout;
+
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_werr;
+	if (i2c_put_data(address) < 0)
+		goto address_err;
+
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_READ ) < 0)
+		goto device_rerr;
+	__i2c_send_ack();	/* Master sends ACK for continue reading */
+	while (cnt) {
+		if (cnt == 1) {
+			if (i2c_get_data(buf, 0) < 0)
+				break;
+		} else {
+			if (i2c_get_data(buf, 1) < 0)
+				break;
+		}
+		cnt--;
+		buf++;
+	}
+
+	__i2c_send_stop();
+	return count - cnt;
+ device_rerr:
+ device_werr:
+ address_err:
+	timeout --;
+	__i2c_send_stop();
+	goto L_try_again;
+
+L_timeout:
+	__i2c_send_stop();
+	printk("Read I2C device 0x%2x failed.\n", device);
+	return -ENODEV;
+}
+
+int i2c_write(unsigned char device, unsigned char *buf,
+	      unsigned char address, int count)
+{
+	int cnt = count;
+	int cnt_in_pg;
+	int timeout = 5;
+	unsigned char *tmpbuf;
+	unsigned char tmpaddr;
+
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+
+ W_try_again:
+	if (timeout < 0)
+		goto W_timeout;
+
+	cnt = count;
+	tmpbuf = (unsigned char *)buf;
+	tmpaddr = address;
+
+ start_write_page:
+	cnt_in_pg = 0;
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_err;
+	if (i2c_put_data(tmpaddr) < 0)
+		goto address_err;
+	while (cnt) {
+		if (++cnt_in_pg > 8) {
+			__i2c_send_stop();
+			mdelay(1);
+			tmpaddr += 8;
+			goto start_write_page;
+		}
+		if (i2c_put_data(*tmpbuf) < 0)
+			break;
+		cnt--;
+		tmpbuf++;
+	}
+	__i2c_send_stop();
+	return count - cnt;
+ device_err:
+ address_err:
+	timeout--;
+	__i2c_send_stop();
+	goto W_try_again;
+
+ W_timeout:
+	printk(KERN_DEBUG "Write I2C device 0x%2x failed.\n", device);
+	__i2c_send_stop();
+	return -ENODEV;
+}
+
+EXPORT_SYMBOL(i2c_open);
+EXPORT_SYMBOL(i2c_close);
+EXPORT_SYMBOL(i2c_setclk);
+EXPORT_SYMBOL(i2c_read);
+EXPORT_SYMBOL(i2c_write);
--- linux-2.6.24.7.old/arch/mips/jz4730/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4730/irq.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,266 @@
+/*
+ * linux/arch/mips/jz4730/irq.c
+ *
+ * JZ4730 interrupt routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/jzsoc.h>
+
+/*
+ * INTC irq type
+ */
+
+static void enable_intc_irq(unsigned int irq)
+{
+	__intc_unmask_irq(irq);
+}
+
+static void disable_intc_irq(unsigned int irq)
+{
+	__intc_mask_irq(irq);
+}
+
+static void mask_and_ack_intc_irq(unsigned int irq)
+{
+	__intc_mask_irq(irq);
+	__intc_ack_irq(irq);
+}
+
+static void end_intc_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		enable_intc_irq(irq);
+	}
+}
+
+static unsigned int startup_intc_irq(unsigned int irq)
+{
+	enable_intc_irq(irq);
+	return 0;
+}
+
+static void shutdown_intc_irq(unsigned int irq)
+{
+	disable_intc_irq(irq);
+}
+
+static struct irq_chip intc_irq_type = {
+	.typename = "INTC",
+	.startup = startup_intc_irq,
+	.shutdown = shutdown_intc_irq,
+	.enable = enable_intc_irq,
+	.disable = disable_intc_irq,
+	.ack = mask_and_ack_intc_irq,
+	.end = end_intc_irq,
+};
+
+/*
+ * GPIO irq type
+ */
+
+static void enable_gpio_irq(unsigned int irq)
+{
+	unsigned int intc_irq;
+
+	if (irq < (IRQ_GPIO_0 + 32)) {
+		intc_irq = IRQ_GPIO0;
+	}
+	else if (irq < (IRQ_GPIO_0 + 64)) {
+		intc_irq = IRQ_GPIO1;
+	}
+	else if (irq < (IRQ_GPIO_0 + 96)) {
+		intc_irq = IRQ_GPIO2;
+	}
+	else {
+		intc_irq = IRQ_GPIO3;
+	}
+
+	enable_intc_irq(intc_irq);
+	__gpio_unmask_irq(irq - IRQ_GPIO_0);
+}
+
+static void disable_gpio_irq(unsigned int irq)
+{
+	__gpio_mask_irq(irq - IRQ_GPIO_0);
+}
+
+static void mask_and_ack_gpio_irq(unsigned int irq)
+{
+	__gpio_mask_irq(irq - IRQ_GPIO_0);
+	__gpio_ack_irq(irq - IRQ_GPIO_0);
+}
+
+static void end_gpio_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		enable_gpio_irq(irq);
+	}
+}
+
+static unsigned int startup_gpio_irq(unsigned int irq)
+{
+	enable_gpio_irq(irq);
+	return 0;
+}
+
+static void shutdown_gpio_irq(unsigned int irq)
+{
+	disable_gpio_irq(irq);
+}
+
+static struct irq_chip gpio_irq_type = {
+	.typename = "GPIO",
+	.startup = startup_gpio_irq,
+	.shutdown = shutdown_gpio_irq,
+	.enable = enable_gpio_irq,
+	.disable = disable_gpio_irq,
+	.ack = mask_and_ack_gpio_irq,
+	.end = end_gpio_irq,
+};
+
+/*
+ * DMA irq type
+ */
+
+static void enable_dma_irq(unsigned int irq)
+{
+	__intc_unmask_irq(IRQ_DMAC);
+	__dmac_channel_enable_irq(irq - IRQ_DMA_0);
+}
+
+static void disable_dma_irq(unsigned int irq)
+{
+	__dmac_channel_disable_irq(irq - IRQ_DMA_0);
+}
+
+static void mask_and_ack_dma_irq(unsigned int irq)
+{
+	__intc_ack_irq(IRQ_DMAC);
+	__dmac_channel_disable_irq(irq - IRQ_DMA_0);
+}
+
+static void end_dma_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		enable_dma_irq(irq);
+	}
+}
+
+static unsigned int startup_dma_irq(unsigned int irq)
+{
+	enable_dma_irq(irq);
+	return 0;
+}
+
+static void shutdown_dma_irq(unsigned int irq)
+{
+	disable_dma_irq(irq);
+}
+
+static struct irq_chip dma_irq_type = {
+	.typename = "DMA",
+	.startup = startup_dma_irq,
+	.shutdown = shutdown_dma_irq,
+	.enable = enable_dma_irq,
+	.disable = disable_dma_irq,
+	.ack = mask_and_ack_dma_irq,
+	.end = end_dma_irq,
+};
+
+//----------------------------------------------------------------------
+
+void __init arch_init_irq(void)
+{
+	int i;
+
+	clear_c0_status(0xff04); /* clear ERL */
+	set_c0_status(0x0400);   /* set IP2 */
+
+	/* Set up INTC irq
+	 */
+	for (i = 0; i < 32; i++) {
+		disable_intc_irq(i);
+		irq_desc[i].chip = &intc_irq_type;
+	}
+
+	/* Set up DMAC irq
+	 */
+	for (i = 0; i < NUM_DMA; i++) {
+		disable_dma_irq(IRQ_DMA_0 + i);
+		irq_desc[IRQ_DMA_0 + i].chip = &dma_irq_type;
+	}
+
+	/* Set up GPIO irq
+	 */
+	for (i = 0; i < NUM_GPIO; i++) {
+		disable_gpio_irq(IRQ_GPIO_0 + i);
+		irq_desc[IRQ_GPIO_0 + i].chip = &gpio_irq_type;
+	}
+}
+
+static int plat_real_irq(int irq)
+{
+	switch (irq) {
+	case IRQ_GPIO0:
+		irq = __gpio_group_irq(0) + IRQ_GPIO_0;
+		break;
+	case IRQ_GPIO1:
+		irq = __gpio_group_irq(1) + IRQ_GPIO_0 + 32;
+		break;
+	case IRQ_GPIO2:
+		irq = __gpio_group_irq(2) + IRQ_GPIO_0 + 64;
+		break;
+	case IRQ_GPIO3:
+		irq = __gpio_group_irq(3) + IRQ_GPIO_0 + 96;
+		break;
+	case IRQ_DMAC:
+		irq = __dmac_get_irq() + IRQ_DMA_0;
+		break;
+	}
+
+	return irq;
+}
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	int irq = 0;
+	static unsigned long intc_ipr = 0;
+
+	intc_ipr |= REG_INTC_IPR;
+
+	if (!intc_ipr)	return;
+
+	irq = ffs(intc_ipr) - 1;
+	intc_ipr &= ~(1<<irq);
+
+	irq = plat_real_irq(irq);
+
+	do_IRQ(irq);
+}
--- linux-2.6.24.7.old/arch/mips/jz4730/platform.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4730/platform.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,140 @@
+/*
+ * Platform device support for Jz4730 SoC.
+ *
+ * Copyright 2007, Peter <jlwei@ingenic.cn>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/resource.h>
+
+#include <asm/jzsoc.h>
+
+/* OHCI (USB full speed host controller) */
+static struct resource jz_usb_ohci_resources[] = {
+	[0] = {
+		.start		= CPHYSADDR(UHC_BASE), // phys addr for ioremap
+		.end		= CPHYSADDR(UHC_BASE) + 0x10000 - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_UHC,
+		.end		= IRQ_UHC,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+/* The dmamask must be set for OHCI to work */
+static u64 ohci_dmamask = ~(u32)0;
+
+static struct platform_device jz_usb_ohci_device = {
+	.name		= "jz-ohci",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &ohci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(jz_usb_ohci_resources),
+	.resource	= jz_usb_ohci_resources,
+};
+
+/*** LCD controller ***/
+static struct resource jz_lcd_resources[] = {
+	[0] = {
+		.start          = CPHYSADDR(LCD_BASE),
+		.end            = CPHYSADDR(LCD_BASE) + 0x10000 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start          = IRQ_LCD,
+		.end            = IRQ_LCD,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static u64 jz_lcd_dmamask = ~(u32)0;
+
+static struct platform_device jz_lcd_device = {
+	.name           = "jz-lcd",
+	.id             = 0,
+	.dev = {
+		.dma_mask               = &jz_lcd_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(jz_lcd_resources),
+	.resource       = jz_lcd_resources,
+};
+
+/* UDC (USB gadget controller) */
+static struct resource jz_usb_gdt_resources[] = {
+	[0] = {
+		.start		= CPHYSADDR(UDC_BASE),
+		.end		= CPHYSADDR(UDC_BASE) + 0x10000 - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_UDC,
+		.end		= IRQ_UDC,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static u64 udc_dmamask = ~(u32)0;
+
+static struct platform_device jz_usb_gdt_device = {
+	.name		= "jz-udc",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &udc_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(jz_usb_gdt_resources),
+	.resource	= jz_usb_gdt_resources,
+};
+
+/** MMC/SD controller **/
+static struct resource jz_mmc_resources[] = {
+	[0] = {
+		.start          = CPHYSADDR(MSC_BASE),
+		.end            = CPHYSADDR(MSC_BASE) + 0x10000 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start          = IRQ_MSC,
+		.end            = IRQ_MSC,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static u64 jz_mmc_dmamask =  ~(u32)0;
+
+static struct platform_device jz_mmc_device = {
+	.name = "jz-mmc",
+	.id = 0,
+	.dev = {
+		.dma_mask               = &jz_mmc_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(jz_mmc_resources),
+	.resource       = jz_mmc_resources,
+};
+
+/* All */
+static struct platform_device *jz_platform_devices[] __initdata = {
+	&jz_usb_ohci_device,
+	&jz_lcd_device,
+	&jz_usb_gdt_device,
+	&jz_mmc_device,
+};
+
+static int __init jz_platform_init(void)
+{
+	return platform_add_devices(jz_platform_devices, ARRAY_SIZE(jz_platform_devices));
+}
+
+arch_initcall(jz_platform_init);
--- linux-2.6.24.7.old/arch/mips/jz4730/pm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4730/pm.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,1098 @@
+/*
+ * linux/arch/mips/jz4730/pm.c
+ *
+ * Jz4730 Power Management Routines
+ *
+ * Copyright 2005 Ingenic Semiconductor
+ *      Wei Jianli <jlwei@ingenic.cn>
+ *      Huang Lihong<lhhuang@ingenic.cn>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/pm.h>
+#include <linux/pm_legacy.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/sysctl.h>
+
+#include <asm/cacheops.h>
+#include <asm/jzsoc.h>
+
+extern void jz_cpu_suspend(void);
+extern void jz_cpu_resume(void);
+
+static void jz_board_pm_suspend(void);
+
+#define SAVE(x,s)	sleep_save[SLEEP_SAVE_##x] = REG##s(x)
+#define RESTORE(x,s)	REG##s(x) = sleep_save[SLEEP_SAVE_##x]
+
+/*
+ * List of global jz4730 peripheral registers to preserve.
+ * More ones like core register and general purpose register values
+ * are preserved with the stack pointer in sleep.S.
+ */
+enum {	SLEEP_SAVE_START = 0,
+
+	/* CPM */
+	SLEEP_SAVE_CPM_MSCR, SLEEP_SAVE_CPM_PLCR1,
+
+	/* WDT */
+	SLEEP_SAVE_WDT_WTCNT, SLEEP_SAVE_WDT_WTCSR,
+
+	/* OST */
+	SLEEP_SAVE_OST_TER,
+	SLEEP_SAVE_OST_TCSR0, SLEEP_SAVE_OST_TCSR1, SLEEP_SAVE_OST_TCSR2,
+	SLEEP_SAVE_OST_TRDR0, SLEEP_SAVE_OST_TRDR1, SLEEP_SAVE_OST_TRDR2,
+	SLEEP_SAVE_OST_TCNT0, SLEEP_SAVE_OST_TCNT1, SLEEP_SAVE_OST_TCNT2,
+
+	/* HARB */
+	SLEEP_SAVE_HARB_HAPOR, SLEEP_SAVE_HARB_HMCTR, SLEEP_SAVE_HARB_HMLTR,
+
+	/* EMC */
+	SLEEP_SAVE_EMC_SMCR0, SLEEP_SAVE_EMC_SMCR1, SLEEP_SAVE_EMC_SMCR2, SLEEP_SAVE_EMC_SMCR3,
+	SLEEP_SAVE_EMC_SMCR4, SLEEP_SAVE_EMC_SMCR5,
+
+	/* GPIO */
+	SLEEP_SAVE_GPIO_GPDR0, SLEEP_SAVE_GPIO_GPDR1, SLEEP_SAVE_GPIO_GPDR2, SLEEP_SAVE_GPIO_GPDR3,
+	SLEEP_SAVE_GPIO_GPDIR0, SLEEP_SAVE_GPIO_GPDIR1, SLEEP_SAVE_GPIO_GPDIR2,	SLEEP_SAVE_GPIO_GPDIR3,
+	SLEEP_SAVE_GPIO_GPODR0, SLEEP_SAVE_GPIO_GPODR1, SLEEP_SAVE_GPIO_GPODR2,	SLEEP_SAVE_GPIO_GPODR3,
+	SLEEP_SAVE_GPIO_GPPUR0, SLEEP_SAVE_GPIO_GPPUR1, SLEEP_SAVE_GPIO_GPPUR2, SLEEP_SAVE_GPIO_GPPUR3,
+	SLEEP_SAVE_GPIO_GPALR0, SLEEP_SAVE_GPIO_GPALR1, SLEEP_SAVE_GPIO_GPALR2,	SLEEP_SAVE_GPIO_GPALR3,
+	SLEEP_SAVE_GPIO_GPAUR0, SLEEP_SAVE_GPIO_GPAUR1, SLEEP_SAVE_GPIO_GPAUR2,	SLEEP_SAVE_GPIO_GPAUR3,
+	SLEEP_SAVE_GPIO_GPIDLR0, SLEEP_SAVE_GPIO_GPIDLR1, SLEEP_SAVE_GPIO_GPIDLR2, SLEEP_SAVE_GPIO_GPIDLR3,
+	SLEEP_SAVE_GPIO_GPIDUR0, SLEEP_SAVE_GPIO_GPIDUR1, SLEEP_SAVE_GPIO_GPIDUR2, SLEEP_SAVE_GPIO_GPIDUR3,
+	SLEEP_SAVE_GPIO_GPIER0, SLEEP_SAVE_GPIO_GPIER1, SLEEP_SAVE_GPIO_GPIER2,	SLEEP_SAVE_GPIO_GPIER3,
+	SLEEP_SAVE_GPIO_GPIMR0, SLEEP_SAVE_GPIO_GPIMR1, SLEEP_SAVE_GPIO_GPIMR2, SLEEP_SAVE_GPIO_GPIMR3,
+	SLEEP_SAVE_GPIO_GPFR0, SLEEP_SAVE_GPIO_GPFR1, SLEEP_SAVE_GPIO_GPFR2, SLEEP_SAVE_GPIO_GPFR3,
+
+	/* UART(0-3) */
+	SLEEP_SAVE_UART0_IER, SLEEP_SAVE_UART0_LCR, SLEEP_SAVE_UART0_MCR, SLEEP_SAVE_UART0_SPR, SLEEP_SAVE_UART0_DLLR, SLEEP_SAVE_UART0_DLHR,
+	SLEEP_SAVE_UART1_IER, SLEEP_SAVE_UART1_LCR, SLEEP_SAVE_UART1_MCR, SLEEP_SAVE_UART1_SPR, SLEEP_SAVE_UART1_DLLR, SLEEP_SAVE_UART1_DLHR,
+	SLEEP_SAVE_UART2_IER, SLEEP_SAVE_UART2_LCR, SLEEP_SAVE_UART2_MCR, SLEEP_SAVE_UART2_SPR, SLEEP_SAVE_UART2_DLLR, SLEEP_SAVE_UART2_DLHR,
+	SLEEP_SAVE_UART3_IER, SLEEP_SAVE_UART3_LCR, SLEEP_SAVE_UART3_MCR, SLEEP_SAVE_UART3_SPR, SLEEP_SAVE_UART3_DLLR, SLEEP_SAVE_UART3_DLHR,
+
+	/* DMAC */
+	SLEEP_SAVE_DMAC_DMACR,
+	SLEEP_SAVE_DMAC_DSAR0, SLEEP_SAVE_DMAC_DSAR1, SLEEP_SAVE_DMAC_DSAR2, SLEEP_SAVE_DMAC_DSAR3, SLEEP_SAVE_DMAC_DSAR4, SLEEP_SAVE_DMAC_DSAR5, SLEEP_SAVE_DMAC_DSAR6, SLEEP_SAVE_DMAC_DSAR7,
+	SLEEP_SAVE_DMAC_DDAR0, SLEEP_SAVE_DMAC_DDAR1, SLEEP_SAVE_DMAC_DDAR2, SLEEP_SAVE_DMAC_DDAR3, SLEEP_SAVE_DMAC_DDAR4, SLEEP_SAVE_DMAC_DDAR5, SLEEP_SAVE_DMAC_DDAR6, SLEEP_SAVE_DMAC_DDAR7,
+	SLEEP_SAVE_DMAC_DTCR0, SLEEP_SAVE_DMAC_DTCR1, SLEEP_SAVE_DMAC_DTCR2, SLEEP_SAVE_DMAC_DTCR3, SLEEP_SAVE_DMAC_DTCR4, SLEEP_SAVE_DMAC_DTCR5, SLEEP_SAVE_DMAC_DTCR6, SLEEP_SAVE_DMAC_DTCR7,
+	SLEEP_SAVE_DMAC_DRSR0, SLEEP_SAVE_DMAC_DRSR1, SLEEP_SAVE_DMAC_DRSR2, SLEEP_SAVE_DMAC_DRSR3, SLEEP_SAVE_DMAC_DRSR4, SLEEP_SAVE_DMAC_DRSR5, SLEEP_SAVE_DMAC_DRSR6, SLEEP_SAVE_DMAC_DRSR7,
+	SLEEP_SAVE_DMAC_DCCSR0, SLEEP_SAVE_DMAC_DCCSR1, SLEEP_SAVE_DMAC_DCCSR2, SLEEP_SAVE_DMAC_DCCSR3, SLEEP_SAVE_DMAC_DCCSR4, SLEEP_SAVE_DMAC_DCCSR5, SLEEP_SAVE_DMAC_DCCSR6, SLEEP_SAVE_DMAC_DCCSR7,
+
+	/* INTC */
+	SLEEP_SAVE_INTC_IPR, SLEEP_SAVE_INTC_ISR, SLEEP_SAVE_INTC_IMR,
+
+	/* Checksum */
+	SLEEP_SAVE_CKSUM,
+
+	SLEEP_SAVE_SIZE
+};
+
+static unsigned long sleep_save[SLEEP_SAVE_SIZE];
+
+static int jz_pm_do_suspend(void)
+{
+	unsigned long checksum = 0;
+	unsigned long imr = REG_INTC_IMR;
+	int i;
+
+	printk("Put cpu into suspend mode.\n");
+
+	/* Mask all interrupts */
+	REG_INTC_IMSR = 0xffffffff;
+
+	/* Preserve current time */
+	REG_RTC_RSR = xtime.tv_sec;
+
+	REG_CPM_OCR |= CPM_OCR_SUSPEND_PHY0; /* suspend USB PHY 0 */
+	REG_CPM_OCR |= CPM_OCR_SUSPEND_PHY1; /* suspend USB PHY 1 */
+	REG_CPM_OCR |= CPM_OCR_EXT_RTC_CLK;  /* select the external RTC clock (32.768KHz) */
+
+	/* Disable NAND ctroller */
+	REG_EMC_NFCSR &= ~(EMC_NFCSR_NFE | EMC_NFCSR_FCE);
+
+	/*
+	 * Temporary solution.  This won't be necessary once
+	 * we move this support into the device drivers.
+	 * Save the on-chip modules
+	 */
+	SAVE(UART0_LCR, 8); SAVE(UART0_MCR, 8); SAVE(UART0_SPR, 8);
+	REG8(UART0_LCR) |= UARTLCR_DLAB; /* Access to DLLR/DLHR */
+	SAVE(UART0_DLLR, 8); SAVE(UART0_DLHR, 8);
+	REG8(UART0_LCR) &= ~UARTLCR_DLAB; /* Access to IER */
+	SAVE(UART0_IER, 8);
+
+	SAVE(UART1_LCR, 8); SAVE(UART1_MCR, 8); SAVE(UART1_SPR, 8);
+	REG8(UART1_LCR) |= UARTLCR_DLAB; /* Access to DLLR/DLHR */
+	SAVE(UART1_DLLR, 8); SAVE(UART1_DLHR, 8);
+	REG8(UART1_LCR) &= ~UARTLCR_DLAB; /* Access to IER */
+	SAVE(UART1_IER, 8);
+
+	SAVE(UART2_LCR, 8); SAVE(UART2_MCR, 8); SAVE(UART2_SPR, 8);
+	REG8(UART2_LCR) |= UARTLCR_DLAB; /* Access to DLLR/DLHR */
+	SAVE(UART2_DLLR, 8); SAVE(UART2_DLHR, 8);
+	REG8(UART2_LCR) &= ~UARTLCR_DLAB; /* Access to IER */
+	SAVE(UART2_IER, 8);
+
+	SAVE(UART3_LCR, 8); SAVE(UART3_MCR, 8); SAVE(UART3_SPR, 8);
+	REG8(UART3_LCR) |= UARTLCR_DLAB; /* Access to DLLR/DLHR */
+	SAVE(UART3_DLLR, 8); SAVE(UART3_DLHR, 8);
+	REG8(UART3_LCR) &= ~UARTLCR_DLAB; /* Access to IER */
+	SAVE(UART3_IER, 8);
+
+	/* Save vital registers */
+
+	SAVE(OST_TER, 8);
+	SAVE(OST_TCSR0, 16); SAVE(OST_TCSR1, 16); SAVE(OST_TCSR2, 16);
+	SAVE(OST_TRDR0, 32); SAVE(OST_TRDR1, 32); SAVE(OST_TRDR2, 32);
+	SAVE(OST_TCNT0, 32); SAVE(OST_TCNT1, 32); SAVE(OST_TCNT2, 32);
+
+	SAVE(HARB_HAPOR, 32); SAVE(HARB_HMCTR, 32); SAVE(HARB_HMLTR, 32);
+
+	SAVE(EMC_SMCR0, 32); SAVE(EMC_SMCR1, 32); SAVE(EMC_SMCR2, 32); SAVE(EMC_SMCR3, 32);
+	SAVE(EMC_SMCR4, 32); SAVE(EMC_SMCR5, 32);
+
+	SAVE(GPIO_GPDR0, 32); SAVE(GPIO_GPDR1, 32); SAVE(GPIO_GPDR2, 32);
+	SAVE(GPIO_GPDR3, 32);
+	SAVE(GPIO_GPDIR0, 32); SAVE(GPIO_GPDIR1, 32); SAVE(GPIO_GPDIR2, 32);
+	SAVE(GPIO_GPDIR3, 32);
+	SAVE(GPIO_GPODR0, 32); SAVE(GPIO_GPODR1, 32); SAVE(GPIO_GPODR2, 32);
+	SAVE(GPIO_GPODR3, 32);
+	SAVE(GPIO_GPPUR0, 32); SAVE(GPIO_GPPUR1, 32); SAVE(GPIO_GPPUR2, 32);
+	SAVE(GPIO_GPPUR3, 32);
+	SAVE(GPIO_GPALR0, 32); SAVE(GPIO_GPALR1, 32); SAVE(GPIO_GPALR2, 32);
+	SAVE(GPIO_GPALR3, 32);
+	SAVE(GPIO_GPAUR0, 32); SAVE(GPIO_GPAUR1, 32); SAVE(GPIO_GPAUR2, 32);
+	SAVE(GPIO_GPAUR3, 32);
+	SAVE(GPIO_GPIDLR0, 32); SAVE(GPIO_GPIDLR1, 32);	SAVE(GPIO_GPIDLR2, 32);
+	SAVE(GPIO_GPIDLR3, 32);
+	SAVE(GPIO_GPIDUR0, 32);	SAVE(GPIO_GPIDUR1, 32);	SAVE(GPIO_GPIDUR2, 32);
+	SAVE(GPIO_GPIDUR3, 32);
+	SAVE(GPIO_GPIER0, 32); SAVE(GPIO_GPIER1, 32); SAVE(GPIO_GPIER2, 32);
+	SAVE(GPIO_GPIER3, 32);
+	SAVE(GPIO_GPIMR0, 32); SAVE(GPIO_GPIMR1, 32); SAVE(GPIO_GPIMR2, 32);
+	SAVE(GPIO_GPIMR3, 32);
+	SAVE(GPIO_GPFR0, 32); SAVE(GPIO_GPFR1, 32); SAVE(GPIO_GPFR2, 32);
+	SAVE(GPIO_GPFR3, 32);
+
+	SAVE(DMAC_DMACR, 32);
+	SAVE(DMAC_DSAR0, 32); SAVE(DMAC_DSAR1, 32); SAVE(DMAC_DSAR2, 32); SAVE(DMAC_DSAR3, 32); SAVE(DMAC_DSAR4, 32); SAVE(DMAC_DSAR5, 32); SAVE(DMAC_DSAR6, 32); SAVE(DMAC_DSAR7, 32);
+	SAVE(DMAC_DDAR0, 32); SAVE(DMAC_DDAR1, 32); SAVE(DMAC_DDAR2, 32); SAVE(DMAC_DDAR3, 32); SAVE(DMAC_DDAR4, 32); SAVE(DMAC_DDAR5, 32); SAVE(DMAC_DDAR6, 32); SAVE(DMAC_DDAR7, 32);
+	SAVE(DMAC_DTCR0, 32); SAVE(DMAC_DTCR1, 32); SAVE(DMAC_DTCR2, 32); SAVE(DMAC_DTCR3, 32); SAVE(DMAC_DTCR4, 32); SAVE(DMAC_DTCR5, 32); SAVE(DMAC_DTCR6, 32); SAVE(DMAC_DTCR7, 32);
+	SAVE(DMAC_DRSR0, 32); SAVE(DMAC_DRSR1, 32); SAVE(DMAC_DRSR2, 32); SAVE(DMAC_DRSR3, 32); SAVE(DMAC_DRSR4, 32); SAVE(DMAC_DRSR5, 32); SAVE(DMAC_DRSR6, 32); SAVE(DMAC_DRSR7, 32);
+	SAVE(DMAC_DCCSR0, 32); SAVE(DMAC_DCCSR1, 32); SAVE(DMAC_DCCSR2, 32); SAVE(DMAC_DCCSR3, 32); SAVE(DMAC_DCCSR4, 32); SAVE(DMAC_DCCSR5, 32); SAVE(DMAC_DCCSR6, 32); SAVE(DMAC_DCCSR7, 32);
+
+	SAVE(INTC_IPR, 32);SAVE(INTC_ISR, 32);SAVE(INTC_IMR, 32);
+
+	SAVE(WDT_WTCNT, 32);SAVE(WDT_WTCSR, 8);
+
+	/* Mask all interrupts */
+	REG_INTC_IMSR = 0xffffffff;
+
+	/* Save module clocks */
+	SAVE(CPM_MSCR, 32);
+
+        /* Save PLL */
+	SAVE(CPM_PLCR1, 32);
+
+	/* Stop module clocks */
+	__cpm_stop_uart0();
+	__cpm_stop_uart1();
+	__cpm_stop_uart2();
+	__cpm_stop_uart3();
+	__cpm_stop_uhc();
+	__cpm_stop_udc();
+	__cpm_stop_eth();
+	__cpm_stop_cim();
+	__cpm_stop_kbc();
+	__cpm_stop_scc();
+	__cpm_stop_ssi();
+	__cpm_stop_ost();
+
+	/* platform-specific pm routine */
+	jz_board_pm_suspend();
+
+	/* Clear previous reset status */
+	REG_CPM_RSTR &= ~(CPM_RSTR_HR | CPM_RSTR_WR | CPM_RSTR_SR);
+
+	/* Set resume return address */
+	REG_CPM_SPR = virt_to_phys(jz_cpu_resume);
+
+	/* Before sleeping, calculate and save a checksum */
+	for (i = 0; i < SLEEP_SAVE_SIZE - 1; i++)
+		checksum += sleep_save[i];
+	sleep_save[SLEEP_SAVE_CKSUM] = checksum;
+
+	/* *** go zzz *** */
+	jz_cpu_suspend();
+#if 0
+	/* after sleeping, validate the checksum */
+	checksum = 0;
+	for (i = 0; i < SLEEP_SAVE_SIZE - 1; i++)
+		checksum += sleep_save[i];
+
+	/* if invalid, display message and wait for a hardware reset */
+	if (checksum != sleep_save[SLEEP_SAVE_CKSUM]) {
+		/** Add platform-specific message display codes here **/
+		while (1);
+	}
+#endif
+	/* Restore PLL */
+	RESTORE(CPM_PLCR1, 32);
+
+	/* Restore module clocks */
+	RESTORE(CPM_MSCR, 32);
+
+	/* Ensure not to come back here if it wasn't intended */
+	REG_CPM_SPR = 0;
+
+	/* Restore registers */
+
+	RESTORE(GPIO_GPDR0, 32); RESTORE(GPIO_GPDR1, 32); RESTORE(GPIO_GPDR2, 32);
+	RESTORE(GPIO_GPDR3, 32);
+	RESTORE(GPIO_GPDIR0, 32); RESTORE(GPIO_GPDIR1, 32); RESTORE(GPIO_GPDIR2, 32);
+	RESTORE(GPIO_GPDIR3, 32);
+	RESTORE(GPIO_GPODR0, 32); RESTORE(GPIO_GPODR1, 32); RESTORE(GPIO_GPODR2, 32);
+	RESTORE(GPIO_GPODR3, 32);
+	RESTORE(GPIO_GPPUR0, 32); RESTORE(GPIO_GPPUR1, 32); RESTORE(GPIO_GPPUR2, 32);
+	RESTORE(GPIO_GPPUR3, 32);
+	RESTORE(GPIO_GPALR0, 32); RESTORE(GPIO_GPALR1, 32); RESTORE(GPIO_GPALR2, 32);
+	RESTORE(GPIO_GPALR3, 32);
+	RESTORE(GPIO_GPAUR0, 32); RESTORE(GPIO_GPAUR1, 32); RESTORE(GPIO_GPAUR2, 32);
+	RESTORE(GPIO_GPAUR3, 32);
+	RESTORE(GPIO_GPIDLR0, 32);RESTORE(GPIO_GPIDLR1, 32);RESTORE(GPIO_GPIDLR2, 32);
+	RESTORE(GPIO_GPIDLR3, 32);
+	RESTORE(GPIO_GPIDUR0, 32);RESTORE(GPIO_GPIDUR1, 32);RESTORE(GPIO_GPIDUR2, 32);
+	RESTORE(GPIO_GPIDUR3, 32);
+	RESTORE(GPIO_GPIER0, 32); RESTORE(GPIO_GPIER1, 32); RESTORE(GPIO_GPIER2, 32);
+	RESTORE(GPIO_GPIER3, 32);
+	RESTORE(GPIO_GPIMR0, 32); RESTORE(GPIO_GPIMR1, 32); RESTORE(GPIO_GPIMR2, 32);
+	RESTORE(GPIO_GPIMR3, 32);
+	RESTORE(GPIO_GPFR0, 32); RESTORE(GPIO_GPFR1, 32); RESTORE(GPIO_GPFR2, 32);
+	RESTORE(GPIO_GPFR3, 32);
+
+	RESTORE(EMC_SMCR0, 32); RESTORE(EMC_SMCR1, 32); RESTORE(EMC_SMCR2, 32); RESTORE(EMC_SMCR3, 32);
+	RESTORE(EMC_SMCR4, 32); RESTORE(EMC_SMCR5, 32);
+
+	RESTORE(HARB_HAPOR, 32); RESTORE(HARB_HMCTR, 32); RESTORE(HARB_HMLTR, 32);
+
+	RESTORE(OST_TCNT0, 32);	RESTORE(OST_TCNT1, 32);	RESTORE(OST_TCNT2, 32);
+	RESTORE(OST_TRDR0, 32);	RESTORE(OST_TRDR1, 32);	RESTORE(OST_TRDR2, 32);
+	RESTORE(OST_TCSR0, 16);	RESTORE(OST_TCSR1, 16);	RESTORE(OST_TCSR2, 16);
+	RESTORE(OST_TER, 8);
+
+	RESTORE(DMAC_DMACR, 32);
+	RESTORE(DMAC_DSAR0, 32); RESTORE(DMAC_DSAR1, 32); RESTORE(DMAC_DSAR2, 32); RESTORE(DMAC_DSAR3, 32); RESTORE(DMAC_DSAR4, 32); RESTORE(DMAC_DSAR5, 32); RESTORE(DMAC_DSAR6, 32); RESTORE(DMAC_DSAR7, 32);
+	RESTORE(DMAC_DDAR0, 32); RESTORE(DMAC_DDAR1, 32); RESTORE(DMAC_DDAR2, 32); RESTORE(DMAC_DDAR3, 32); RESTORE(DMAC_DDAR4, 32); RESTORE(DMAC_DDAR5, 32); RESTORE(DMAC_DDAR6, 32); RESTORE(DMAC_DDAR7, 32);
+	RESTORE(DMAC_DTCR0, 32); RESTORE(DMAC_DTCR1, 32); RESTORE(DMAC_DTCR2, 32); RESTORE(DMAC_DTCR3, 32); RESTORE(DMAC_DTCR4, 32); RESTORE(DMAC_DTCR5, 32); RESTORE(DMAC_DTCR6, 32); RESTORE(DMAC_DTCR7, 32);
+	RESTORE(DMAC_DRSR0, 32); RESTORE(DMAC_DRSR1, 32); RESTORE(DMAC_DRSR2, 32); RESTORE(DMAC_DRSR3, 32); RESTORE(DMAC_DRSR4, 32); RESTORE(DMAC_DRSR5, 32); RESTORE(DMAC_DRSR6, 32); RESTORE(DMAC_DRSR7, 32);
+	RESTORE(DMAC_DCCSR0, 32); RESTORE(DMAC_DCCSR1, 32); RESTORE(DMAC_DCCSR2, 32); RESTORE(DMAC_DCCSR3, 32); RESTORE(DMAC_DCCSR4, 32); RESTORE(DMAC_DCCSR5, 32); RESTORE(DMAC_DCCSR6, 32); RESTORE(DMAC_DCCSR7, 32);
+
+	RESTORE(INTC_IPR, 32);RESTORE(INTC_ISR, 32);RESTORE(INTC_IMR, 32);
+
+	REG_WDT_WTCNT = 0; RESTORE(WDT_WTCSR, 8);
+
+	/*
+	 * Temporary solution.  This won't be necessary once
+	 * we move this support into the device drivers.
+	 * Restore the on-chip modules.
+	 */
+
+	/* FIFO control reg, write-only */
+	REG8(UART0_FCR) = UARTFCR_FE | UARTFCR_RFLS | UARTFCR_TFLS | UARTFCR_UUE;
+	REG8(UART1_FCR) = UARTFCR_FE | UARTFCR_RFLS | UARTFCR_TFLS | UARTFCR_UUE;
+	REG8(UART2_FCR) = UARTFCR_FE | UARTFCR_RFLS | UARTFCR_TFLS | UARTFCR_UUE;
+	REG8(UART3_FCR) = UARTFCR_FE | UARTFCR_RFLS | UARTFCR_TFLS | UARTFCR_UUE;
+
+	REG8(UART0_LCR) |= UARTLCR_DLAB; /* Access to DLLR/DLHR */
+	RESTORE(UART0_DLLR, 8);	RESTORE(UART0_DLHR, 8);
+	REG8(UART0_LCR) &= ~UARTLCR_DLAB; /* Access to IER */
+	RESTORE(UART0_IER, 8);
+	RESTORE(UART0_MCR, 8); RESTORE(UART0_SPR, 8); RESTORE(UART0_LCR, 8);
+
+	REG8(UART1_LCR) |= UARTLCR_DLAB; /* Access to DLLR/DLHR */
+	RESTORE(UART1_DLLR, 8);	RESTORE(UART1_DLHR, 8);
+	REG8(UART1_LCR) &= ~UARTLCR_DLAB; /* Access to IER */
+	RESTORE(UART1_IER, 8);
+	RESTORE(UART1_MCR, 8); RESTORE(UART1_SPR, 8); RESTORE(UART1_LCR, 8);
+
+	REG8(UART2_LCR) |= UARTLCR_DLAB; /* Access to DLLR/DLHR */
+	RESTORE(UART2_DLLR, 8);	RESTORE(UART2_DLHR, 8);
+	REG8(UART2_LCR) &= ~UARTLCR_DLAB; /* Access to IER */
+	RESTORE(UART2_IER, 8);
+	RESTORE(UART2_MCR, 8); RESTORE(UART2_SPR, 8); RESTORE(UART2_LCR, 8);
+
+	REG8(UART3_LCR) |= UARTLCR_DLAB; /* Access to DLLR/DLHR */
+	RESTORE(UART3_DLLR, 8);	RESTORE(UART3_DLHR, 8);
+	REG8(UART3_LCR) &= ~UARTLCR_DLAB; /* Access to IER */
+	RESTORE(UART3_IER, 8);
+	RESTORE(UART3_MCR, 8); RESTORE(UART3_SPR, 8); RESTORE(UART3_LCR, 8);
+
+	REG_CPM_OCR &= ~CPM_OCR_SUSPEND_PHY0; /* resume USB PHY 0 */
+	REG_CPM_OCR &= ~CPM_OCR_SUSPEND_PHY1; /* resume USB PHY 1 */
+#if 0
+	REG_CPM_OCR &= ~CPM_OCR_EXT_RTC_CLK;  /* use internal RTC clock (JZ_EXTAL/128 Hz) */
+#else
+	REG_CPM_OCR |= CPM_OCR_EXT_RTC_CLK;  /* use external RTC clock (32.768 KHz) */
+#endif
+
+	/* Enable NAND ctroller */
+	REG_EMC_NFCSR |= EMC_NFCSR_NFE;
+
+	/* Restore current time */
+	xtime.tv_sec = REG_RTC_RSR;
+
+	/* Restore interrupts */
+	REG_INTC_IMSR = imr;
+	REG_INTC_IMCR = ~imr;
+
+	return 0;
+}
+
+/* NOTES:
+ * 1: Pins that are floated (NC) should be set as input and pull-enable.
+ * 2: Pins that are pull-up or pull-down by outside should be set as input
+ *    and pull-disable.
+ * 3: Pins that are connected to a chipset should be set as pull-disable.
+ */
+static void jz_board_pm_gpio_setup(void)
+{
+	/* CIM_D0(IN)/PULL-UP/GP0 */
+	__gpio_as_input(0);
+	__gpio_enable_pull(0);
+
+	/* CIM_D1(IN)/PULL-UP/GP1 */
+	__gpio_as_input(1);
+	__gpio_enable_pull(1);
+
+	/* CIM_D2(IN)/PULL-UP/GP2 */
+	__gpio_as_input(2);
+	__gpio_enable_pull(2);
+
+	/* CIM_D3(IN)/PULL-UP/GP3 */
+	__gpio_as_input(3);
+	__gpio_enable_pull(3);
+
+	/* CIM_D4(IN)/PULL-DOWN/GP4 */
+	__gpio_as_input(4);
+	__gpio_enable_pull(4);
+
+	/* CIM_D5(IN)/PULL-DOWN/GP5 */
+	__gpio_as_input(5);
+	__gpio_enable_pull(5);
+
+	/* CIM_D6(IN)/PULL-DOWN/GP6 */
+	__gpio_as_input(6);
+	__gpio_enable_pull(6);
+
+	/* CIM_D7(IN)/PULL-DOWN/GP7 */
+	__gpio_as_input(7);
+	__gpio_enable_pull(7);
+
+	/* CIM_VSYNC(IN)/PULL-DOWN/GP8 */
+	__gpio_as_input(8);
+	__gpio_enable_pull(8);
+
+	/* CIM_HSYNC(IN)/PULL-UP/GP9 */
+	__gpio_as_input(9);
+	__gpio_enable_pull(9);
+
+	/* CIM_PCLK(IN)/PULL-DOWN/GP10 */
+	__gpio_as_input(10);
+	__gpio_enable_pull(10);
+
+	/* CIM_MCLK(OUT)/PULL-DOWN/GP11 */
+	__gpio_as_input(11);
+	__gpio_enable_pull(11);
+
+	/* DMA_DREQ0(IN)/CHIP_MODE/PULL-UP/GP12 */
+	__gpio_as_input(12);
+	__gpio_enable_pull(12);
+
+	/* DMA_DACK0(OUT)/PULL-UP/GP13 */  /* GPIO13 */
+	__gpio_as_input(13);
+	__gpio_disable_pull(13);
+
+	/* GP14 */
+	/* GP15 */
+
+	/* RXD3(IN)/PULL-UP/GP16 */
+	__gpio_as_input(16);
+	__gpio_enable_pull(16);
+
+	/* CTS3(IN)/PULL-UP/GP17 */
+	__gpio_as_input(17);
+	__gpio_enable_pull(17);
+
+	/* GP18 */
+	/* GP19 */
+	/* GP20 */
+
+	/* TXD3(OUT)/PULL-UP/GP21 */
+	__gpio_as_input(21);
+	__gpio_enable_pull(21);
+
+	/* GP22 */
+
+	/* RTS3(OUT)/PULL-UP/GP23 */
+	__gpio_as_input(23);
+	__gpio_enable_pull(23);
+
+	/* RXD1(IN)/PULL-UP/GP24 */      /* IR_RXD */
+	__gpio_as_input(24);
+	__gpio_enable_pull(24);
+
+	/* TXD1(OUT)/PULL-UP/GP25 */     /* IR_TXD */
+	__gpio_disable_pull(25);
+	__gpio_as_output(25);
+	__cpm_set_pin(25);
+
+	/* DMA_AEN(OUT)/PULL-UP/GP26 */  /* CIM_PWD_N */
+	__gpio_as_input(26);
+	__gpio_disable_pull(26);
+
+	/* DMA_EOP(OUT)/PULL-UP/GP27 */  /* SW4 */
+	__gpio_as_input(27);
+	__gpio_disable_pull(27);
+
+	/* USB_CLK(IN)/PULL-UP/GP28 */
+	__gpio_as_input(28);
+	__gpio_disable_pull(28);
+
+	/* USB_PPWR0(OUT)/PULL-UP/GP29 */  /* USB_CLK_EN */
+	__gpio_disable_pull(29);
+	__gpio_as_output(29);
+	__cpm_clear_pin(29);  /* disable USB 48MHz clock */
+
+	/* GP30 */
+	/* GP31 */
+
+	/* PS2_KCLK(IO)/PULL-UP/GP32 */
+	__gpio_as_input(32);
+	__gpio_enable_pull(32);
+
+	/* PS2_KDATA(IO)/PULL-UP/GP33 */  /* CIM_RST */
+	__gpio_as_input(33);
+	__gpio_enable_pull(33);
+
+	/* MSC_D0(IO)/PULL-UP/GP34 */
+	__gpio_as_input(34);
+	__gpio_disable_pull(34);
+
+	/* MSC_D1(IO)/PULL-UP/GP35 */
+	__gpio_as_input(35);
+	__gpio_disable_pull(35);
+
+	/* MSC_D2(IO)/PULL-UP/GP36 */
+	__gpio_as_input(36);
+	__gpio_disable_pull(36);
+
+	/* MSC_D3(IO)/PULL-UP/GP37 */
+	__gpio_as_input(37);
+	__gpio_disable_pull(37);
+
+	/* MSC_CMD(IO)/PULL-UP/GP38 */
+	__gpio_as_input(38);
+	__gpio_disable_pull(38);
+
+	/* MSC_CLK(OUT)/PULL-UP/GP39 */
+	__gpio_as_input(39);
+	__gpio_enable_pull(39);
+
+	/* LCD_D0(OUT)/PULL-UP/GP40 */
+	__gpio_as_input(40);
+	__gpio_enable_pull(40);
+
+	/* LCD_D1(OUT)/PULL-UP/GP41 */
+	__gpio_as_input(41);
+	__gpio_enable_pull(41);
+
+	/* LCD_D2(OUT)/PULL-UP/GP42 */
+	__gpio_as_input(42);
+	__gpio_enable_pull(42);
+
+	/* LCD_D3(OUT)/PULL-UP/GP43 */
+	__gpio_as_input(43);
+	__gpio_enable_pull(43);
+
+	/* LCD_D4(OUT)/PULL-UP/GP44 */
+	__gpio_as_input(44);
+	__gpio_enable_pull(44);
+
+	/* LCD_D5(OUT)/PULL-UP/GP45 */
+	__gpio_as_input(45);
+	__gpio_enable_pull(45);
+
+	/* LCD_D6(OUT)/PULL-UP/GP46 */
+	__gpio_as_input(46);
+	__gpio_enable_pull(46);
+
+	/* LCD_D7(OUT)/PULL-UP/GP47 */
+	__gpio_as_input(47);
+	__gpio_enable_pull(47);
+
+	/* LCD_D8(OUT)/PULL-DOWN/GP48 */
+	__gpio_as_input(48);
+	__gpio_enable_pull(48);
+
+	/* LCD_D9(OUT)/PULL-DOWN/GP49 */
+	__gpio_as_input(49);
+	__gpio_enable_pull(49);
+
+	/* LCD_D10(OUT)/PULL-DOWN/GP50 */
+	__gpio_as_input(50);
+	__gpio_enable_pull(50);
+
+	/* LCD_D11(OUT)/PULL-DOWN/GP51 */
+	__gpio_as_input(51);
+	__gpio_enable_pull(51);
+
+	/* LCD_D12(OUT)/PULL-DOWN/GP52 */
+	__gpio_as_input(52);
+	__gpio_enable_pull(52);
+
+	/* LCD_D13(OUT)/PULL-DOWN/GP53 */
+	__gpio_as_input(53);
+	__gpio_enable_pull(53);
+
+	/* LCD_D14(OUT)/PULL-DOWN/GP54 */
+	__gpio_as_input(54);
+	__gpio_enable_pull(54);
+
+	/* LCD_D15(OUT)/PULL-DOWN/GP55 */
+	__gpio_as_input(55);
+	__gpio_enable_pull(55);
+
+	/* LCD_VSYNC(IN)/PULL-DOWN/GP56 */
+	__gpio_as_input(56);
+	__gpio_enable_pull(56);
+
+	/* LCD_HSYNC(IN)/PULL-UP/GP57 */
+	__gpio_as_input(57);
+	__gpio_enable_pull(57);
+
+	/* LCD_PCLK(IN)/PULL-DOWN/GP58 */
+	__gpio_as_input(58);
+	__gpio_enable_pull(58);
+
+	/* LCD_DE(OUT)/PULL-DOWN/GP59 */
+	__gpio_as_input(59);
+	__gpio_enable_pull(59);
+
+	/* LCD_SPL(OUT)/PULL-UP/GP60 */
+	__gpio_as_input(60);
+	__gpio_disable_pull(60);
+
+	/* LCD_CLS(OUT)/PULL-UP/GP61 */
+	__gpio_as_input(61);
+	__gpio_disable_pull(61);
+
+	/* LCD_PS(OUT)/PULL-UP/GP62 */
+	__gpio_as_input(62);
+	__gpio_disable_pull(62);
+
+	/* LCD_REV(OUT)/PULL-UP/GP63 */
+	__gpio_as_input(63);
+	__gpio_enable_pull(63);
+
+	/* SCC0_DAT(IO)/PULL-UP/GP64 */  /* Keypad */
+	__gpio_as_input(64);
+	__gpio_enable_pull(64);
+
+	/* SCC1_DAT(IO)/PULL-UP/GP65 */  /* SW5 */
+	__gpio_as_input(65);
+	__gpio_disable_pull(65);
+
+	/* SCC0_CLK(OUT)/PULL-UP/GP66 */  /* PW_O */
+	__gpio_disable_pull(66);
+	__gpio_as_output(66);
+	__cpm_set_pin(66);
+
+	/* SCC1_CLK(OUT)/PULL-UP/GP67 */  /* SW6 */
+	__gpio_as_input(67);
+	__gpio_disable_pull(67);
+
+	/* SYS_CLK(OUT)/PULL-UP/GP68 */  /* I2S_CLK */
+	__gpio_disable_pull(68);
+
+	/* ACRESET_N(OUT)/PULL-UP/GP69 */ /* AK4642 PDN */
+	__gpio_disable_pull(69);
+	__gpio_as_output(69);
+	__cpm_clear_pin(69);
+
+	/* SDATA_OUT(OUT)/PULL-UP/GP70 */ /* I2S_DIN */
+	__gpio_disable_pull(70);
+
+	/* SDATA_IN(IN)/PULL-UP/GP71 */  /* I2S_DOUT */
+	__gpio_disable_pull(71);
+
+	/* SSI_CLK(OUT)/PULL-UP/GP72 */   /* SSI_CLK */
+	__gpio_as_input(72);
+	__gpio_enable_pull(72);
+
+	/* SSI_CE1_N(OUT)/PULL-UP/GP73 */ /* SSI_CE1_N */
+	__gpio_as_input(73);
+	__gpio_enable_pull(73);
+
+	/* SSI_DT(OUT)/PULL-UP/GP74 */    /* SSI_DT */
+	__gpio_as_input(74);
+	__gpio_enable_pull(74);
+
+	/* SSI_DR(IN)/PULL-UP/GP75 */     /* SSI_DR */
+	__gpio_as_input(75);
+	__gpio_enable_pull(75);
+
+	/* SSI_CE2_N(OUT)/SSI_GPC/PULL-UP/GP76 */
+	__gpio_as_input(76);
+	__gpio_enable_pull(76);
+
+	/* BITCLK_IN(IN)/PULL-UP/GP77 */ /* I2S_BITCLK */
+	__gpio_disable_pull(77);
+
+	/* SYNC_IN(IN)/PULL-UP/GP78 */  /* I2S_LRCIN */
+	__gpio_disable_pull(78);
+
+	/* FRE_N(OUT)/PULL-UP/GP79 */
+	__gpio_enable_pull(79);
+	__gpio_as_input(79);
+
+	/* FWE_N(OUT)/PULL-UP/GP80 */
+	__gpio_enable_pull(80);
+	__gpio_as_input(80);
+
+	/* FRB_N(IN)/PULL-UP/GP81 */
+	__gpio_enable_pull(81);
+	__gpio_as_input(81);
+
+	/* DCS1_N(OUT)/PULL-UP/GP82 */  /* SD_WP */
+	__gpio_as_input(82);
+	__gpio_enable_pull(82);
+
+	/* CS1_N(OUT)/PULL-UP/GP83 */  /* JACK_PLUG */
+	__gpio_as_input(83);
+	__gpio_disable_pull(83);
+
+	/* CS2_N(OUT)/PULL-UP/GP84 */   /* DC_DETE */
+	__gpio_as_input(84);
+	__gpio_disable_pull(84);
+
+	/* CS3_N(OUT)/PULL-UP/GP85 */   /* NAND CS# */
+	__gpio_enable_pull(85);
+	__gpio_as_input(85);
+
+	/* CS4_N/(OUT)PULL-UP/GP86 */   /* PULL_OFF */
+	__gpio_disable_pull(86);
+	__gpio_as_output(86);
+//	__cpm_set_pin(86);
+	__cpm_clear_pin(86);
+
+	/* CS5_N(OUT)/PULL-UP/GP87 */   /* IR_SD */
+	__gpio_as_input(87);
+	__gpio_disable_pull(87);
+
+	/* INPACK_N(IN)/PULL-UP/GP88 */  /* SW7 */
+	__gpio_as_input(88);
+	__gpio_disable_pull(88);
+
+	/* BVD2(IN)/PULL-UP/GP89 */      /* SW8 */
+	__gpio_as_input(89);
+	__gpio_disable_pull(89);
+
+	/* PCE1_N(OUT)/PULL-UP/GP90 */   /* SD_CD_N */
+	__gpio_as_input(90);
+	__gpio_enable_pull(90);
+
+	/* PSKTSEL_N(OUT)/PULL-UP/GP91 */  /* SD_VCC_3V_EN_N */
+	__gpio_disable_pull(91);
+	__gpio_as_output(91);
+	__cpm_clear_pin(91);
+
+	/* IOIS16_N(IN)/PULL-UP/GP92 */    /* LED_EN */
+	__gpio_disable_pull(92);
+	__gpio_as_output(92);
+	__cpm_clear_pin(92);
+
+	/* PCE2_N(OUT)/PULL-UP/GP93 */     /* LCD_DISP_OFF_N */
+	__gpio_disable_pull(93);
+	__gpio_as_input(93);
+
+	/* PWM0(OUT)/PULL-UP/GP94 */       /* LCD backlight off */
+	__gpio_disable_pull(94);
+	__gpio_as_output(94);
+	__cpm_clear_pin(94);
+
+	/* PWM1(OUT)/PULL-UP/GP95 */
+	__gpio_disable_pull(95);
+	__gpio_as_output(95);
+	__cpm_clear_pin(95);
+
+	/* PRT(OUT)/PULL-UP/GP96 */        /* RTC_IRQ */
+	__gpio_as_input(96);
+	__gpio_disable_pull(96);
+
+	/* PRT(OUT)/PULL-UP/GP97 */        /* PW_I */
+	__gpio_as_input(97);
+	__gpio_disable_pull(97);
+
+	/* PRT(OUT)/PULL-UP/GP98 */        /* Keypad */
+	__gpio_as_input(98);
+	__gpio_disable_pull(98);
+
+	/* PRT(OUT)/PULL-UP/GP99 */        /* Keypad */
+	__gpio_as_input(99);
+	__gpio_disable_pull(99);
+
+	/* PRT(OUT)/PULL-UP/GP100 */        /* Keypad */
+	__gpio_as_input(100);
+	__gpio_disable_pull(100);
+
+	/* PRT(OUT)/PULL-UP/GP101 */        /* Keypad */
+	__gpio_as_input(101);
+	__gpio_disable_pull(101);
+
+	/* PRT(OUT)/PULL-UP/GP102 */        /* Keypad */
+	__gpio_as_input(102);
+	__gpio_disable_pull(102);
+
+	/* PRT(OUT)/PULL-UP/GP103 */        /* Keypad */
+	__gpio_as_input(103);
+	__gpio_enable_pull(103);
+
+	/* PRT(OUT)/PULL-UP/GP104 */        /* Keypad */
+	__gpio_as_input(104);
+	__gpio_enable_pull(104);
+
+	/* PRT(OUT)/PULL-UP/GP105 */        /* Keypad */
+	__gpio_as_input(105);
+	__gpio_enable_pull(105);
+
+	/* PRT(OUT)/PULL-UP/GP106 */        /* 5V_ON */
+	__gpio_disable_pull(106);
+	__gpio_as_output(106);
+	__cpm_clear_pin(106);
+
+	/* PRT(IN)/PULL-UP/GP107 */        /* GSM_BOOT */
+	__gpio_as_input(107);
+	__gpio_enable_pull(107);
+
+	/* PRT(IN)/PULL-UP/GP108 */        /* GSM_RESET */
+	__gpio_as_input(108);
+	__gpio_enable_pull(108);
+
+	/* PRT(IN)/PULL-UP/GP109 */        /* GSM_EN */
+	__gpio_as_input(109);
+	__gpio_enable_pull(109);
+
+	/* PRT(IN)/PULL-UP/GP110 */        /* GSM_RING */
+	__gpio_as_input(110);
+	__gpio_enable_pull(110);
+
+	/* PRT(IN)/UART2_RXD/PULL-UP/GP111 */        /* Keypad */
+	__gpio_as_input(111);
+	__gpio_enable_pull(111);
+
+	/* MII_TX_EN(OUT)/PULL-UP/GP112 */
+	__gpio_as_input(112);
+	__gpio_enable_pull(112);
+
+	/* MII_RX_DV(IN)/PULL-UP/GP113 */
+	__gpio_as_input(113);
+	__gpio_enable_pull(113);
+
+	/* MII_RX_ER(IN)/PULL-UP/GP114 */
+	__gpio_as_input(114);
+	__gpio_enable_pull(114);
+
+	/* MII_COL(IN)/PULL-UP/GP115 */
+	__gpio_as_input(115);
+	__gpio_enable_pull(115);
+
+	/* MII_CRS(IN)/PULL-UP/GP116 */
+	__gpio_as_input(116);
+	__gpio_enable_pull(116);
+
+	/* MII_TXD0(OUT)/PULL-UP/GP117 */
+	__gpio_as_input(117);
+	__gpio_enable_pull(117);
+
+	/* MII_TXD1(OUT)/PULL-UP/GP118 */
+	__gpio_as_input(118);
+	__gpio_enable_pull(118);
+
+	/* MII_TXD2(OUT)/PULL-UP/GP119 */
+	__gpio_as_input(119);
+	__gpio_enable_pull(119);
+
+	/* MII_TXD3(OUT)/PULL-UP/GP120 */
+	__gpio_as_input(120);
+	__gpio_enable_pull(120);
+
+	/* MII_RXD0(IN)/PULL-UP/GP121 */
+	__gpio_as_input(121);
+	__gpio_enable_pull(121);
+
+	/* MII_RXD1(IN)/PULL-UP/GP122 */
+	__gpio_as_input(122);
+	__gpio_enable_pull(122);
+
+	/* MII_RXD2(IN)/PULL-UP/GP123 */
+	__gpio_as_input(123);
+	__gpio_enable_pull(123);
+
+	/* MII_RXD3(IN)/PULL-UP/GP124 */
+	__gpio_as_input(124);
+	__gpio_enable_pull(124);
+
+	/* UART2_TXD(OUT)/PULL-UP/GP125 */  /* CHARG_STAT */
+	__gpio_as_output(125);
+	__gpio_disable_pull(125);
+	__cpm_clear_pin(125);
+
+	/* UART0_RXD(IN)/PULL-UP/GP126 */
+	__gpio_as_input(126);
+	__gpio_enable_pull(126);
+
+	/* UART0_TXD(OUT)/PULL-UP/GP127 */
+	__gpio_as_input(127);
+	__gpio_enable_pull(127);
+}
+
+/*
+ * In order to save power most, all gpio pins should be put to their
+ * proper states during low power mode.
+ */
+static void jz_board_pm_suspend(void)
+{
+	/* Setup the state of all the GPIO pins during low-power mode */
+	jz_board_pm_gpio_setup();
+
+	/* Allow next interrupts to wakeup the system.
+	 */
+	REG_CPM_WER = 0;              /* Clear all first */
+
+	/* RTC alarm */
+	REG_CPM_WER |= 1 << 0;
+	REG_CPM_WRER |= 1 << 0;
+	REG_CPM_WFER |= 1 << 0;
+	__gpio_as_irq_rise_edge(96);
+
+	/* Power_I key */
+	REG_CPM_WER |= 1 << 1;
+	REG_CPM_WRER |= 1 << 1;
+	REG_CPM_WFER |= 1 << 1;
+	__gpio_as_irq_rise_edge(97);
+
+	/* enable INTC irq */
+	__intc_unmask_irq(IRQ_GPIO3);
+
+#if 0
+	/* Enable RTC alarm */
+	REG_CPM_WER |= CPM_WER_WERTC;
+	REG_RTC_RGR = 32767;
+	REG_RTC_RCR &= ~RTC_RCR_AE;
+	REG_RTC_RSR = 0;
+	REG_RTC_RSAR = 30;
+	REG_RTC_RCR = RTC_RCR_AE | RTC_RCR_AIE | RTC_RCR_START;
+#endif
+}
+
+/*
+ * We don't use sleep mode of jz4730 for it has bug, the suspend mode
+ * implemented by hibernate mode is used instead of it.
+ */
+static int jz_pm_do_sleep(void)
+{
+	printk("It was deprecated, please use /proc/sys/pm/suspend.\n");
+#if 0
+	unsigned long imr = REG_INTC_IMR;
+
+	/* Preserve current time */
+	REG_RTC_RSR = xtime.tv_sec;
+
+	/* Mask all interrupts */
+	REG_INTC_IMSR = 0xffffffff;
+
+	/* Just allow next interrupts to wakeup the system.
+	 * Note: modify this according to your system.
+	 */
+	/* RTC alarm */
+	__gpio_as_irq_fall_edge(96); /* GPIO 96 */
+
+	/* POWER_I key */
+	__gpio_as_irq_rise_edge(97); /* GPIO 97 */
+
+	/* Enable INTC */
+	__intc_unmask_irq(IRQ_GPIO3);
+
+	/* Disable modules e.g. LCD backlight */
+
+	/* Stop module clocks */
+	__cpm_stop_uhc();
+
+	/* Enter SLEEP mode
+	 * Put SDRAM into self-refresh mode.
+	 */
+	REG_CPM_LPCR &= ~CPM_LPCR_LPM_MASK;
+	REG_CPM_LPCR |= CPM_LPCR_LPM_SLEEP;
+
+	__asm__(".set\tmips3\n\t"
+		".set noreorder\n\t"
+		".align 5\n\t"
+		"wait\n\t"
+		"nop\n\t"
+		".set reorder\n\t"
+		".set\tmips0");
+
+	/* Restore to IDLE mode */
+	REG_CPM_LPCR &= ~CPM_LPCR_LPM_MASK;
+	REG_CPM_LPCR |= CPM_LPCR_LPM_IDLE;
+
+	/* Restore clock of usb host */
+	__cpm_start_uhc();
+
+	/* Restore interrupts */
+	REG_INTC_IMSR = imr;
+	REG_INTC_IMCR = ~imr;
+
+	/* Restore current time */
+	xtime.tv_sec = REG_RTC_RSR;
+#endif
+	return 0;
+}
+
+#define K0BASE  KSEG0
+void jz_flush_cache_all(void)
+{
+	unsigned long addr;
+
+	/* Clear CP0 TagLo */
+	asm volatile ("mtc0 $0, $28\n\t"::);
+
+	for (addr = K0BASE; addr < (K0BASE + 0x4000); addr += 32) {
+		asm volatile (
+			".set mips3\n\t"
+			" cache %0, 0(%1)\n\t"
+			".set mips2\n\t"
+			:
+			: "I" (Index_Writeback_Inv_D), "r"(addr));
+
+		asm volatile (
+			".set mips3\n\t"
+			" cache %0, 0(%1)\n\t"
+			".set mips2\n\t"
+			:
+			: "I" (Index_Store_Tag_I), "r"(addr));
+	}
+
+	asm volatile ("sync\n\t"::);
+
+	/* invalidate BTB */
+	asm volatile (
+		".set mips32\n\t"
+		" mfc0 %0, $16, 7\n\t"
+		" nop\n\t"
+		" ori $0, 2\n\t"
+		" mtc0 %0, $16, 7\n\t"
+		" nop\n\t"
+		".set mips2\n\t"
+		:
+		: "r"(addr));
+}
+
+/* Put CPU to HIBERNATE mode */
+int jz_pm_suspend(void)
+{
+	int retval;
+
+	pm_send_all(PM_SUSPEND, (void *)3);
+
+	retval = jz_pm_do_suspend();
+
+	pm_send_all(PM_RESUME, (void *)0);
+
+	return retval;
+}
+
+#if 0
+/* Put CPU to SLEEP mode */
+int jz_pm_sleep(void)
+{
+	return jz_pm_do_sleep();
+}
+
+/* Put CPU to IDLE mode, used for dpm in linux 2.4 */
+void jz_pm_idle(void)
+{
+	local_irq_disable();
+	if (!need_resched()) {
+		local_irq_enable();
+		cpu_wait();
+	}
+}
+#endif
+
+#ifdef CONFIG_SYSCTL
+
+/*
+ * Use a temporary sysctl number. Horrid, but will be cleaned up in 2.6
+ * when all the PM interfaces exist nicely.
+ */
+#define CTL_PM_SUSPEND   1
+#define CTL_PM_HIBERNATE 2
+
+/*----------------------------------------------------------------------------
+ * Power Management sleep sysctl proc interface
+ *
+ * A write to /proc/sys/pm/suspend invokes this function
+ * which initiates a sleep.
+ *--------------------------------------------------------------------------*/
+static int sysctl_jz_pm_sleep(void)
+{
+	return jz_pm_suspend();
+}
+
+static struct ctl_table pm_table[] =
+{
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "suspend",
+		.data		= NULL,
+		.maxlen		= 0,
+		.mode		= 0600,
+		.proc_handler	= &sysctl_jz_pm_sleep,
+	},
+	{ .ctl_name = 0}
+};
+
+static struct ctl_table pm_dir_table[] =
+{
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "pm",
+		.mode		= 0555,
+		.child		= pm_table,
+	},
+	{ .ctl_name = 0}
+};
+
+#endif /* CONFIG_SYSCTL */
+
+/*
+ * Initialize power interface
+ */
+static int __init jz_pm_init(void)
+{
+	printk("Power Management for JZ\n");
+
+#ifdef CONFIG_SYSCTL
+	register_sysctl_table(pm_dir_table);
+#endif
+
+	return 0;
+}
+
+module_init(jz_pm_init);
--- linux-2.6.24.7.old/arch/mips/jz4730/proc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4730/proc.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,292 @@
+/*
+ * linux/arch/mips/jz4730/proc.c
+ *
+ * /proc/jz/ procfs for on-chip peripherals.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/sysctl.h>
+#include <linux/proc_fs.h>
+
+#include <asm/uaccess.h>
+#include <asm/jzsoc.h>
+
+struct proc_dir_entry *proc_jz_root;
+
+/*
+ * EMC Module
+ */
+static int emc_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+
+	len += sprintf (page+len, "BCR:       0x%08x\n", REG_EMC_BCR);
+	len += sprintf (page+len, "SMCR(0-5): 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", REG_EMC_SMCR0, REG_EMC_SMCR1, REG_EMC_SMCR2, REG_EMC_SMCR3, REG_EMC_SMCR4, REG_EMC_SMCR5);
+	len += sprintf (page+len, "SACR(0-5): 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", REG_EMC_SACR0, REG_EMC_SACR1, REG_EMC_SACR2, REG_EMC_SACR3, REG_EMC_SACR4, REG_EMC_SACR5);
+	len += sprintf (page+len, "DMCR:      0x%08x\n", REG_EMC_DMCR);
+	len += sprintf (page+len, "RTCSR:     0x%04x\n", REG_EMC_RTCSR);
+	len += sprintf (page+len, "RTCOR:     0x%04x\n", REG_EMC_RTCOR);
+	len += sprintf (page+len, "DMAR(0-1): 0x%08x 0x%08x\n", REG_EMC_DMAR1, REG_EMC_DMAR2);
+	return len;
+}
+
+/*
+ * Power Manager Module
+ */
+static int pmc_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	unsigned long lpcr = REG_CPM_LPCR;
+	unsigned long mscr = REG_CPM_MSCR;
+
+	len += sprintf (page+len, "LPCR           : 0x%08lx\n", lpcr);
+	len += sprintf (page+len, "Low Power Mode : %s\n",
+			((lpcr & CPM_LPCR_LPM_MASK) == (CPM_LPCR_LPM_IDLE)) ?
+			"idle" : (((lpcr & CPM_LPCR_LPM_MASK) == (CPM_LPCR_LPM_SLEEP)) ? "sleep" : "hibernate"));
+	len += sprintf (page+len, "Doze Mode      : %s\n",
+			(lpcr & CPM_LPCR_DOZE) ? "on" : "off");
+	if (lpcr & CPM_LPCR_DOZE)
+		len += sprintf (page+len, "     duty      : %d\n", (int)((lpcr & CPM_LPCR_DUTY_MASK) >> CPM_LPCR_DUTY_BIT));
+	len += sprintf (page+len, "CKO1           : %s\n",
+			(REG_CPM_CFCR & CPM_CFCR_CKOEN1) ? "enable" : "disable");
+	len += sprintf (page+len, "UART0          : %s\n",
+			(mscr & CPM_MSCR_MSTP_UART0) ? "stopped" : "running");
+	len += sprintf (page+len, "UART1          : %s\n",
+			(mscr & CPM_MSCR_MSTP_UART1) ? "stopped" : "running");
+	len += sprintf (page+len, "UART2          : %s\n",
+			(mscr & CPM_MSCR_MSTP_UART2) ? "stopped" : "running");
+	len += sprintf (page+len, "UART3          : %s\n",
+			(mscr & CPM_MSCR_MSTP_UART3) ? "stopped" : "running");
+	len += sprintf (page+len, "OST            : %s\n",
+			(mscr & CPM_MSCR_MSTP_OST) ? "stopped" : "running");
+	len += sprintf (page+len, "DMAC           : %s\n",
+			(mscr & CPM_MSCR_MSTP_DMAC) ? "stopped" : "running");
+	len += sprintf (page+len, "ETH            : %s\n",
+			(mscr & CPM_MSCR_MSTP_ETH) ? "stopped" : "running");
+	len += sprintf (page+len, "UHC/UDC        : %s\n",
+			(mscr & CPM_MSCR_MSTP_UHC) ? "stopped" : "running");
+	len += sprintf (page+len, "PWM0           : %s\n",
+			(mscr & CPM_MSCR_MSTP_PWM0) ? "stopped" : "running");
+	len += sprintf (page+len, "PWM1           : %s\n",
+			(mscr & CPM_MSCR_MSTP_PWM1) ? "stopped" : "running");
+	len += sprintf (page+len, "I2C            : %s\n",
+			(mscr & CPM_MSCR_MSTP_I2C) ? "stopped" : "running");
+	len += sprintf (page+len, "SSI            : %s\n",
+			(mscr & CPM_MSCR_MSTP_SSI) ? "stopped" : "running");
+	len += sprintf (page+len, "SCC            : %s\n",
+			(mscr & CPM_MSCR_MSTP_SCC) ? "stopped" : "running");
+	return len;
+}
+
+static int pmc_write_proc(struct file *file, const char __user *buffer, unsigned long count, void *data)
+{
+	REG_CPM_MSCR = simple_strtoul(buffer, 0, 16);
+	return count;
+}
+
+/*
+ * Clock Generation Module
+ */
+static int cgm_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	unsigned int cfcr = REG_CPM_CFCR;
+	unsigned int plcr1 = REG_CPM_PLCR1;
+	unsigned int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned int od[4] = {1, 2, 2, 4};
+
+
+	len += sprintf (page+len, "PLCR1          : 0x%08x\n", plcr1);
+	len += sprintf (page+len, "CFCR           : 0x%08x\n", cfcr);
+	len += sprintf (page+len, "PLL            : %s\n",
+			(plcr1 & CPM_PLCR1_PLL1EN) ? "ON" : "OFF");
+	len += sprintf (page+len, "NF:NR:NO       : %d:%d:%d\n",
+			__cpm_plcr1_fd() + 2,
+			__cpm_plcr1_rd() + 2,
+			od[__cpm_plcr1_od()]
+		);
+	len += sprintf (page+len, "I:S:M:P        : %d:%d:%d:%d\n",
+			div[(cfcr & CPM_CFCR_IFR_MASK) >> CPM_CFCR_IFR_BIT],
+			div[(cfcr & CPM_CFCR_SFR_MASK) >> CPM_CFCR_SFR_BIT],
+			div[(cfcr & CPM_CFCR_MFR_MASK) >> CPM_CFCR_MFR_BIT],
+			div[(cfcr & CPM_CFCR_PFR_MASK) >> CPM_CFCR_PFR_BIT]
+		);
+	len += sprintf (page+len, "PLL Freq       : %d MHz\n", __cpm_get_pllout()/1000000);
+	len += sprintf (page+len, "ICLK           : %d MHz\n", __cpm_get_iclk()/1000000);
+	len += sprintf (page+len, "SCLK           : %d MHz\n", __cpm_get_sclk()/1000000);
+	len += sprintf (page+len, "MCLK           : %d MHz\n", __cpm_get_mclk()/1000000);
+	len += sprintf (page+len, "PCLK           : %d MHz\n", __cpm_get_pclk()/1000000);
+	len += sprintf (page+len, "DEVCLK         : %d MHz\n", __cpm_get_devclk()/1000000);
+	len += sprintf (page+len, "RTCCLK         : %d KHz\n", __cpm_get_rtcclk()/1000);
+	len += sprintf (page+len, "USBCLK         : %d MHz\n", __cpm_get_usbclk()/1000000);
+#if defined(CONFIG_FB_JZ)
+	len += sprintf (page+len, "LCDCLK         : %d MHz\n", __cpm_get_lcdclk()/1000000);
+	len += sprintf (page+len, "PIXCLK         : %d MHz\n", __cpm_get_pixclk()/1000000);
+#endif
+	return len;
+}
+
+static int cgm_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	REG_CPM_CFCR = simple_strtoul(buffer, 0, 16);
+	return count;
+}
+
+/*
+ * WDT
+ */
+static int wdt_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+
+	len += sprintf (page+len, "WDT_WTCSR   : 0x%08x\n", REG_WDT_WTCSR);
+	len += sprintf (page+len, "WDT_WTCNT   : 0x%08x\n", REG_WDT_WTCNT);
+
+	return len;
+}
+
+static int wdt_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	unsigned long cnt = simple_strtoul(buffer, 0, 16);
+
+	REG_WDT_WTCNT = cnt;
+	REG_WDT_WTCSR = WDT_WTCSR_START;
+
+	return count;
+}
+
+/*
+ * PWM
+ */
+
+static int proc_jz_pwm_read_byte(char *page, char **start, off_t off,
+				 int count, int *eof, void *data)
+{
+	return sprintf (page, "0x%02x\n", REG8(data));
+}
+
+static int proc_jz_pwm_read_word(char *page, char **start, off_t off,
+			      int count, int *eof, void *data)
+{
+     	return sprintf (page, "0x%04x\n", REG16(data));
+}
+
+static int proc_jz_pwm_write_byte(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	REG8(data) = simple_strtoul(buffer, 0, 16);
+	return count;
+}
+
+static int proc_jz_pwm_write_word(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	REG16(data) =  simple_strtoul(buffer, 0, 16);
+	return count;
+}
+
+#define PWM_NUM 2
+
+static int jz_pwm_proc_init(void)
+{
+	struct proc_dir_entry *proc_jz_pwm, *res;
+	char name[16];
+	unsigned char i;
+
+	for (i = 0; i < PWM_NUM; i++) {
+		sprintf(name, "pwm%d", i);
+		proc_jz_pwm = proc_mkdir(name, proc_jz_root);
+		res = create_proc_entry("control", 0600, proc_jz_pwm);
+		if ( res) {
+			res->read_proc  = proc_jz_pwm_read_byte;
+			res->write_proc = proc_jz_pwm_write_byte;
+			if (i)
+				res->data = (void * )PWM_CTR(1);
+			else
+				res->data = (void * )PWM_CTR(0);
+		}
+		res = create_proc_entry("period", 0600, proc_jz_pwm);
+		if ( res) {
+			res->read_proc  = proc_jz_pwm_read_word;
+			res->write_proc = proc_jz_pwm_write_word;
+			if (i)
+				res->data = (void *)PWM_PER(1);
+			else
+				res->data = (void *)PWM_PER(0);
+		}
+		res = create_proc_entry("duty", 0600, proc_jz_pwm);
+		if ( res) {
+			res->read_proc  = proc_jz_pwm_read_word;
+			res->write_proc = proc_jz_pwm_write_word;
+			if (i)
+				res->data = (void * )PWM_DUT(1);
+			else
+				res->data = (void * )PWM_DUT(0);
+		}
+	}
+	return 0;
+}
+
+/*
+ * /proc/jz/xxx entry
+ *
+ */
+static int __init jz_proc_init(void)
+{
+	struct proc_dir_entry *entry;
+
+	/* create /proc/jz */
+	proc_jz_root = proc_mkdir("jz", 0);
+
+	/* create /proc/jz/emc */
+	entry = create_proc_entry("emc", 0644, proc_jz_root);
+	if (entry) {
+		entry->read_proc = emc_read_proc;
+		entry->write_proc = NULL;
+		entry->data = NULL;
+	}
+
+	/* create /proc/jz/pmc */
+	entry = create_proc_entry("pmc", 0644, proc_jz_root);
+	if (entry) {
+		entry->read_proc = pmc_read_proc;
+		entry->write_proc = pmc_write_proc;
+		entry->data = NULL;
+	}
+
+	/* create /proc/jz/cgm */
+	entry = create_proc_entry("cgm", 0644, proc_jz_root);
+	if (entry) {
+		entry->read_proc = cgm_read_proc;
+		entry->write_proc = cgm_write_proc;
+		entry->data = NULL;
+	}
+
+	/* create /proc/jz/wdt */
+	entry = create_proc_entry("wdt", 0644, proc_jz_root);
+	if (entry) {
+		entry->read_proc = wdt_read_proc;
+		entry->write_proc = wdt_write_proc;
+		entry->data = NULL;
+	}
+
+	/* PWM */
+	jz_pwm_proc_init();
+
+	return 0;
+}
+
+__initcall(jz_proc_init);
--- linux-2.6.24.7.old/arch/mips/jz4730/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4730/prom.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,198 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *    PROM library initialisation code, supports YAMON and U-Boot.
+ *
+ * Copyright 2000, 2001, 2006 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	ppopov@mvista.com or source@mvista.com
+ *
+ * This file was derived from Carsten Langgaard's
+ * arch/mips/mips-boards/xx files.
+ *
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+#include <asm/jzsoc.h>
+
+/* #define DEBUG_CMDLINE */
+
+int prom_argc;
+char **prom_argv, **prom_envp;
+
+char * prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
+
+void  prom_init_cmdline(void)
+{
+	char *cp;
+	int actr;
+
+	actr = 1; /* Always ignore argv[0] */
+
+	cp = &(arcs_cmdline[0]);
+	while(actr < prom_argc) {
+	        strcpy(cp, prom_argv[actr]);
+		cp += strlen(prom_argv[actr]);
+		*cp++ = ' ';
+		actr++;
+	}
+	if (cp != &(arcs_cmdline[0])) /* get rid of trailing space */
+		--cp;
+	if (prom_argc > 1)
+		*cp = '\0';
+
+}
+
+
+char *prom_getenv(char *envname)
+{
+#if 0
+	/*
+	 * Return a pointer to the given environment variable.
+	 * YAMON uses "name", "value" pairs, while U-Boot uses "name=value".
+	 */
+
+	char **env = prom_envp;
+	int i = strlen(envname);
+	int yamon = (*env && strchr(*env, '=') == NULL);
+
+	while (*env) {
+		if (yamon) {
+			if (strcmp(envname, *env++) == 0)
+				return *env;
+		} else {
+			if (strncmp(envname, *env, i) == 0 && (*env)[i] == '=')
+				return *env + i + 1;
+		}
+		env++;
+	}
+#endif
+	return NULL;
+}
+
+inline unsigned char str2hexnum(unsigned char c)
+{
+	if(c >= '0' && c <= '9')
+		return c - '0';
+	if(c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	if(c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	return 0; /* foo */
+}
+
+inline void str2eaddr(unsigned char *ea, unsigned char *str)
+{
+	int i;
+
+	for(i = 0; i < 6; i++) {
+		unsigned char num;
+
+		if((*str == '.') || (*str == ':'))
+			str++;
+		num = str2hexnum(*str++) << 4;
+		num |= (str2hexnum(*str++));
+		ea[i] = num;
+	}
+}
+
+int get_ethernet_addr(char *ethernet_addr)
+{
+        char *ethaddr_str;
+
+        ethaddr_str = prom_getenv("ethaddr");
+	if (!ethaddr_str) {
+	        printk("ethaddr not set in boot prom\n");
+		return -1;
+	}
+	str2eaddr(ethernet_addr, ethaddr_str);
+
+#if 0
+	{
+		int i;
+
+	printk("get_ethernet_addr: ");
+	for (i=0; i<5; i++)
+		printk("%02x:", (unsigned char)*(ethernet_addr+i));
+	printk("%02x\n", *(ethernet_addr+i));
+	}
+#endif
+
+	return 0;
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
+
+void __init prom_init(void)
+{
+	unsigned char *memsize_str;
+	unsigned long memsize;
+
+	prom_argc = (int) fw_arg0;
+	prom_argv = (char **) fw_arg1;
+	prom_envp = (char **) fw_arg2;
+
+	mips_machtype = MACH_INGENIC_JZ4730;
+
+	prom_init_cmdline();
+	memsize_str = prom_getenv("memsize");
+	if (!memsize_str) {
+		memsize = 0x04000000;
+	} else {
+		memsize = simple_strtol(memsize_str, NULL, 0);
+	}
+	add_memory_region(0, memsize, BOOT_MEM_RAM);
+}
+
+/* used by early printk */
+void prom_putchar(char c)
+{
+	volatile u8 *uart_lsr = (volatile u8 *)(UART3_BASE + OFF_LSR);
+	volatile u8 *uart_tdr = (volatile u8 *)(UART3_BASE + OFF_TDR);
+
+	/* Wait for fifo to shift out some bytes */
+	while ( !((*uart_lsr & (UARTLSR_TDRQ | UARTLSR_TEMT)) == 0x60) );
+
+	*uart_tdr = (u8)c;
+}
+
+const char *get_system_type(void)
+{
+	return "JZ4730";
+}
+
+EXPORT_SYMBOL(prom_getcmdline);
+EXPORT_SYMBOL(get_ethernet_addr);
+EXPORT_SYMBOL(str2eaddr);
--- linux-2.6.24.7.old/arch/mips/jz4730/reset.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4730/reset.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+ * linux/arch/mips/jz4730/reset.c
+ *
+ * JZ4730 reset routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/reboot.h>
+#include <asm/system.h>
+#include <asm/jzsoc.h>
+
+void jz_restart(char *command)
+{
+	__wdt_set_count(0xffffffff-32);	/* reset after 1/1024 s */
+	__wdt_start();
+	while (1);
+}
+
+void jz_halt(void)
+{
+	__wdt_set_count(0xffffffff-32);	/* reset after 1/1024 s */
+	__wdt_start();
+	while (1);
+}
+
+void jz_power_off(void)
+{
+	jz_halt();
+}
--- linux-2.6.24.7.old/arch/mips/jz4730/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4730/setup.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,182 @@
+/*
+ * linux/arch/mips/jz4730/setup.c
+ *
+ * JZ4730 CPU common setup routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/ioport.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_8250.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/pgtable.h>
+#include <asm/time.h>
+#include <asm/jzsoc.h>
+
+#ifdef CONFIG_PC_KEYB
+#include <asm/keyboard.h>
+#endif
+
+jz_clocks_t jz_clocks;
+
+extern char * __init prom_getcmdline(void);
+extern void __init jz_board_setup(void);
+extern void jz_restart(char *);
+extern void jz_halt(void);
+extern void jz_power_off(void);
+extern void jz_time_init(void);
+
+static void __init sysclocks_setup(void)
+{
+#ifndef CONFIG_JZ4730_URANUS
+	jz_clocks.iclk = __cpm_get_iclk();
+	jz_clocks.sclk = __cpm_get_sclk();
+	jz_clocks.mclk = __cpm_get_mclk();
+	jz_clocks.pclk = __cpm_get_pclk();
+	jz_clocks.devclk = __cpm_get_devclk();
+	jz_clocks.rtcclk = __cpm_get_rtcclk();
+	jz_clocks.uartclk = __cpm_get_uartclk();
+	jz_clocks.lcdclk = __cpm_get_lcdclk();
+	jz_clocks.pixclk = __cpm_get_pixclk();
+	jz_clocks.usbclk = __cpm_get_usbclk();
+	jz_clocks.i2sclk = __cpm_get_i2sclk();
+	jz_clocks.mscclk = __cpm_get_mscclk();
+#else  /* URANUS FPGA */
+
+#define FPGACLK 8000000
+
+	jz_clocks.iclk = FPGACLK;
+	jz_clocks.sclk = FPGACLK;
+	jz_clocks.mclk = FPGACLK;
+	jz_clocks.devclk = FPGACLK;
+	jz_clocks.rtcclk = FPGACLK;
+	jz_clocks.uartclk = FPGACLK;
+	jz_clocks.pixclk = FPGACLK;
+	jz_clocks.lcdclk = FPGACLK;
+	jz_clocks.usbclk = FPGACLK;
+	jz_clocks.i2sclk = FPGACLK;
+	jz_clocks.mscclk = FPGACLK;
+#endif
+
+	printk("CPU clock: %dMHz, System clock: %dMHz, Memory clock: %dMHz, Peripheral clock: %dMHz\n",
+	       (jz_clocks.iclk + 500000) / 1000000,
+	       (jz_clocks.sclk + 500000) / 1000000,
+	       (jz_clocks.mclk + 500000) / 1000000,
+	       (jz_clocks.pclk + 500000) / 1000000);
+}
+
+static void __init soc_cpm_setup(void)
+{
+	__cpm_idle_mode();
+	__cpm_enable_cko1();
+	__cpm_start_all();
+
+	/* get system clocks */
+	sysclocks_setup();
+}
+
+static void __init soc_harb_setup(void)
+{
+//	__harb_set_priority(0x00);  /* CIM>LCD>DMA>ETH>PCI>USB>CBB */
+//	__harb_set_priority(0x03);  /* LCD>CIM>DMA>ETH>PCI>USB>CBB */
+	__harb_set_priority(0x08);  /* DMAC>LCD>CIM>ETH>USB>CIM */
+//	__harb_set_priority(0x0a);  /* ETH>LCD>CIM>DMA>PCI>USB>CBB */
+}
+
+static void __init soc_emc_setup(void)
+{
+}
+
+static void __init soc_dmac_setup(void)
+{
+	__dmac_enable_all_channels();
+}
+
+static void __init jz_soc_setup(void)
+{
+	soc_cpm_setup();
+	soc_harb_setup();
+	soc_emc_setup();
+	soc_dmac_setup();
+}
+
+static void __init jz_serial_setup(void)
+{
+#ifdef CONFIG_SERIAL_8250
+	struct uart_port s;
+
+	memset(&s, 0, sizeof(s));
+
+	s.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST;
+	s.iotype = UPIO_MEM;
+	s.regshift = 2;
+	s.uartclk = jz_clocks.uartclk;
+
+	s.line = 0;
+	s.membase = (u8 *)UART0_BASE;
+	s.irq = IRQ_UART0;
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial ttyS0 setup failed!\n");
+	}
+
+	s.line = 1;
+	s.membase = (u8 *)UART1_BASE;
+	s.irq = IRQ_UART1;
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial ttyS1 setup failed!\n");
+	}
+
+	s.line = 2;
+	s.membase = (u8 *)UART2_BASE;
+	s.irq = IRQ_UART2;
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial ttyS2 setup failed!\n");
+	}
+
+	s.line = 3;
+	s.membase = (u8 *)UART3_BASE;
+	s.irq = IRQ_UART3;
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial ttyS3 setup failed!\n");
+	}
+#endif
+}
+
+void __init plat_mem_setup(void)
+{
+	char *argptr;
+
+	argptr = prom_getcmdline();
+
+	/* IO/MEM resources. */
+	set_io_port_base(0);
+	ioport_resource.start = 0x00000000;
+	ioport_resource.end = 0xffffffff;
+	iomem_resource.start = 0x00000000;
+	iomem_resource.end = 0xffffffff;
+
+	_machine_restart = jz_restart;
+	_machine_halt = jz_halt;
+	pm_power_off = jz_power_off;
+
+	jz_soc_setup();    /* soc specific setup */
+	jz_serial_setup(); /* serial port setup */
+	jz_board_setup();  /* board specific setup */
+}
--- linux-2.6.24.7.old/arch/mips/jz4730/sleep.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4730/sleep.S	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,307 @@
+/*
+ * linux/arch/mips/jz4730/sleep.S
+ *
+ * jz4730 Assembler Sleep/WakeUp Management Routines
+ *
+ * Copyright (C) 2005 Ingenic Semiconductor
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/mach-jz4730/regs.h>
+
+	.text
+	.set	noreorder
+	.set	noat
+
+	.extern jz_flush_cache_all
+
+/*
+ * jz_cpu_suspend()
+ *
+ * Forces CPU into hibernate mode
+ */
+
+	.globl	jz_cpu_suspend
+jz_cpu_suspend:
+
+	/* save hi, lo and general registers except k0($26) and k1($27) (total 32) */
+	move	k0, sp
+	addiu	k0, k0, -(32*4)
+	mfhi	k1
+	sw	$0,  0(k0)
+	sw	$1,  4(k0)
+	sw	k1,  120(k0)		/* hi */
+	mflo	k1
+	sw	$2,  8(k0)
+	sw	$3,  12(k0)
+	sw	k1,  124(k0)		/* lo */
+	sw	$4,  16(k0)
+	sw	$5,  20(k0)
+	sw	$6,  24(k0)
+	sw	$7,  28(k0)
+	sw	$8,  32(k0)
+	sw	$9,  36(k0)
+	sw	$10, 40(k0)
+	sw	$11, 44(k0)
+	sw	$12, 48(k0)
+	sw	$13, 52(k0)
+	sw	$14, 56(k0)
+	sw	$15, 60(k0)
+	sw	$16, 64(k0)
+	sw	$17, 68(k0)
+	sw	$18, 72(k0)
+	sw	$19, 76(k0)
+	sw	$20, 80(k0)
+	sw	$21, 84(k0)
+	sw	$22, 88(k0)
+	sw	$23, 92(k0)
+	sw	$24, 96(k0)
+	sw	$25, 100(k0)
+	sw	$28, 104(k0)
+	sw	$29, 108(k0)		/* saved sp */
+	sw	$30, 112(k0)
+	sw	$31, 116(k0)		/* saved ra */
+	move	sp, k0
+
+	/* save CP0 registers and sp (total 26) */
+	move	k0, sp
+	addiu	k0, k0, -(26*4)
+
+	mfc0	$1, CP0_INDEX
+	mfc0	$2, CP0_RANDOM
+	mfc0	$3, CP0_ENTRYLO0
+	mfc0	$4, CP0_ENTRYLO1
+	mfc0	$5, CP0_CONTEXT
+	mfc0	$6, CP0_PAGEMASK
+	mfc0	$7, CP0_WIRED
+	mfc0	$8, CP0_BADVADDR
+	mfc0	$9, CP0_ENTRYHI
+	mfc0	$10, CP0_STATUS
+/*	mfc0	$11, $12, 1*/		/* IntCtl */
+	mfc0	$12, CP0_CAUSE
+	mfc0	$13, CP0_EPC
+/*	mfc0	$14, $15, 1*/		/* EBase */
+	mfc0	$15, CP0_CONFIG
+/*	mfc0	$16, CP0_CONFIG, 7*/	/* Config 7 */
+	mfc0	$17, CP0_LLADDR
+	mfc0	$18, CP0_WATCHLO
+	mfc0	$19, CP0_WATCHHI
+	mfc0	$20, CP0_DEBUG
+	mfc0	$21, CP0_DEPC
+	mfc0	$22, CP0_ECC
+	mfc0	$23, CP0_TAGLO
+	mfc0	$24, CP0_ERROREPC
+	mfc0	$25, CP0_DESAVE
+
+	sw	$1,  0(k0)
+	sw	$2,  4(k0)
+	sw	$3,  8(k0)
+	sw	$4,  12(k0)
+	sw	$5,  16(k0)
+	sw	$6,  20(k0)
+	sw	$7,  24(k0)
+	sw	$8,  28(k0)
+	sw	$9,  32(k0)
+	sw	$10, 36(k0)
+	sw	$11, 40(k0)
+	sw	$12, 44(k0)
+	sw	$13, 48(k0)
+	sw	$14, 52(k0)
+	sw	$15, 56(k0)
+	sw	$16, 60(k0)
+	sw	$17, 64(k0)
+	sw	$18, 68(k0)
+	sw	$19, 72(k0)
+	sw	$20, 76(k0)
+	sw	$21, 80(k0)
+	sw	$22, 84(k0)
+	sw	$23, 88(k0)
+	sw	$24, 92(k0)
+	sw	$25, 96(k0)
+	sw	$29, 100(k0)	/* saved sp */
+	move	sp, k0
+
+	/* preserve virtual address of stack */
+	la	k0, suspend_save_sp
+	sw	sp, 0(k0)
+
+	/* flush caches and write buffers */
+	jal	jz_flush_cache_all
+	nop
+
+	/* set new sdram refresh constant */
+	li	t0, 1
+	la	t1, EMC_RTCOR
+	sh	t0, 0(t1)
+
+	/* disable PLL */
+	la	t0, CPM_PLCR1
+	sw	$0, 0(t0)
+
+	/* put CPU to hibernate mode */
+	la	t0, CPM_LPCR
+	lw	t1, 0(t0)
+	li	t2, ~CPM_LPCR_LPM_MASK
+	and	t1, t2
+	ori	t1, CPM_LPCR_LPM_HIBERNATE
+
+	.align	5
+	/* align execution to a cache line */
+	j	1f
+
+	.align	5
+1:
+	/* all needed values are now in registers.
+	 * These last instructions should be in cache
+	 */
+	nop
+	nop
+
+	/* set hibernate mode */
+	sw	t1, 0(t0)
+	nop
+
+	/* enter hibernate mode */
+	.set	mips3
+	wait
+	nop
+	.set	mips2
+
+2:	j	2b		/* loop waiting for suspended */
+	nop
+
+/*
+ * jz_cpu_resume()
+ *
+ * entry point from bootloader into kernel during resume
+ */
+
+	.align 5
+	.globl	jz_cpu_resume
+jz_cpu_resume:
+	/* clear SCR.HGP */
+	la	t0, CPM_SCR
+	lw	t1, 0(t0)
+	li	t2, ~CPM_SCR_HGP
+	and	t1, t2
+	sw	t1, 0(t0)
+
+	/* restore LPCR.LPM to IDLE mode */
+	la	t0, CPM_LPCR
+	lw	t1, 0(t0)
+	li	t2, ~CPM_LPCR_LPM_MASK
+	and	t1, t2
+	ori	t1, CPM_LPCR_LPM_IDLE
+	sw	t1, 0(t0)
+
+	/* restore saved sp */
+	la	t0, suspend_save_sp
+	lw	sp, 0(t0)
+
+	/* restore CP0 registers */
+	move	k0, sp
+	lw	$1,  0(k0)
+	lw	$2,  4(k0)
+	lw	$3,  8(k0)
+	lw	$4,  12(k0)
+	lw	$5,  16(k0)
+	lw	$6,  20(k0)
+	lw	$7,  24(k0)
+	lw	$8,  28(k0)
+	lw	$9,  32(k0)
+	lw	$10, 36(k0)
+	lw	$11, 40(k0)
+	lw	$12, 44(k0)
+	lw	$13, 48(k0)
+	lw	$14, 52(k0)
+	lw	$15, 56(k0)
+	lw	$16, 60(k0)
+	lw	$17, 64(k0)
+	lw	$18, 68(k0)
+	lw	$19, 72(k0)
+	lw	$20, 76(k0)
+	lw	$21, 80(k0)
+	lw	$22, 84(k0)
+	lw	$23, 88(k0)
+	lw	$24, 92(k0)
+	lw	$25, 96(k0)
+	lw	$29, 100(k0)	/* saved sp */
+
+	mtc0	$1, CP0_INDEX
+	mtc0	$2, CP0_RANDOM
+	mtc0	$3, CP0_ENTRYLO0
+	mtc0	$4, CP0_ENTRYLO1
+	mtc0	$5, CP0_CONTEXT
+	mtc0	$6, CP0_PAGEMASK
+	mtc0	$7, CP0_WIRED
+	mtc0	$8, CP0_BADVADDR
+	mtc0	$9, CP0_ENTRYHI
+	mtc0	$10, CP0_STATUS
+/*	mtc0	$11, $12, 1*/		/* IntCtl */
+	mtc0	$12, CP0_CAUSE
+	mtc0	$13, CP0_EPC
+/*	mtc0	$14, $15, 1*/		/* EBase */
+	mtc0	$15, CP0_CONFIG
+/*	mtc0	$16, CP0_CONFIG, 7*/	/* Config 7 */
+	mtc0	$17, CP0_LLADDR
+	mtc0	$18, CP0_WATCHLO
+	mtc0	$19, CP0_WATCHHI
+	mtc0	$20, CP0_DEBUG
+	mtc0	$21, CP0_DEPC
+	mtc0	$22, CP0_ECC
+	mtc0	$23, CP0_TAGLO
+	mtc0	$24, CP0_ERROREPC
+	mtc0	$25, CP0_DESAVE
+
+	/* restore general registers */
+	move	k0, sp
+	lw	k1,  120(k0)		/* hi */
+	lw	$0,  0(k0)
+	lw	$1,  4(k0)
+	mthi	k1
+	lw	k1,  124(k0)		/* lo */
+	lw	$2,  8(k0)
+	lw	$3,  12(k0)
+	mtlo	k1
+	lw	$4,  16(k0)
+	lw	$5,  20(k0)
+	lw	$6,  24(k0)
+	lw	$7,  28(k0)
+	lw	$8,  32(k0)
+	lw	$9,  36(k0)
+	lw	$10, 40(k0)
+	lw	$11, 44(k0)
+	lw	$12, 48(k0)
+	lw	$13, 52(k0)
+	lw	$14, 56(k0)
+	lw	$15, 60(k0)
+	lw	$16, 64(k0)
+	lw	$17, 68(k0)
+	lw	$18, 72(k0)
+	lw	$19, 76(k0)
+	lw	$20, 80(k0)
+	lw	$21, 84(k0)
+	lw	$22, 88(k0)
+	lw	$23, 92(k0)
+	lw	$24, 96(k0)
+	lw	$25, 100(k0)
+	lw	$28, 104(k0)
+	lw	$29, 108(k0)		/* saved sp */
+	lw	$30, 112(k0)
+	lw	$31, 116(k0)		/* saved ra */
+
+	/* return to caller */
+	jr	ra
+	nop
+
+suspend_save_sp:
+	.word	0			/* preserve sp here */
+
+	.set	reorder
--- linux-2.6.24.7.old/arch/mips/jz4730/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4730/time.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,129 @@
+/*
+ *  linux/arch/mips/jz4730/time.c
+ *
+ *  Setting up the clock on the JZ4730 boards.
+ *
+ * Copyright (c) 2006-2008  Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/clockchips.h>
+
+#include <asm/time.h>
+#include <asm/jzsoc.h>
+
+#define JZ_TIMER_CHAN  0
+#define JZ_TIMER_IRQ   IRQ_OST0
+#define JZ_TIMER_CLOCK JZ_EXTAL
+
+static unsigned int timer_latch;
+
+void (*jz_timer_callback)(void);
+
+static void jz_set_mode(enum clock_event_mode mode,
+			struct clock_event_device *evt)
+{
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+                break;
+        case CLOCK_EVT_MODE_ONESHOT:
+        case CLOCK_EVT_MODE_UNUSED:
+        case CLOCK_EVT_MODE_SHUTDOWN:
+                break;
+        case CLOCK_EVT_MODE_RESUME:
+                break;
+        }
+}
+
+static struct clock_event_device jz_clockevent_device = {
+	.name		= "jz-timer",
+	.features	= CLOCK_EVT_FEAT_PERIODIC,
+
+	/* .mult, .shift, .max_delta_ns and .min_delta_ns left uninitialized */
+
+	.rating		= 300,
+	.irq		= JZ_TIMER_IRQ,
+	.set_mode	= jz_set_mode,
+};
+
+static irqreturn_t jz_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *cd = dev_id;
+
+	__ost_clear_uf(JZ_TIMER_CHAN); /* ACK timer */
+
+	if (jz_timer_callback)
+		jz_timer_callback();
+
+	cd->event_handler(cd);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction jz_irqaction = {
+	.handler	= jz_timer_interrupt,
+	.flags		= IRQF_DISABLED | IRQF_PERCPU,
+	.name		= "jz-timer",
+};
+
+cycle_t jz_get_cycles(void)
+{
+	unsigned int jz_timer_cnt;
+#if 0				/* clock source use pll, read directly */
+	jz_timer_cnt = timer_latch - REG_OST_TCNT(JZ_TIMER_CHAN);
+#else  /* clock source use RTCClock or Extall Clock, wait read ready */
+	jz_timer_cnt = REG_OST_TCNT(JZ_TIMER_CHAN); /* dummy read */
+	while ( __ost_is_busy(JZ_TIMER_CHAN) ) ; /* wait read ready */
+	jz_timer_cnt = timer_latch - REG_OST_TCRB(JZ_TIMER_CHAN);
+#endif
+
+	/* convert jiffes to jz timer cycles */
+	return (cycle_t)( jiffies*((JZ_TIMER_CLOCK)/HZ) + jz_timer_cnt);
+}
+
+static struct clocksource clocksource_jz = {
+	.name 		= "jz_clocksource",
+	.rating		= 300,
+	.read		= jz_get_cycles,
+	.mask		= 0xFFFFFFFF,
+	.shift 		= 10,	/* control clocksource.mult's accuracy */
+	.flags		= CLOCK_SOURCE_WATCHDOG,
+};
+
+static int __init jz_clocksource_init(void)
+{
+	clocksource_jz.mult = clocksource_hz2mult(JZ_TIMER_CLOCK, clocksource_jz.shift);
+	clocksource_register(&clocksource_jz);
+	return 0;
+}
+
+static void __init jz_timer_setup(void)
+{
+	struct clock_event_device *cd = &jz_clockevent_device;
+	struct irqaction *action = &jz_irqaction;
+	unsigned int cpu = smp_processor_id();
+
+	jz_clocksource_init();
+	cd->cpumask = cpumask_of_cpu(cpu);
+	clockevents_register_device(cd);
+	action->dev_id = cd;
+	setup_irq(JZ_TIMER_IRQ, &jz_irqaction);
+}
+
+void __init plat_time_init(void)
+{
+	/* Init timer, timer clock soure use extal clock */
+	timer_latch = (JZ_TIMER_CLOCK + (HZ>>1)) / HZ;
+	__ost_set_mode(JZ_TIMER_CHAN, OST_TCSR_UIE | OST_TCSR_CKS_EXTAL);
+	__ost_set_reload(JZ_TIMER_CHAN, timer_latch);
+	__ost_set_count(JZ_TIMER_CHAN, timer_latch);
+	__ost_enable_channel(JZ_TIMER_CHAN);
+
+	jz_timer_setup();
+}
--- linux-2.6.24.7.old/arch/mips/jz4740/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/Makefile	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,26 @@
+#
+# Makefile for the Ingenic JZ4740.
+#
+
+# Object file lists.
+
+obj-y += prom.o irq.o time.o reset.o setup.o dma.o \
+	platform.o i2c.o
+
+obj-$(CONFIG_PROC_FS)		+= proc.o
+
+# board specific support
+
+obj-$(CONFIG_JZ4740_PAVO)	+= board-pavo.o
+obj-$(CONFIG_JZ4740_LEO)	+= board-leo.o
+obj-$(CONFIG_JZ4740_LYRA)	+= board-lyra.o
+obj-$(CONFIG_JZ4725_DIPPER)	+= board-dipper.o
+obj-$(CONFIG_JZ4720_VIRGO)	+= board-virgo.o
+
+# PM support
+
+obj-$(CONFIG_PM_LEGACY)         +=pm.o
+
+# CPU Frequency scaling support
+
+obj-$(CONFIG_CPU_FREQ_JZ)       +=cpufreq.o
--- linux-2.6.24.7.old/arch/mips/jz4740/board-dipper.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/board-dipper.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,117 @@
+/*
+ * linux/arch/mips/jz4740/board-dipper.c
+ *
+ * JZ4725 Dipper board setup routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+
+#include <asm/jzsoc.h>
+
+extern void (*jz_timer_callback)(void);
+
+#if 0
+static void dancing(void)
+{
+	static unsigned int count = 0;
+
+	count ++;
+	count &= 1;
+
+	if (count)
+		__gpio_set_pin(GPIO_LED_EN);
+	else
+		__gpio_clear_pin(GPIO_LED_EN);
+}
+#endif
+
+static void dipper_timer_callback(void)
+{
+	static unsigned long count = 0;
+
+	if ((++count) % 50 == 0) {
+//		dancing();
+		count = 0;
+	}
+}
+
+static void __init board_cpm_setup(void)
+{
+	/* Stop unused module clocks here.
+	 * We have started all module clocks at arch/mips/jz4740/setup.c.
+	 */
+}
+
+static void __init board_gpio_setup(void)
+{
+	/*
+	 * Most of the GPIO pins should have been initialized by the boot-loader
+	 */
+
+	/*
+	 * Initialize MSC pins
+	 */
+	__gpio_as_msc();
+
+	/*
+	 * Initialize Smart LCD pins
+	 */
+//	__gpio_as_slcd_18bit();
+
+	/*
+	 * Initialize SSI pins
+	 */
+	__gpio_as_ssi();
+
+	/*
+	 * Initialize I2C pins
+	 */
+	__gpio_as_i2c();
+
+	/*
+	 * Initialize Other pins
+	 */
+	__gpio_as_output(GPIO_SD_VCC_EN_N);
+	__gpio_clear_pin(GPIO_SD_VCC_EN_N);
+
+	__gpio_as_input(GPIO_SD_CD_N);
+	__gpio_disable_pull(GPIO_SD_CD_N);
+
+	__gpio_as_input(GPIO_SD_WP);
+	__gpio_disable_pull(GPIO_SD_WP);
+
+	__gpio_as_input(GPIO_DC_DETE_N);
+	__gpio_as_input(GPIO_CHARG_STAT_N);
+	__gpio_as_input(GPIO_USB_DETE);
+
+	__gpio_as_output(GPIO_DISP_OFF_N);
+
+//	__gpio_as_output(GPIO_LED_EN);
+}
+
+void __init jz_board_setup(void)
+{
+	printk("JZ4725 DIPPER board setup\n");
+
+	board_cpm_setup();
+	board_gpio_setup();
+
+	jz_timer_callback = dipper_timer_callback;
+}
--- linux-2.6.24.7.old/arch/mips/jz4740/board-leo.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/board-leo.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,67 @@
+/*
+ * linux/arch/mips/jz4740/board-leo.c
+ *
+ * JZ4740 LEO board setup routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+
+#include <asm/jzsoc.h>
+
+extern void (*jz_timer_callback)(void);
+
+static void dancing(void)
+{
+	static unsigned char slash[] = "\\|/-";
+	static volatile unsigned char *p = (unsigned char *)0xb6000016;
+	static unsigned int count = 0;
+	*p = slash[count++];
+	count &= 3;
+}
+
+static void leo_timer_callback(void)
+{
+	static unsigned long count = 0;
+
+	if ((++count) % 10 == 0) {
+		dancing();
+		count = 0;
+	}
+}
+
+static void __init board_cpm_setup(void)
+{
+	/* Stop unused module clocks here.
+	 * We have started all module clocks at arch/mips/jz4740/setup.c.
+	 */
+}
+
+static void __init board_gpio_setup(void)
+{
+	/* All GPIO pins should have been initialized by the boot-loader */
+}
+
+void __init jz_board_setup(void)
+{
+	board_cpm_setup();
+	board_gpio_setup();
+	printk(" BOARD SETUP");
+	jz_timer_callback = leo_timer_callback;
+}
--- linux-2.6.24.7.old/arch/mips/jz4740/board-lyra.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/board-lyra.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,114 @@
+/*
+ * linux/arch/mips/jz4740/board-lyra.c
+ *
+ * JZ4740 LYRA board setup routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+
+#include <asm/jzsoc.h>
+
+extern void (*jz_timer_callback)(void);
+
+static void dancing(void)
+{
+	static unsigned int count = 0;
+
+	count ++;
+	count &= 1;
+	if (count)
+		__gpio_set_pin(GPIO_LED_EN);
+	else
+		__gpio_clear_pin(GPIO_LED_EN);
+}
+
+static void lyra_timer_callback(void)
+{
+	static unsigned long count = 0;
+
+	if ((++count) % 50 == 0) {
+		dancing();
+		count = 0;
+	}
+}
+
+static void __init board_cpm_setup(void)
+{
+	/* Stop unused module clocks here.
+	 * We have started all module clocks at arch/mips/jz4740/setup.c.
+	 */
+}
+
+static void __init board_gpio_setup(void)
+{
+	/*
+	 * Most of the GPIO pins should have been initialized by the boot-loader
+	 */
+
+	/*
+	 * Initialize MSC pins
+	 */
+	__gpio_as_msc();
+
+	/*
+	 * Initialize LCD pins
+	 */
+	__gpio_as_lcd_18bit();
+
+	/*
+	 * Initialize SSI pins
+	 */
+	__gpio_as_ssi();
+
+	/*
+	 * Initialize I2C pins
+	 */
+	__gpio_as_i2c();
+
+	/*
+	 * Initialize Other pins
+	 */
+	__gpio_as_output(GPIO_SD_VCC_EN_N);
+	__gpio_clear_pin(GPIO_SD_VCC_EN_N);
+
+	__gpio_as_input(GPIO_SD_CD_N);
+	__gpio_disable_pull(GPIO_SD_CD_N);
+
+	__gpio_as_input(GPIO_SD_WP);
+	__gpio_disable_pull(GPIO_SD_WP);
+
+	__gpio_as_input(GPIO_DC_DETE_N);
+	__gpio_as_input(GPIO_CHARG_STAT_N);
+	__gpio_as_input(GPIO_USB_DETE);
+
+	__gpio_as_output(GPIO_DISP_OFF_N);
+
+	__gpio_as_output(GPIO_LED_EN);
+}
+
+void __init jz_board_setup(void)
+{
+	printk("JZ4740 LYRA board setup\n");
+
+	board_cpm_setup();
+	board_gpio_setup();
+
+	jz_timer_callback = lyra_timer_callback;
+}
--- linux-2.6.24.7.old/arch/mips/jz4740/board-pavo.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/board-pavo.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,114 @@
+/*
+ * linux/arch/mips/jz4740/board-pavo.c
+ *
+ * JZ4740 PAVO board setup routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+
+#include <asm/jzsoc.h>
+
+extern void (*jz_timer_callback)(void);
+
+static void dancing(void)
+{
+	static unsigned int count = 0;
+
+	count ++;
+	count &= 1;
+	if (count)
+		__gpio_set_pin(GPIO_LED_EN);
+	else
+		__gpio_clear_pin(GPIO_LED_EN);
+}
+
+static void pavo_timer_callback(void)
+{
+	static unsigned long count = 0;
+
+	if ((++count) % 50 == 0) {
+		dancing();
+		count = 0;
+	}
+}
+
+static void __init board_cpm_setup(void)
+{
+	/* Stop unused module clocks here.
+	 * We have started all module clocks at arch/mips/jz4740/setup.c.
+	 */
+}
+
+static void __init board_gpio_setup(void)
+{
+	/*
+	 * Most of the GPIO pins should have been initialized by the boot-loader
+	 */
+
+	/*
+	 * Initialize MSC pins
+	 */
+	__gpio_as_msc();
+
+	/*
+	 * Initialize LCD pins
+	 */
+	__gpio_as_lcd_18bit();
+
+	/*
+	 * Initialize SSI pins
+	 */
+	__gpio_as_ssi();
+
+	/*
+	 * Initialize I2C pins
+	 */
+	__gpio_as_i2c();
+
+	/*
+	 * Initialize Other pins
+	 */
+	__gpio_as_output(GPIO_SD_VCC_EN_N);
+	__gpio_clear_pin(GPIO_SD_VCC_EN_N);
+
+	__gpio_as_input(GPIO_SD_CD_N);
+	__gpio_disable_pull(GPIO_SD_CD_N);
+
+	__gpio_as_input(GPIO_SD_WP);
+	__gpio_disable_pull(GPIO_SD_WP);
+
+	__gpio_as_input(GPIO_DC_DETE_N);
+	__gpio_as_input(GPIO_CHARG_STAT_N);
+	__gpio_as_input(GPIO_USB_DETE);
+
+	__gpio_as_output(GPIO_DISP_OFF_N);
+
+	__gpio_as_output(GPIO_LED_EN);
+}
+
+void __init jz_board_setup(void)
+{
+	printk("JZ4740 PAVO board setup\n");
+
+	board_cpm_setup();
+	board_gpio_setup();
+
+	jz_timer_callback = pavo_timer_callback;
+}
--- linux-2.6.24.7.old/arch/mips/jz4740/board-virgo.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/board-virgo.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,114 @@
+/*
+ * linux/arch/mips/jz4740/board-virgo.c
+ *
+ * JZ4720 VIRGO board setup routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+
+#include <asm/jzsoc.h>
+
+extern void (*jz_timer_callback)(void);
+
+static void dancing(void)
+{
+	static unsigned int count = 0;
+
+	count ++;
+	count &= 1;
+	if (count)
+		__gpio_set_pin(GPIO_LED_EN);
+	else
+		__gpio_clear_pin(GPIO_LED_EN);
+}
+
+static void virgo_timer_callback(void)
+{
+	static unsigned long count = 0;
+
+	if ((++count) % 50 == 0) {
+		dancing();
+		count = 0;
+	}
+}
+
+static void __init board_cpm_setup(void)
+{
+	/* Stop unused module clocks here.
+	 * We have started all module clocks at arch/mips/jz4740/setup.c.
+	 */
+}
+
+static void __init board_gpio_setup(void)
+{
+	/*
+	 * Most of the GPIO pins should have been initialized by the boot-loader
+	 */
+
+	/*
+	 * Initialize MSC pins
+	 */
+	__gpio_as_msc();
+
+	/*
+	 * Initialize LCD pins
+	 */
+//	__gpio_as_lcd_18bit();
+
+	/*
+	 * Initialize SSI pins
+	 */
+	__gpio_as_ssi();
+
+	/*
+	 * Initialize I2C pins
+	 */
+	__gpio_as_i2c();
+
+	/*
+	 * Initialize Other pins
+	 */
+	__gpio_as_output(GPIO_SD_VCC_EN_N);
+	__gpio_clear_pin(GPIO_SD_VCC_EN_N);
+
+	__gpio_as_input(GPIO_SD_CD_N);
+	__gpio_disable_pull(GPIO_SD_CD_N);
+
+//	__gpio_as_input(GPIO_SD_WP);
+//	__gpio_disable_pull(GPIO_SD_WP);
+
+	__gpio_as_input(GPIO_DC_DETE_N);
+//	__gpio_as_input(GPIO_CHARG_STAT_N);
+	__gpio_as_input(GPIO_USB_DETE);
+
+	__gpio_as_output(GPIO_DISP_OFF_N);
+
+//	__gpio_as_output(GPIO_LED_EN);
+}
+
+void __init jz_board_setup(void)
+{
+	printk("JZ4720 VIRGO board setup\n");
+
+	board_cpm_setup();
+	board_gpio_setup();
+
+	jz_timer_callback = virgo_timer_callback;
+}
--- linux-2.6.24.7.old/arch/mips/jz4740/cpufreq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/cpufreq.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,602 @@
+/*
+ * linux/arch/mips/jz4740/cpufreq.c
+ *
+ * cpufreq driver for JZ4740
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <linux/cpufreq.h>
+
+#include <asm/jzsoc.h>
+#include <asm/processor.h>
+
+#define dprintk(msg...) cpufreq_debug_printk(CPUFREQ_DEBUG_DRIVER, \
+						"cpufreq-jz4740", msg)
+
+#undef CHANGE_PLL
+
+#define PLL_UNCHANGED 0
+#define PLL_GOES_UP   1
+#define PLL_GOES_DOWN 2
+
+#define PLL_WAIT_500NS (500*(__cpm_get_cclk()/1000000000))
+
+/* Saved the boot-time parameters */
+static struct {
+	/* SDRAM parameters */
+	unsigned int mclk;  /* memory clock, KHz */
+	unsigned int tras;  /* RAS pulse width, cycles of mclk */
+	unsigned int rcd;   /* RAS to CAS Delay, cycles of mclk */
+	unsigned int tpc;   /* RAS Precharge time, cycles of mclk */
+	unsigned int trwl;  /* Write Precharge Time, cycles of mclk */
+	unsigned int trc;   /* RAS Cycle Time, cycles of mclk */
+	unsigned int rtcor; /* Refresh Time Constant */
+	unsigned int sdram_initialized;
+
+	/* LCD parameters */
+	unsigned int lcd_clk;    /* LCD clock, Hz */
+	unsigned int lcdpix_clk; /* LCD Pixel clock, Hz */
+	unsigned int lcd_clks_initialized;
+} boot_config;
+
+struct jz4740_freq_percpu_info {
+	struct cpufreq_frequency_table table[7];
+};
+
+static struct jz4740_freq_percpu_info jz4740_freq_table;
+
+/*
+ * This contains the registers value for an operating point.
+ * If only part of a register needs to change then there is
+ * a mask value for that register.
+ * When going to a new operating point the current register
+ * value is ANDed with the ~mask and ORed with the new value.
+ */
+struct dpm_regs {
+	u32 cpccr;        /* Clock Freq Control Register */
+	u32 cpccr_mask;   /* Clock Freq Control Register mask */
+	u32 cppcr;        /* PLL1 Control Register */
+	u32 cppcr_mask;   /* PLL1 Control Register mask */
+	u32 pll_up_flag;  /* New PLL freq is higher than current or not */
+};
+
+extern jz_clocks_t jz_clocks;
+
+static void jz_update_clocks(void)
+{
+	/* Next clocks must be updated if we have changed
+	 * the PLL or divisors.
+	 */
+	jz_clocks.cclk = __cpm_get_cclk();
+	jz_clocks.hclk = __cpm_get_hclk();
+	jz_clocks.mclk = __cpm_get_mclk();
+	jz_clocks.pclk = __cpm_get_pclk();
+	jz_clocks.lcdclk = __cpm_get_lcdclk();
+	jz_clocks.pixclk = __cpm_get_pixclk();
+	jz_clocks.i2sclk = __cpm_get_i2sclk();
+	jz_clocks.usbclk = __cpm_get_usbclk();
+	jz_clocks.mscclk = __cpm_get_mscclk();
+}
+
+static void
+jz_init_boot_config(void)
+{
+	if (!boot_config.lcd_clks_initialized) {
+		/* the first time to scale pll */
+		boot_config.lcd_clk = __cpm_get_lcdclk();
+		boot_config.lcdpix_clk = __cpm_get_pixclk();
+		boot_config.lcd_clks_initialized = 1;
+	}
+
+	if (!boot_config.sdram_initialized) {
+		/* the first time to scale frequencies */
+		unsigned int dmcr, rtcor;
+		unsigned int tras, rcd, tpc, trwl, trc;
+
+		dmcr = REG_EMC_DMCR;
+		rtcor = REG_EMC_RTCOR;
+
+		tras = (dmcr >> 13) & 0x7;
+		rcd = (dmcr >> 11) & 0x3;
+		tpc = (dmcr >> 8) & 0x7;
+		trwl = (dmcr >> 5) & 0x3;
+		trc = (dmcr >> 2) & 0x7;
+
+		boot_config.mclk = __cpm_get_mclk() / 1000;
+		boot_config.tras = tras + 4;
+		boot_config.rcd = rcd + 1;
+		boot_config.tpc = tpc + 1;
+		boot_config.trwl = trwl + 1;
+		boot_config.trc = trc * 2 + 1;
+		boot_config.rtcor = rtcor;
+
+		boot_config.sdram_initialized = 1;
+	}
+}
+
+static void jz_update_dram_rtcor(unsigned int new_mclk)
+{
+	unsigned int rtcor;
+
+	new_mclk /= 1000;
+	rtcor = boot_config.rtcor * new_mclk / boot_config.mclk;
+	rtcor--;
+
+	if (rtcor < 1) rtcor = 1;
+	if (rtcor > 255) rtcor = 255;
+
+	REG_EMC_RTCOR = rtcor;
+	REG_EMC_RTCNT = rtcor;
+}
+
+static void jz_update_dram_dmcr(unsigned int new_mclk)
+{
+	unsigned int dmcr;
+	unsigned int tras, rcd, tpc, trwl, trc;
+	unsigned int valid_time, new_time; /* ns */
+
+	new_mclk /= 1000;
+	tras = boot_config.tras * new_mclk / boot_config.mclk;
+	rcd = boot_config.rcd * new_mclk / boot_config.mclk;
+	tpc = boot_config.tpc * new_mclk / boot_config.mclk;
+	trwl = boot_config.trwl * new_mclk / boot_config.mclk;
+	trc = boot_config.trc * new_mclk / boot_config.mclk;
+
+	/* Validation checking */
+	valid_time = (boot_config.tras * 1000000) / boot_config.mclk;
+	new_time = (tras * 1000000) / new_mclk;
+	if (new_time < valid_time) tras += 1;
+
+	valid_time = (boot_config.rcd * 1000000) / boot_config.mclk;
+	new_time = (rcd * 1000000) / new_mclk;
+	if (new_time < valid_time) rcd += 1;
+
+	valid_time = (boot_config.tpc * 1000000) / boot_config.mclk;
+	new_time = (tpc * 1000000) / new_mclk;
+	if (new_time < valid_time) tpc += 1;
+
+	valid_time = (boot_config.trwl * 1000000) / boot_config.mclk;
+	new_time = (trwl * 1000000) / new_mclk;
+	if (new_time < valid_time) trwl += 1;
+
+	valid_time = (boot_config.trc * 1000000) / boot_config.mclk;
+	new_time = (trc * 1000000) / new_mclk;
+	if (new_time < valid_time) trc += 2;
+
+	tras = (tras < 4) ? 4: tras;
+	tras = (tras > 11) ? 11: tras;
+	tras -= 4;
+
+	rcd = (rcd < 1) ? 1: rcd;
+	rcd = (rcd > 4) ? 4: rcd;
+	rcd -= 1;
+
+	tpc = (tpc < 1) ? 1: tpc;
+	tpc = (tpc > 8) ? 8: tpc;
+	tpc -= 1;
+
+	trwl = (trwl < 1) ? 1: trwl;
+	trwl = (trwl > 4) ? 4: trwl;
+	trwl -= 1;
+
+	trc = (trc < 1) ? 1: trc;
+	trc = (trc > 15) ? 15: trc;
+	trc /= 2;
+
+	dmcr = REG_EMC_DMCR;
+
+	dmcr &= ~(EMC_DMCR_TRAS_MASK | EMC_DMCR_RCD_MASK | EMC_DMCR_TPC_MASK | EMC_DMCR_TRWL_MASK | EMC_DMCR_TRC_MASK);
+	dmcr |= ((tras << EMC_DMCR_TRAS_BIT) | (rcd << EMC_DMCR_RCD_BIT) | (tpc << EMC_DMCR_TPC_BIT) | (trwl << EMC_DMCR_TRWL_BIT) | (trc << EMC_DMCR_TRC_BIT));
+
+	REG_EMC_DMCR = dmcr;
+}
+
+static void jz_update_dram_prev(unsigned int cur_mclk, unsigned int new_mclk)
+{
+	/* No risk, no fun: run with interrupts on! */
+	if (new_mclk > cur_mclk) {
+		/* We're going FASTER, so first update TRAS, RCD, TPC, TRWL
+		 * and TRC of DMCR before changing the frequency.
+		 */
+		jz_update_dram_dmcr(new_mclk);
+	} else {
+		/* We're going SLOWER: first update RTCOR value
+		 * before changing the frequency.
+		 */
+		jz_update_dram_rtcor(new_mclk);
+	}
+}
+
+static void jz_update_dram_post(unsigned int cur_mclk, unsigned int new_mclk)
+{
+	/* No risk, no fun: run with interrupts on! */
+	if (new_mclk > cur_mclk) {
+		/* We're going FASTER, so update RTCOR
+		 * after changing the frequency
+		 */
+		jz_update_dram_rtcor(new_mclk);
+	} else {
+		/* We're going SLOWER: so update TRAS, RCD, TPC, TRWL
+		 * and TRC of DMCR after changing the frequency.
+		 */
+		jz_update_dram_dmcr(new_mclk);
+	}
+}
+
+static void jz_scale_divisors(struct dpm_regs *regs)
+{
+	unsigned int cpccr;
+	unsigned int cur_mclk, new_mclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned int tmp = 0, wait = PLL_WAIT_500NS;
+
+	cpccr = REG_CPM_CPCCR;
+	cpccr &= ~((unsigned long)regs->cpccr_mask);
+	cpccr |= regs->cpccr;
+	cpccr |= CPM_CPCCR_CE;       /* update immediately */
+
+	cur_mclk = __cpm_get_mclk();
+	new_mclk = __cpm_get_pllout() / div[(cpccr & CPM_CPCCR_MDIV_MASK) >> CPM_CPCCR_MDIV_BIT];
+
+	/* Update some DRAM parameters before changing frequency */
+	jz_update_dram_prev(cur_mclk, new_mclk);
+
+	/* update register to change the clocks.
+	 * align this code to a cache line.
+	 */
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".align 5\n"
+		"sw %1,0(%0)\n\t"
+		"li %3,0\n\t"
+		"1:\n\t"
+		"bne %3,%2,1b\n\t"
+		"addi %3, 1\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set reorder\n\t"
+		:
+		: "r" (CPM_CPCCR), "r" (cpccr), "r" (wait), "r" (tmp));
+
+	/* Update some other DRAM parameters after changing frequency */
+	jz_update_dram_post(cur_mclk, new_mclk);
+}
+
+#ifdef CHANGE_PLL
+/* Maintain the LCD clock and pixel clock */
+static void jz_scale_lcd_divisors(struct dpm_regs *regs)
+{
+	unsigned int new_pll, new_lcd_div, new_lcdpix_div;
+	unsigned int cpccr;
+	unsigned int tmp = 0, wait = PLL_WAIT_500NS;
+
+	if (!boot_config.lcd_clks_initialized) return;
+
+	new_pll = __cpm_get_pllout();
+	new_lcd_div = new_pll / boot_config.lcd_clk;
+	new_lcdpix_div = new_pll / boot_config.lcdpix_clk;
+
+	if (new_lcd_div < 1)
+		new_lcd_div = 1;
+	if (new_lcd_div > 16)
+		new_lcd_div = 16;
+
+	if (new_lcdpix_div < 1)
+		new_lcdpix_div = 1;
+	if (new_lcdpix_div > 512)
+		new_lcdpix_div = 512;
+
+//	REG_CPM_CPCCR2 = new_lcdpix_div - 1;
+
+	cpccr = REG_CPM_CPCCR;
+	cpccr &= ~CPM_CPCCR_LDIV_MASK;
+	cpccr |= ((new_lcd_div - 1) << CPM_CPCCR_LDIV_BIT);
+	cpccr |= CPM_CPCCR_CE;       /* update immediately */
+
+	/* update register to change the clocks.
+	 * align this code to a cache line.
+	 */
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".align 5\n"
+		"sw %1,0(%0)\n\t"
+		"li %3,0\n\t"
+		"1:\n\t"
+		"bne %3,%2,1b\n\t"
+		"addi %3, 1\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set reorder\n\t"
+		:
+		: "r" (CPM_CPCCR), "r" (cpccr), "r" (wait), "r" (tmp));
+}
+
+static void jz_scale_pll(struct dpm_regs *regs)
+{
+	unsigned int cppcr;
+	unsigned int cur_mclk, new_mclk, new_pll;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	int od[] = {1, 2, 2, 4};
+
+	cppcr = REG_CPM_CPPCR;
+	cppcr &= ~(regs->cppcr_mask | CPM_CPPCR_PLLS | CPM_CPPCR_PLLEN | CPM_CPPCR_PLLST_MASK);
+	regs->cppcr &= ~CPM_CPPCR_PLLEN;
+	cppcr |= (regs->cppcr | 0xff);
+
+	/* Update some DRAM parameters before changing frequency */
+	new_pll = JZ_EXTAL * ((cppcr>>23)+2) / ((((cppcr>>18)&0x1f)+2) * od[(cppcr>>16)&0x03]);
+	cur_mclk = __cpm_get_mclk();
+	new_mclk = new_pll / div[(REG_CPM_CPCCR>>CPM_CPCCR_MDIV_BIT) & 0xf];
+
+	/*
+	 * Update some SDRAM parameters
+	 */
+	jz_update_dram_prev(cur_mclk, new_mclk);
+
+	/*
+	 * Update PLL, align code to cache line.
+	 */
+	cppcr |= CPM_CPPCR_PLLEN;
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".align 5\n"
+		"sw %1,0(%0)\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set reorder\n\t"
+		:
+		: "r" (CPM_CPPCR), "r" (cppcr));
+
+	/* Update some other DRAM parameters after changing frequency */
+	jz_update_dram_post(cur_mclk, new_mclk);
+}
+#endif
+
+static void jz4740_transition(struct dpm_regs *regs)
+{
+	/*
+	 * Get and save some boot-time conditions.
+	 */
+	jz_init_boot_config();
+
+#ifdef CHANGE_PLL
+	/*
+	 * Disable LCD before scaling pll.
+	 * LCD and LCD pixel clocks should not be changed even if the PLL
+	 * output frequency has been changed.
+	 */
+	REG_LCD_CTRL &= ~LCD_CTRL_ENA;
+
+	/*
+	 * Stop module clocks before scaling PLL
+	 */
+	__cpm_stop_eth();
+	__cpm_stop_aic(1);
+	__cpm_stop_aic(2);
+#endif
+
+	/* ... add more as necessary */
+
+	if (regs->pll_up_flag == PLL_GOES_UP) {
+		/* the pll frequency is going up, so change dividors first */
+		jz_scale_divisors(regs);
+#ifdef CHANGE_PLL
+		jz_scale_pll(regs);
+#endif
+	}
+	else if (regs->pll_up_flag == PLL_GOES_DOWN) {
+		/* the pll frequency is going down, so change pll first */
+#ifdef CHANGE_PLL
+		jz_scale_pll(regs);
+#endif
+		jz_scale_divisors(regs);
+	}
+	else {
+		/* the pll frequency is unchanged, so change divisors only */
+		jz_scale_divisors(regs);
+	}
+
+#ifdef CHANGE_PLL
+	/*
+	 * Restart module clocks before scaling PLL
+	 */
+	__cpm_start_eth();
+	__cpm_start_aic(1);
+	__cpm_start_aic(2);
+
+	/* ... add more as necessary */
+
+	/* Scale the LCD divisors after scaling pll */
+	if (regs->pll_up_flag != PLL_UNCHANGED) {
+		jz_scale_lcd_divisors(regs);
+	}
+
+	/* Enable LCD controller */
+	REG_LCD_CTRL &= ~LCD_CTRL_DIS;
+	REG_LCD_CTRL |= LCD_CTRL_ENA;
+#endif
+
+	/* Update system clocks */
+	jz_update_clocks();
+}
+
+extern unsigned int idle_times;
+static unsigned int jz4740_freq_get(unsigned int cpu)
+{
+	return  (__cpm_get_cclk() / 1000);
+}
+
+static unsigned int index_to_divisor(unsigned int index, struct dpm_regs *regs)
+{
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[4] = {1, 2, 2, 2}; /* divisors of I:S:P:M */
+	unsigned int div_of_cclk, new_freq, i;
+
+	regs->pll_up_flag = PLL_UNCHANGED;
+	regs->cpccr_mask = CPM_CPCCR_CDIV_MASK | CPM_CPCCR_HDIV_MASK | CPM_CPCCR_PDIV_MASK | CPM_CPCCR_MDIV_MASK;
+
+	new_freq = jz4740_freq_table.table[index].frequency;
+
+	do {
+		div_of_cclk = __cpm_get_pllout() / (1000 * new_freq);
+	} while (div_of_cclk==0);
+
+	if(div_of_cclk == 1 || div_of_cclk == 2 || div_of_cclk == 4) {
+		for(i = 1; i<4; i++) {
+			div[i] = 3;
+		}
+	} else {
+		for(i = 1; i<4; i++) {
+			div[i] = 2;
+		}
+	}
+
+	for(i = 0; i<4; i++) {
+		div[i] *= div_of_cclk;
+	}
+
+	dprintk("divisors of I:S:P:M = %d:%d:%d:%d\n", div[0], div[1], div[2], div[3]);
+
+	regs->cpccr =
+		(n2FR[div[0]] << CPM_CPCCR_CDIV_BIT) |
+		(n2FR[div[1]] << CPM_CPCCR_HDIV_BIT) |
+		(n2FR[div[2]] << CPM_CPCCR_PDIV_BIT) |
+		(n2FR[div[3]] << CPM_CPCCR_MDIV_BIT);
+
+	return  div_of_cclk;
+}
+
+static void jz4740_set_cpu_divider_index(unsigned int cpu, unsigned int index)
+{
+	unsigned long divisor, old_divisor;
+	struct cpufreq_freqs freqs;
+	struct dpm_regs regs;
+
+	old_divisor = __cpm_get_pllout() /  __cpm_get_cclk();
+	divisor = index_to_divisor(index, &regs);
+
+	freqs.old = __cpm_get_cclk() / 1000;
+	freqs.new =  __cpm_get_pllout() / (1000 * divisor);
+	freqs.cpu = cpu;
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+	if (old_divisor != divisor)
+		jz4740_transition(&regs);
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+}
+
+static int jz4740_freq_target(struct cpufreq_policy *policy,
+			  unsigned int target_freq,
+			  unsigned int relation)
+{
+	unsigned int new_index = 0;
+
+	if (cpufreq_frequency_table_target(policy,
+					   &jz4740_freq_table.table[0],
+					   target_freq, relation, &new_index))
+		return -EINVAL;
+
+	jz4740_set_cpu_divider_index(policy->cpu, new_index);
+
+	dprintk("new frequency is %d KHz (REG_CPM_CPCCR:0x%x)\n", __cpm_get_cclk() / 1000, REG_CPM_CPCCR);
+
+	return 0;
+}
+
+static int jz4740_freq_verify(struct cpufreq_policy *policy)
+{
+	return cpufreq_frequency_table_verify(policy,
+					      &jz4740_freq_table.table[0]);
+}
+
+static int __init jz4740_cpufreq_driver_init(struct cpufreq_policy *policy)
+{
+
+	struct cpufreq_frequency_table *table =	&jz4740_freq_table.table[0];
+	unsigned int MAX_FREQ;
+
+	dprintk(KERN_INFO "Jz4740 cpufreq driver\n");
+
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	policy->cur = MAX_FREQ = __cpm_get_cclk() / 1000; /* in kHz. Current and max frequency is determined by u-boot */
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+
+	policy->cpuinfo.min_freq = MAX_FREQ/8;
+	policy->cpuinfo.max_freq = MAX_FREQ;
+	policy->cpuinfo.transition_latency = 100000; /* in 10^(-9) s = nanoseconds */
+
+	table[0].index = 0;
+	table[0].frequency = MAX_FREQ/8;
+	table[1].index = 1;
+	table[1].frequency = MAX_FREQ/6;
+	table[2].index = 2;
+	table[2].frequency = MAX_FREQ/4;
+	table[3].index = 3;
+	table[3].frequency = MAX_FREQ/3;
+	table[4].index = 4;
+	table[4].frequency = MAX_FREQ/2;
+	table[5].index = 5;
+	table[5].frequency = MAX_FREQ;
+	table[6].index = 6;
+	table[6].frequency = CPUFREQ_TABLE_END;
+
+#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
+	cpufreq_frequency_table_get_attr(table, policy->cpu); /* for showing /sys/devices/system/cpu/cpuX/cpufreq/stats/ */
+#endif
+
+	return  cpufreq_frequency_table_cpuinfo(policy, table);
+}
+
+static struct cpufreq_driver cpufreq_jz4740_driver = {
+//	.flags		= CPUFREQ_STICKY,
+	.init		= jz4740_cpufreq_driver_init,
+	.verify		= jz4740_freq_verify,
+	.target		= jz4740_freq_target,
+	.get		= jz4740_freq_get,
+	.name		= "jz4740",
+};
+
+static int __init jz4740_cpufreq_init(void)
+{
+	return cpufreq_register_driver(&cpufreq_jz4740_driver);
+}
+
+static void __exit jz4740_cpufreq_exit(void)
+{
+		cpufreq_unregister_driver(&cpufreq_jz4740_driver);
+}
+
+module_init(jz4740_cpufreq_init);
+module_exit(jz4740_cpufreq_exit);
+
+MODULE_AUTHOR("Regen <lhhuang@ingenic.cn>");
+MODULE_DESCRIPTION("cpufreq driver for Jz4740");
+MODULE_LICENSE("GPL");
+
--- linux-2.6.24.7.old/arch/mips/jz4740/dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/dma.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,768 @@
+/*
+ * linux/arch/mips/jz4740/dma.c
+ *
+ * Support functions for the JZ4740 internal DMA channels.
+ * No-descriptor transfer only.
+ * Descriptor transfer should also call jz_request_dma() to get a free
+ * channel and call jz_free_dma() to free the channel. And driver should
+ * build the DMA descriptor and setup the DMA channel by itself.
+ *
+ * Copyright (C) 2006 Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/soundcard.h>
+
+#include <asm/system.h>
+#include <asm/addrspace.h>
+#include <asm/jzsoc.h>
+
+/*
+ * A note on resource allocation:
+ *
+ * All drivers needing DMA channels, should allocate and release them
+ * through the public routines `jz_request_dma()' and `jz_free_dma()'.
+ *
+ * In order to avoid problems, all processes should allocate resources in
+ * the same sequence and release them in the reverse order.
+ *
+ * So, when allocating DMAs and IRQs, first allocate the DMA, then the IRQ.
+ * When releasing them, first release the IRQ, then release the DMA. The
+ * main reason for this order is that, if you are requesting the DMA buffer
+ * done interrupt, you won't know the irq number until the DMA channel is
+ * returned from jz_request_dma().
+ */
+
+struct jz_dma_chan jz_dma_table[MAX_DMA_NUM] = {
+	{dev_id:-1,},
+	{dev_id:-1,},
+	{dev_id:-1,},
+	{dev_id:-1,},
+	{dev_id:-1,},
+	{dev_id:-1,},
+};
+
+// Device FIFO addresses and default DMA modes
+static const struct {
+	unsigned int fifo_addr;
+	unsigned int dma_mode;
+	unsigned int dma_source;
+} dma_dev_table[DMA_ID_MAX] = {
+	{CPHYSADDR(UART0_TDR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_UART0OUT},
+	{CPHYSADDR(UART0_RDR), DMA_8BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_UART0IN},
+	{CPHYSADDR(SSI_DR), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_SSIOUT},
+	{CPHYSADDR(SSI_DR), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_SSIIN},
+	{CPHYSADDR(AIC_DR), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_AICOUT},
+	{CPHYSADDR(AIC_DR), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_AICIN},
+	{CPHYSADDR(MSC_TXFIFO), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_MSCOUT},
+	{CPHYSADDR(MSC_RXFIFO), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_MSCIN},
+	{0, DMA_AUTOINIT, DMAC_DRSR_RS_TCU},
+	{0, DMA_AUTOINIT, DMAC_DRSR_RS_AUTO},
+	{},
+};
+
+
+int jz_dma_read_proc(char *buf, char **start, off_t fpos,
+			 int length, int *eof, void *data)
+{
+	int i, len = 0;
+	struct jz_dma_chan *chan;
+
+	for (i = 0; i < MAX_DMA_NUM; i++) {
+		if ((chan = get_dma_chan(i)) != NULL) {
+			len += sprintf(buf + len, "%2d: %s\n",
+				       i, chan->dev_str);
+		}
+	}
+
+	if (fpos >= len) {
+		*start = buf;
+		*eof = 1;
+		return 0;
+	}
+	*start = buf + fpos;
+	if ((len -= fpos) > length)
+		return length;
+	*eof = 1;
+	return len;
+}
+
+
+void dump_jz_dma_channel(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan;
+
+	if (dmanr > MAX_DMA_NUM)
+		return;
+	chan = &jz_dma_table[dmanr];
+
+	printk("DMA%d Registers:\n", dmanr);
+	printk("  DMACR  = 0x%08x\n", REG_DMAC_DMACR);
+	printk("  DSAR   = 0x%08x\n", REG_DMAC_DSAR(dmanr));
+	printk("  DTAR   = 0x%08x\n", REG_DMAC_DTAR(dmanr));
+	printk("  DTCR   = 0x%08x\n", REG_DMAC_DTCR(dmanr));
+	printk("  DRSR   = 0x%08x\n", REG_DMAC_DRSR(dmanr));
+	printk("  DCCSR  = 0x%08x\n", REG_DMAC_DCCSR(dmanr));
+	printk("  DCMD  = 0x%08x\n", REG_DMAC_DCMD(dmanr));
+	printk("  DDA  = 0x%08x\n", REG_DMAC_DDA(dmanr));
+	printk("  DMADBR = 0x%08x\n", REG_DMAC_DMADBR);
+}
+
+
+/**
+ * jz_request_dma - dynamically allcate an idle DMA channel to return
+ * @dev_id: the specified dma device id or DMA_ID_RAW_SET
+ * @dev_str: the specified dma device string name
+ * @irqhandler: the irq handler, or NULL
+ * @irqflags: the irq handler flags
+ * @irq_dev_id: the irq handler device id for shared irq
+ *
+ * Finds a free channel, and binds the requested device to it.
+ * Returns the allocated channel number, or negative on error.
+ * Requests the DMA done IRQ if irqhandler != NULL.
+ *
+*/
+/*int jz_request_dma(int dev_id, const char *dev_str,
+		   void (*irqhandler)(int, void *, struct pt_regs *),
+		   unsigned long irqflags,
+		   void *irq_dev_id)
+*/
+
+int jz_request_dma(int dev_id, const char *dev_str,
+		   irqreturn_t (*irqhandler)(int, void *),
+		   unsigned long irqflags,
+		   void *irq_dev_id)
+{
+	struct jz_dma_chan *chan;
+	int i, ret;
+
+	if (dev_id < 0 || dev_id >= DMA_ID_MAX)
+		return -EINVAL;
+
+	for (i = 0; i < MAX_DMA_NUM; i++) {
+		if (jz_dma_table[i].dev_id < 0)
+			break;
+	}
+	if (i == MAX_DMA_NUM)  /* no free channel */
+		return -ENODEV;
+
+	/* we got a free channel */
+	chan = &jz_dma_table[i];
+
+	if (irqhandler) {
+		chan->irq = IRQ_DMA_0 + i;	// allocate irq number
+		chan->irq_dev = irq_dev_id;
+		if ((ret = request_irq(chan->irq, irqhandler, irqflags,
+				       dev_str, chan->irq_dev))) {
+			chan->irq = -1;
+			chan->irq_dev = NULL;
+			return ret;
+		}
+	} else {
+		chan->irq = -1;
+		chan->irq_dev = NULL;
+	}
+
+	// fill it in
+	chan->io = i;
+	chan->dev_id = dev_id;
+	chan->dev_str = dev_str;
+	chan->fifo_addr = dma_dev_table[dev_id].fifo_addr;
+	chan->mode = dma_dev_table[dev_id].dma_mode;
+	chan->source = dma_dev_table[dev_id].dma_source;
+
+	return i;
+}
+
+void jz_free_dma(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan) {
+		printk("Trying to free DMA%d\n", dmanr);
+		return;
+	}
+
+	disable_dma(dmanr);
+	if (chan->irq)
+		free_irq(chan->irq, chan->irq_dev);
+
+	chan->irq = -1;
+	chan->irq_dev = NULL;
+	chan->dev_id = -1;
+}
+
+void jz_set_dma_dest_width(int dmanr, int nbit)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+	       	return;
+
+	chan->mode &= ~DMAC_DCMD_DWDH_MASK;
+	switch (nbit) {
+	case 8:
+		chan->mode |= DMAC_DCMD_DWDH_8;
+		break;
+	case 16:
+		chan->mode |= DMAC_DCMD_DWDH_16;
+		break;
+	case 32:
+		chan->mode |= DMAC_DCMD_DWDH_32;
+		break;
+	}
+}
+
+void jz_set_dma_src_width(int dmanr, int nbit)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+	       	return;
+
+	chan->mode &= ~DMAC_DCMD_SWDH_MASK;
+	switch (nbit) {
+	case 8:
+		chan->mode |= DMAC_DCMD_SWDH_8;
+		break;
+	case 16:
+		chan->mode |= DMAC_DCMD_SWDH_16;
+		break;
+	case 32:
+		chan->mode |= DMAC_DCMD_SWDH_32;
+		break;
+	}
+}
+
+void jz_set_dma_block_size(int dmanr, int nbyte)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	chan->mode &= ~DMAC_DCMD_DS_MASK;
+	switch (nbyte) {
+	case 1:
+		chan->mode |= DMAC_DCMD_DS_8BIT;
+		break;
+	case 2:
+		chan->mode |= DMAC_DCMD_DS_16BIT;
+		break;
+	case 4:
+		chan->mode |= DMAC_DCMD_DS_32BIT;
+		break;
+	case 16:
+		chan->mode |= DMAC_DCMD_DS_16BYTE;
+		break;
+	case 32:
+		chan->mode |= DMAC_DCMD_DS_32BYTE;
+		break;
+	}
+}
+
+unsigned int jz_get_dma_command(int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	return chan->mode;
+}
+
+/**
+ * jz_set_dma_mode - do the raw settings for the specified DMA channel
+ * @dmanr: the specified DMA channel
+ * @mode: dma operate mode, DMA_MODE_READ or DMA_MODE_WRITE
+ * @dma_mode: dma raw mode
+ * @dma_source: dma raw request source
+ * @fifo_addr: dma raw device fifo address
+ *
+ * Ensure call jz_request_dma(DMA_ID_RAW_SET, ...) first, then call
+ * jz_set_dma_mode() rather than set_dma_mode() if you work with
+ * and external request dma device.
+ *
+ * NOTE: Don not dynamically allocate dma channel if one external request
+ *       dma device will occupy this channel.
+*/
+int jz_set_dma_mode(unsigned int dmanr, unsigned int mode,
+		    unsigned int dma_mode, unsigned int dma_source,
+		    unsigned int fifo_addr)
+{
+	int dev_id, i;
+	struct jz_dma_chan *chan;
+
+	if (dmanr > MAX_DMA_NUM)
+		return -ENODEV;
+	for (i = 0; i < MAX_DMA_NUM; i++) {
+		if (jz_dma_table[i].dev_id < 0)
+			break;
+	}
+	if (i == MAX_DMA_NUM)
+		return -ENODEV;
+
+	chan = &jz_dma_table[dmanr];
+	dev_id = chan->dev_id;
+	if (dev_id > 0) {
+		printk(KERN_DEBUG "%s sets the allocated DMA channel %d!\n",
+		       __FUNCTION__, dmanr);
+		return -ENODEV;
+	}
+
+	/* clone it from the dynamically allocated. */
+	if (i != dmanr) {
+		chan->irq = jz_dma_table[i].irq;
+		chan->irq_dev = jz_dma_table[i].irq_dev;
+		chan->dev_str = jz_dma_table[i].dev_str;
+		jz_dma_table[i].irq = 0;
+		jz_dma_table[i].irq_dev = NULL;
+		jz_dma_table[i].dev_id = -1;
+	}
+	chan->dev_id = DMA_ID_RAW_SET;
+	chan->io = dmanr;
+	chan->fifo_addr = fifo_addr;
+	chan->mode = dma_mode;
+	chan->source = dma_source;
+
+	set_dma_mode(dmanr, dma_mode);
+
+	return dmanr;
+}
+
+void enable_dma(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	REG_DMAC_DCCSR(dmanr) &= ~(DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR);
+	REG_DMAC_DCCSR(dmanr) |= DMAC_DCCSR_NDES; /* No-descriptor transfer */
+	__dmac_enable_channel(dmanr);
+	if (chan->irq)
+		__dmac_channel_enable_irq(dmanr);
+}
+
+#define DMA_DISABLE_POLL 0x10000
+
+void disable_dma(unsigned int dmanr)
+{
+	int i;
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	if (!__dmac_channel_enabled(dmanr))
+		return;
+
+	for (i = 0; i < DMA_DISABLE_POLL; i++)
+		if (__dmac_channel_transmit_end_detected(dmanr))
+			break;
+#if 0
+	if (i == DMA_DISABLE_POLL)
+		printk(KERN_INFO "disable_dma: poll expired!\n");
+#endif
+
+	__dmac_disable_channel(dmanr);
+	if (chan->irq)
+		__dmac_channel_disable_irq(dmanr);
+}
+
+/* Note: DMA_MODE_MASK is simulated by sw */
+void set_dma_mode(unsigned int dmanr, unsigned int mode)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+	mode &= DMA_MODE_MASK;
+	if (mode == DMA_MODE_READ) {
+		chan->mode |= DMAC_DCMD_DAI;
+		chan->mode &= ~DMAC_DCMD_SAI;
+	} else if (mode == DMA_MODE_WRITE) {
+		chan->mode |= DMAC_DCMD_SAI;
+		chan->mode &= ~DMAC_DCMD_DAI;
+	} else {
+		printk(KERN_DEBUG "set_dma_mode() just supports DMA_MODE_READ or DMA_MODE_WRITE!\n");
+	}
+	REG_DMAC_DCMD(chan->io) = chan->mode & ~DMA_MODE_MASK;
+	REG_DMAC_DRSR(chan->io) = chan->source;
+}
+
+void set_dma_addr(unsigned int dmanr, unsigned int phyaddr)
+{
+	unsigned int mode;
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	mode = chan->mode & DMA_MODE_MASK;
+	if (mode == DMA_MODE_READ) {
+		REG_DMAC_DSAR(chan->io) = chan->fifo_addr;
+		REG_DMAC_DTAR(chan->io) = phyaddr;
+	} else if (mode == DMA_MODE_WRITE) {
+		REG_DMAC_DSAR(chan->io) = phyaddr;
+		REG_DMAC_DTAR(chan->io) = chan->fifo_addr;
+	} else
+		printk(KERN_DEBUG "Driver should call set_dma_mode() ahead set_dma_addr()!\n");
+}
+
+void set_dma_count(unsigned int dmanr, unsigned int bytecnt)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	int dma_ds[] = {4, 1, 2, 16, 32};
+	unsigned int ds;
+
+	if (!chan)
+	       	return;
+
+       	ds = (chan->mode & DMAC_DCMD_DS_MASK) >> DMAC_DCMD_DS_BIT;
+	REG_DMAC_DTCR(chan->io) = bytecnt / dma_ds[ds]; // transfer count
+}
+
+unsigned int get_dma_residue(unsigned int dmanr)
+{
+	unsigned int count, ds;
+	int dma_ds[] = {4, 1, 2, 16, 32};
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 0;
+
+	ds = (chan->mode & DMAC_DCMD_DS_MASK) >> DMAC_DCMD_DS_BIT;
+	count = REG_DMAC_DTCR(chan->io);
+	count = count * dma_ds[ds];
+
+	return count;
+}
+
+void jz_set_oss_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	switch (audio_fmt) {
+	case AFMT_U8:
+		/* burst mode : 32BIT */
+		break;
+	case AFMT_S16_LE:
+		/* burst mode : 16BYTE */
+		if (mode == DMA_MODE_READ) {
+			chan->mode = DMA_AIC_32_16BYTE_RX_CMD | DMA_MODE_READ;
+			chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCMD_DAI;
+			chan->mode &= ~DMAC_DCMD_SAI;
+		} else if (mode == DMA_MODE_WRITE) {
+			chan->mode = DMA_AIC_32_16BYTE_TX_CMD | DMA_MODE_WRITE;
+			chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCMD_SAI;
+			chan->mode &= ~DMAC_DCMD_DAI;
+		} else
+			printk("oss_dma_burst_mode() just supports DMA_MODE_READ or DMA_MODE_WRITE!\n");
+
+		REG_DMAC_DCMD(chan->io) = chan->mode & ~DMA_MODE_MASK;
+		REG_DMAC_DRSR(chan->io) = chan->source;
+		break;
+	}
+}
+
+void jz_set_alsa_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	switch (audio_fmt) {
+	case 8:
+		/* SNDRV_PCM_FORMAT_S8 burst mode : 32BIT */
+		break;
+	case 16:
+		/* SNDRV_PCM_FORMAT_S16_LE burst mode : 16BYTE */
+		if (mode == DMA_MODE_READ) {
+			chan->mode = DMA_AIC_16BYTE_RX_CMD | DMA_MODE_READ;
+			chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCMD_DAI;
+			chan->mode &= ~DMAC_DCMD_SAI;
+		} else if (mode == DMA_MODE_WRITE) {
+			chan->mode = DMA_AIC_16BYTE_TX_CMD | DMA_MODE_WRITE;
+			chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCMD_SAI;
+			chan->mode &= ~DMAC_DCMD_DAI;
+		} else
+			printk("alsa_dma_burst_mode() just supports DMA_MODE_READ or DMA_MODE_WRITE!\n");
+
+		REG_DMAC_DCMD(chan->io) = chan->mode & ~DMA_MODE_MASK;
+		REG_DMAC_DRSR(chan->io) = chan->source;
+		break;
+	}
+}
+
+#undef JZ4740_DMAC_TEST_ENABLE
+
+#ifdef JZ4740_DMAC_TEST_ENABLE
+
+/*
+ * DMA test: external address <--> external address
+ */
+#define TEST_DMA_SIZE  16*1024
+
+static jz_dma_desc *dma_desc;
+
+static int dma_chan;
+static dma_addr_t dma_desc_phys_addr;
+static unsigned int dma_src_addr, dma_src_phys_addr, dma_dst_addr, dma_dst_phys_addr;
+
+static int dma_check_result(void *src, void *dst, int size)
+{
+	unsigned int addr1, addr2, i, err = 0;
+
+	addr1 = (unsigned int)src;
+	addr2 = (unsigned int)dst;
+
+	for (i = 0; i < size; i += 4) {
+		if (*(volatile unsigned int *)addr1 != *(volatile unsigned int *)addr2) {
+			err++;
+			printk("wrong data at 0x%08x: src 0x%08x  dst 0x%08x\n", addr2, *(volatile unsigned int *)addr1, *(volatile unsigned int *)addr2);
+		}
+		addr1 += 4;
+		addr2 += 4;
+	}
+	printk("check DMA result err=%d\n", err);
+	return err;
+}
+
+static void jz4740_dma_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	printk("jz4740_dma_irq %d\n", irq);
+
+	REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+
+	if (__dmac_channel_transmit_halt_detected(dma_chan)) {
+		printk("DMA HALT\n");
+		__dmac_channel_clear_transmit_halt(dma_chan);
+	}
+
+	if (__dmac_channel_address_error_detected(dma_chan)) {
+		printk("DMA ADDR ERROR\n");
+		__dmac_channel_clear_address_error(dma_chan);
+	}
+
+	if (__dmac_channel_descriptor_invalid_detected(dma_chan)) {
+		printk("DMA DESC INVALID\n");
+		__dmac_channel_clear_descriptor_invalid(dma_chan);
+	}
+
+	if (__dmac_channel_count_terminated_detected(dma_chan)) {
+		printk("DMA CT\n");
+		__dmac_channel_clear_count_terminated(dma_chan);
+	}
+
+	if (__dmac_channel_transmit_end_detected(dma_chan)) {
+		printk("DMA TT\n");
+		__dmac_channel_clear_transmit_end(dma_chan);
+		dump_jz_dma_channel(dma_chan);
+		dma_check_result((void *)dma_src_addr, (void *)dma_dst_addr, TEST_DMA_SIZE);
+	}
+
+	/* free buffers */
+	printk("free DMA buffers\n");
+	free_pages(dma_src_addr, 2);
+	free_pages(dma_dst_addr, 2);
+
+	if (dma_desc)
+		free_pages((unsigned int)dma_desc, 0);
+
+	/* free dma */
+	jz_free_dma(dma_chan);
+}
+
+void dma_nodesc_test(void)
+{
+	unsigned int addr, i;
+
+	printk("dma_nodesc_test\n");
+
+	/* Request DMA channel and setup irq handler */
+	dma_chan = jz_request_dma(DMA_ID_AUTO, "auto", jz4740_dma_irq,
+				   SA_INTERRUPT, NULL);
+	if (dma_chan < 0) {
+		printk("Setup irq failed\n");
+		return;
+	}
+
+	printk("Requested DMA channel = %d\n", dma_chan);
+
+	/* Allocate DMA buffers */
+	dma_src_addr = __get_free_pages(GFP_KERNEL, 2); /* 16KB */
+	dma_dst_addr = __get_free_pages(GFP_KERNEL, 2); /* 16KB */
+
+	dma_src_phys_addr = CPHYSADDR(dma_src_addr);
+	dma_dst_phys_addr = CPHYSADDR(dma_dst_addr);
+
+	printk("Buffer addresses: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+	       dma_src_addr, dma_src_phys_addr, dma_dst_addr, dma_dst_phys_addr);
+
+	/* Prepare data for source buffer */
+	addr = (unsigned int)dma_src_addr;
+	for (i = 0; i < TEST_DMA_SIZE; i += 4) {
+		*(volatile unsigned int *)addr = addr;
+		addr += 4;
+	}
+	dma_cache_wback((unsigned long)dma_src_addr, TEST_DMA_SIZE);
+
+	/* Init target buffer */
+	memset((void *)dma_dst_addr, 0, TEST_DMA_SIZE);
+	dma_cache_wback((unsigned long)dma_dst_addr, TEST_DMA_SIZE);
+
+	/* Init DMA module */
+	printk("Starting DMA\n");
+	REG_DMAC_DMACR = 0;
+	REG_DMAC_DCCSR(dma_chan) = 0;
+	REG_DMAC_DRSR(dma_chan) = DMAC_DRSR_RS_AUTO;
+	REG_DMAC_DSAR(dma_chan) = dma_src_phys_addr;
+	REG_DMAC_DTAR(dma_chan) = dma_dst_phys_addr;
+	REG_DMAC_DTCR(dma_chan) = 512;
+	REG_DMAC_DCMD(dma_chan) = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_32BYTE | DMAC_DCMD_TIE;
+	REG_DMAC_DCCSR(dma_chan) = DMAC_DCCSR_NDES | DMAC_DCCSR_EN;
+	REG_DMAC_DMACR = DMAC_DMACR_DMAE; /* global DMA enable bit */
+
+	printk("DMA started. IMR=%08x\n", REG_INTC_IMR);
+}
+
+void dma_desc_test(void)
+{
+	unsigned int next, addr, i;
+	static jz_dma_desc *desc;
+
+	printk("dma_desc_test\n");
+
+	/* Request DMA channel and setup irq handler */
+	dma_chan = jz_request_dma(DMA_ID_AUTO, "auto", jz4740_dma_irq,
+				  SA_INTERRUPT, NULL);
+	if (dma_chan < 0) {
+		printk("Setup irq failed\n");
+		return;
+	}
+
+	printk("Requested DMA channel = %d\n", dma_chan);
+
+	/* Allocate DMA buffers */
+	dma_src_addr = __get_free_pages(GFP_KERNEL, 2); /* 16KB */
+	dma_dst_addr = __get_free_pages(GFP_KERNEL, 2); /* 16KB */
+
+	dma_src_phys_addr = CPHYSADDR(dma_src_addr);
+	dma_dst_phys_addr = CPHYSADDR(dma_dst_addr);
+
+	printk("Buffer addresses: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+	       dma_src_addr, dma_src_phys_addr, dma_dst_addr, dma_dst_phys_addr);
+
+	/* Prepare data for source buffer */
+	addr = (unsigned int)dma_src_addr;
+	for (i = 0; i < TEST_DMA_SIZE; i += 4) {
+		*(volatile unsigned int *)addr = addr;
+		addr += 4;
+	}
+	dma_cache_wback((unsigned long)dma_src_addr, TEST_DMA_SIZE);
+
+	/* Init target buffer */
+	memset((void *)dma_dst_addr, 0, TEST_DMA_SIZE);
+	dma_cache_wback((unsigned long)dma_dst_addr, TEST_DMA_SIZE);
+
+	/* Allocate DMA descriptors */
+	dma_desc = (jz_dma_desc *)__get_free_pages(GFP_KERNEL, 0);
+	dma_desc_phys_addr = CPHYSADDR((unsigned long)dma_desc);
+
+	printk("DMA descriptor address: 0x%08x  0x%08x\n", (u32)dma_desc, dma_desc_phys_addr);
+
+	/* Setup DMA descriptors */
+	desc = dma_desc;
+	next = (dma_desc_phys_addr + (sizeof(jz_dma_desc))) >> 4;
+
+	desc->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_32BYTE | DMAC_DCMD_TM | DMAC_DCMD_DES_V | DMAC_DCMD_DES_VM | DMAC_DCMD_DES_VIE | DMAC_DCMD_TIE | DMAC_DCMD_LINK;
+	desc->dsadr = dma_src_phys_addr;    /* DMA source address */
+	desc->dtadr = dma_dst_phys_addr;    /* DMA target address */
+	desc->ddadr = (next << 24) + 128;    /* size: 128*32 bytes = 4096 bytes */
+
+	desc++;
+	next = (dma_desc_phys_addr + 2*(sizeof(jz_dma_desc))) >> 4;
+
+	desc->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_16BYTE | DMAC_DCMD_DES_V | DMAC_DCMD_DES_VM | DMAC_DCMD_DES_VIE | DMAC_DCMD_TIE | DMAC_DCMD_LINK;
+	desc->dsadr = dma_src_phys_addr + 4096;	/* DMA source address */
+	desc->dtadr = dma_dst_phys_addr + 4096;	/* DMA target address */
+	desc->ddadr = (next << 24) + 256;    /* size: 256*16 bytes = 4096 bytes */
+
+	desc++;
+	next = (dma_desc_phys_addr + 3*(sizeof(jz_dma_desc))) >> 4;
+
+	desc->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_16BYTE | DMAC_DCMD_DES_V | DMAC_DCMD_DES_VM | DMAC_DCMD_DES_VIE | DMAC_DCMD_TIE | DMAC_DCMD_LINK;
+	desc->dsadr = dma_src_phys_addr + 8192;	/* DMA source address */
+	desc->dtadr = dma_dst_phys_addr + 8192;	/* DMA target address */
+	desc->ddadr = (next << 24) + 256;    /* size: 256*16 bytes = 4096 bytes */
+
+	desc++;
+	next = (dma_desc_phys_addr + 4*(sizeof(jz_dma_desc))) >> 4;
+
+	desc->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_32BIT | DMAC_DCMD_DES_V | DMAC_DCMD_DES_VM | DMAC_DCMD_DES_VIE | DMAC_DCMD_TIE;
+	desc->dsadr = dma_src_phys_addr + 12*1024;	/* DMA source address */
+	desc->dtadr = dma_dst_phys_addr + 12*1024;	/* DMA target address */
+	desc->ddadr = (next << 24) + 1024;    /* size: 1024*4 bytes = 4096 bytes */
+
+	dma_cache_wback((unsigned long)dma_desc, 4*(sizeof(jz_dma_desc)));
+
+	/* Setup DMA descriptor address */
+	REG_DMAC_DDA(dma_chan) = dma_desc_phys_addr;
+
+	/* Setup request source */
+	REG_DMAC_DRSR(dma_chan) = DMAC_DRSR_RS_AUTO;
+
+	/* Setup DMA channel control/status register */
+	REG_DMAC_DCCSR(dma_chan) = DMAC_DCCSR_EN;	/* descriptor transfer, clear status, start channel */
+
+	/* Enable DMA */
+	REG_DMAC_DMACR = DMAC_DMACR_DMAE;
+
+	/* DMA doorbell set -- start DMA now ... */
+	REG_DMAC_DMADBSR = 1 << dma_chan;
+
+	printk("DMA started. IMR=%08x\n", REG_INTC_IMR);
+}
+
+#endif
+
+//EXPORT_SYMBOL_NOVERS(jz_dma_table);
+EXPORT_SYMBOL(jz_dma_table);
+EXPORT_SYMBOL(jz_request_dma);
+EXPORT_SYMBOL(jz_free_dma);
+EXPORT_SYMBOL(jz_set_dma_src_width);
+EXPORT_SYMBOL(jz_set_dma_dest_width);
+EXPORT_SYMBOL(jz_set_dma_block_size);
+EXPORT_SYMBOL(jz_set_dma_mode);
+EXPORT_SYMBOL(set_dma_mode);
+EXPORT_SYMBOL(jz_set_oss_dma);
+EXPORT_SYMBOL(jz_set_alsa_dma);
+EXPORT_SYMBOL(set_dma_addr);
+EXPORT_SYMBOL(set_dma_count);
+EXPORT_SYMBOL(get_dma_residue);
+EXPORT_SYMBOL(enable_dma);
+EXPORT_SYMBOL(disable_dma);
+EXPORT_SYMBOL(dump_jz_dma_channel);
--- linux-2.6.24.7.old/arch/mips/jz4740/i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/i2c.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,273 @@
+/*
+ * linux/arch/mips/jz4740/i2c.c
+ *
+ * Jz4740 I2C routines.
+ *
+ * Copyright (C) 2005,2006 Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <asm/addrspace.h>
+
+#include <asm/jzsoc.h>
+
+/* I2C protocol */
+#define I2C_READ	1
+#define I2C_WRITE	0
+
+#define TIMEOUT         1000
+
+/*
+ * I2C bus protocol basic routines
+ */
+static int i2c_put_data(unsigned char data)
+{
+	unsigned int timeout = TIMEOUT*10;
+
+	__i2c_write(data);
+	__i2c_set_drf();
+	while (__i2c_check_drf() != 0);
+	while (!__i2c_transmit_ended());
+	while (!__i2c_received_ack() && timeout)
+		timeout--;
+
+	if (timeout)
+		return 0;
+	else
+		return -ETIMEDOUT;
+}
+
+#ifdef CONFIG_JZ_TPANEL_ATA2508
+static int i2c_put_data_nack(unsigned char data)
+{
+	unsigned int timeout = TIMEOUT*10;
+
+	__i2c_write(data);
+	__i2c_set_drf();
+	while (__i2c_check_drf() != 0);
+	while (!__i2c_transmit_ended());
+	while (timeout--);
+		return 0;
+}
+#endif
+
+static int i2c_get_data(unsigned char *data, int ack)
+{
+	int timeout = TIMEOUT*10;
+
+	if (!ack)
+		__i2c_send_nack();
+	else
+		__i2c_send_ack();
+
+	while (__i2c_check_drf() == 0 && timeout)
+		timeout--;
+
+	if (timeout) {
+		if (!ack)
+			__i2c_send_stop();
+		*data = __i2c_read();
+		__i2c_clear_drf();
+		return 0;
+	} else
+		return -ETIMEDOUT;
+}
+
+/*
+ * I2C interface
+ */
+void i2c_open(void)
+{
+	__i2c_set_clk(jz_clocks.extalclk, 10000); /* default 10 KHz */
+	__i2c_enable();
+}
+
+void i2c_close(void)
+{
+	udelay(300); /* wait for STOP goes over. */
+	__i2c_disable();
+}
+
+void i2c_setclk(unsigned int i2cclk)
+{
+	__i2c_set_clk(jz_clocks.extalclk, i2cclk);
+}
+
+int i2c_lseek(unsigned char device, unsigned char offset)
+{
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_err;
+	if (i2c_put_data(offset) < 0)
+		goto address_err;
+	return 0;
+ device_err:
+	printk(KERN_DEBUG "No I2C device (0x%02x) installed.\n", device);
+	__i2c_send_stop();
+	return -ENODEV;
+ address_err:
+	printk(KERN_DEBUG "No I2C device (0x%02x) response.\n", device);
+	__i2c_send_stop();
+	return -EREMOTEIO;
+}
+
+int i2c_read(unsigned char device, unsigned char *buf,
+	       unsigned char address, int count)
+{
+	int cnt = count;
+	int timeout = 5;
+
+L_try_again:
+
+	if (timeout < 0)
+		goto L_timeout;
+
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_werr;
+	if (i2c_put_data(address) < 0)
+		goto address_err;
+
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_READ ) < 0)
+		goto device_rerr;
+	__i2c_send_ack();	/* Master sends ACK for continue reading */
+	while (cnt) {
+		if (cnt == 1) {
+			if (i2c_get_data(buf, 0) < 0)
+				break;
+		} else {
+			if (i2c_get_data(buf, 1) < 0)
+				break;
+		}
+		cnt--;
+		buf++;
+	}
+
+	__i2c_send_stop();
+	return count - cnt;
+ device_rerr:
+ device_werr:
+ address_err:
+	timeout --;
+	__i2c_send_stop();
+	goto L_try_again;
+
+L_timeout:
+	__i2c_send_stop();
+	printk("Read I2C device 0x%2x failed.\n", device);
+	return -ENODEV;
+}
+
+int i2c_write(unsigned char device, unsigned char *buf,
+		unsigned char address, int count)
+{
+	int cnt = count;
+	int cnt_in_pg;
+	int timeout = 5;
+	unsigned char *tmpbuf;
+	unsigned char tmpaddr;
+
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+
+ W_try_again:
+	if (timeout < 0)
+		goto W_timeout;
+
+	cnt = count;
+	tmpbuf = (unsigned char *)buf;
+	tmpaddr = address;
+
+ start_write_page:
+	cnt_in_pg = 0;
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_err;
+#ifdef CONFIG_JZ_TPANEL_ATA2508
+	if (address == 0xff) {
+		if (i2c_put_data_nack(tmpaddr) < 0)
+			goto address_err;
+		while (cnt) {
+			if (++cnt_in_pg > 8) {
+				__i2c_send_stop();
+				mdelay(1);
+				tmpaddr += 8;
+				goto start_write_page;
+			}
+			if (i2c_put_data_nack(*tmpbuf) < 0)
+				break;
+			cnt--;
+			tmpbuf++;
+		}
+	}
+	else {
+
+		if (i2c_put_data(tmpaddr) < 0)
+			goto address_err;
+		while (cnt) {
+			if (++cnt_in_pg > 8) {
+				__i2c_send_stop();
+				mdelay(1);
+				tmpaddr += 8;
+				goto start_write_page;
+			}
+			if (i2c_put_data(*tmpbuf) < 0)
+				break;
+			cnt--;
+			tmpbuf++;
+		}
+	}
+#else
+	if (i2c_put_data(tmpaddr) < 0)
+		goto address_err;
+	while (cnt) {
+		if (++cnt_in_pg > 8) {
+			__i2c_send_stop();
+			mdelay(1);
+			tmpaddr += 8;
+			goto start_write_page;
+		}
+		if (i2c_put_data(*tmpbuf) < 0)
+			break;
+		cnt--;
+		tmpbuf++;
+	}
+#endif
+	__i2c_send_stop();
+	return count - cnt;
+ device_err:
+ address_err:
+	timeout--;
+	__i2c_send_stop();
+	goto W_try_again;
+
+ W_timeout:
+	printk(KERN_DEBUG "Write I2C device 0x%2x failed.\n", device);
+	__i2c_send_stop();
+	return -ENODEV;
+}
+
+EXPORT_SYMBOL(i2c_open);
+EXPORT_SYMBOL(i2c_close);
+EXPORT_SYMBOL(i2c_setclk);
+EXPORT_SYMBOL(i2c_read);
+EXPORT_SYMBOL(i2c_write);
--- linux-2.6.24.7.old/arch/mips/jz4740/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/irq.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,265 @@
+/*
+ * linux/arch/mips/jz4740/irq.c
+ *
+ * JZ4740 interrupt routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/jzsoc.h>
+
+/*
+ * INTC irq type
+ */
+
+static void enable_intc_irq(unsigned int irq)
+{
+	__intc_unmask_irq(irq);
+}
+
+static void disable_intc_irq(unsigned int irq)
+{
+	__intc_mask_irq(irq);
+}
+
+static void mask_and_ack_intc_irq(unsigned int irq)
+{
+	__intc_mask_irq(irq);
+	__intc_ack_irq(irq);
+}
+
+static void end_intc_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		enable_intc_irq(irq);
+	}
+}
+
+static unsigned int startup_intc_irq(unsigned int irq)
+{
+	enable_intc_irq(irq);
+	return 0;
+}
+
+static void shutdown_intc_irq(unsigned int irq)
+{
+	disable_intc_irq(irq);
+}
+
+static struct irq_chip intc_irq_type = {
+	.typename = "INTC",
+	.startup = startup_intc_irq,
+	.shutdown = shutdown_intc_irq,
+	.enable = enable_intc_irq,
+	.disable = disable_intc_irq,
+	.ack = mask_and_ack_intc_irq,
+	.end = end_intc_irq,
+};
+
+/*
+ * GPIO irq type
+ */
+
+static void enable_gpio_irq(unsigned int irq)
+{
+	unsigned int intc_irq;
+
+	if (irq < (IRQ_GPIO_0 + 32)) {
+		intc_irq = IRQ_GPIO0;
+	}
+	else if (irq < (IRQ_GPIO_0 + 64)) {
+		intc_irq = IRQ_GPIO1;
+	}
+	else if (irq < (IRQ_GPIO_0 + 96)) {
+		intc_irq = IRQ_GPIO2;
+	}
+	else {
+		intc_irq = IRQ_GPIO3;
+	}
+
+	enable_intc_irq(intc_irq);
+	__gpio_unmask_irq(irq - IRQ_GPIO_0);
+}
+
+static void disable_gpio_irq(unsigned int irq)
+{
+	__gpio_mask_irq(irq - IRQ_GPIO_0);
+}
+
+static void mask_and_ack_gpio_irq(unsigned int irq)
+{
+	__gpio_mask_irq(irq - IRQ_GPIO_0);
+	__gpio_ack_irq(irq - IRQ_GPIO_0);
+}
+
+static void end_gpio_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		enable_gpio_irq(irq);
+	}
+}
+
+static unsigned int startup_gpio_irq(unsigned int irq)
+{
+	enable_gpio_irq(irq);
+	return 0;
+}
+
+static void shutdown_gpio_irq(unsigned int irq)
+{
+	disable_gpio_irq(irq);
+}
+
+static struct irq_chip gpio_irq_type = {
+	.typename = "GPIO",
+	.startup = startup_gpio_irq,
+	.shutdown = shutdown_gpio_irq,
+	.enable = enable_gpio_irq,
+	.disable = disable_gpio_irq,
+	.ack = mask_and_ack_gpio_irq,
+	.end = end_gpio_irq,
+};
+
+/*
+ * DMA irq type
+ */
+
+static void enable_dma_irq(unsigned int irq)
+{
+	__intc_unmask_irq(IRQ_DMAC);
+	__dmac_channel_enable_irq(irq - IRQ_DMA_0);
+}
+
+static void disable_dma_irq(unsigned int irq)
+{
+	__dmac_channel_disable_irq(irq - IRQ_DMA_0);
+}
+
+static void mask_and_ack_dma_irq(unsigned int irq)
+{
+	__intc_ack_irq(IRQ_DMAC);
+	__dmac_channel_disable_irq(irq - IRQ_DMA_0);
+}
+
+static void end_dma_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		enable_dma_irq(irq);
+	}
+}
+
+static unsigned int startup_dma_irq(unsigned int irq)
+{
+	enable_dma_irq(irq);
+	return 0;
+}
+
+static void shutdown_dma_irq(unsigned int irq)
+{
+	disable_dma_irq(irq);
+}
+
+static struct irq_chip dma_irq_type = {
+	.typename = "DMA",
+	.startup = startup_dma_irq,
+	.shutdown = shutdown_dma_irq,
+	.enable = enable_dma_irq,
+	.disable = disable_dma_irq,
+	.ack = mask_and_ack_dma_irq,
+	.end = end_dma_irq,
+};
+
+//----------------------------------------------------------------------
+
+void __init arch_init_irq(void)
+{
+	int i;
+
+	clear_c0_status(0xff04); /* clear ERL */
+	set_c0_status(0x0400);   /* set IP2 */
+
+	/* Set up INTC irq
+	 */
+	for (i = 0; i < 32; i++) {
+		disable_intc_irq(i);
+		irq_desc[i].chip = &intc_irq_type;
+	}
+
+	/* Set up DMAC irq
+	 */
+	for (i = 0; i < NUM_DMA; i++) {
+		disable_dma_irq(IRQ_DMA_0 + i);
+		irq_desc[IRQ_DMA_0 + i].chip = &dma_irq_type;
+	}
+
+	/* Set up GPIO irq
+	 */
+	for (i = 0; i < NUM_GPIO; i++) {
+		disable_gpio_irq(IRQ_GPIO_0 + i);
+		irq_desc[IRQ_GPIO_0 + i].chip = &gpio_irq_type;
+	}
+}
+
+static int plat_real_irq(int irq)
+{
+	switch (irq) {
+	case IRQ_GPIO0:
+		irq = __gpio_group_irq(0) + IRQ_GPIO_0;
+		break;
+	case IRQ_GPIO1:
+		irq = __gpio_group_irq(1) + IRQ_GPIO_0 + 32;
+		break;
+	case IRQ_GPIO2:
+		irq = __gpio_group_irq(2) + IRQ_GPIO_0 + 64;
+		break;
+	case IRQ_GPIO3:
+		irq = __gpio_group_irq(3) + IRQ_GPIO_0 + 96;
+		break;
+	case IRQ_DMAC:
+		irq = __dmac_get_irq() + IRQ_DMA_0;
+		break;
+	}
+
+	return irq;
+}
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	int irq = 0;
+	static unsigned long intc_ipr = 0;
+
+	intc_ipr |= REG_INTC_IPR;
+
+	if (!intc_ipr)	return;
+
+	irq = ffs(intc_ipr) - 1;
+	intc_ipr &= ~(1<<irq);
+
+	irq = plat_real_irq(irq);
+	do_IRQ(irq);
+}
--- linux-2.6.24.7.old/arch/mips/jz4740/platform.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/platform.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,169 @@
+/*
+ * Platform device support for Jz4740 SoC.
+ *
+ * Copyright 2007, <yliu@ingenic.cn>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/resource.h>
+
+#include <asm/jzsoc.h>
+
+/* OHCI (USB full speed host controller) */
+static struct resource jz_usb_ohci_resources[] = {
+	[0] = {
+		.start		= CPHYSADDR(UHC_BASE), // phys addr for ioremap
+		.end		= CPHYSADDR(UHC_BASE) + 0x10000 - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_UHC,
+		.end		= IRQ_UHC,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+/* The dmamask must be set for OHCI to work */
+static u64 ohci_dmamask = ~(u32)0;
+
+static struct platform_device jz_usb_ohci_device = {
+	.name		= "jz-ohci",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &ohci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(jz_usb_ohci_resources),
+	.resource	= jz_usb_ohci_resources,
+};
+
+/*** LCD controller ***/
+static struct resource jz_lcd_resources[] = {
+	[0] = {
+		.start          = CPHYSADDR(LCD_BASE),
+		.end            = CPHYSADDR(LCD_BASE) + 0x10000 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start          = IRQ_LCD,
+		.end            = IRQ_LCD,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static u64 jz_lcd_dmamask = ~(u32)0;
+
+static struct platform_device jz_lcd_device = {
+	.name           = "jz-lcd",
+	.id             = 0,
+	.dev = {
+		.dma_mask               = &jz_lcd_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(jz_lcd_resources),
+	.resource       = jz_lcd_resources,
+};
+
+/* UDC (USB gadget controller) */
+static struct resource jz_usb_gdt_resources[] = {
+	[0] = {
+		.start		= CPHYSADDR(UDC_BASE),
+		.end		= CPHYSADDR(UDC_BASE) + 0x10000 - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_UDC,
+		.end		= IRQ_UDC,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static u64 udc_dmamask = ~(u32)0;
+
+static struct platform_device jz_usb_gdt_device = {
+	.name		= "jz-udc",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &udc_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(jz_usb_gdt_resources),
+	.resource	= jz_usb_gdt_resources,
+};
+
+/** MMC/SD controller **/
+static struct resource jz_mmc_resources[] = {
+	[0] = {
+		.start          = CPHYSADDR(MSC_BASE),
+		.end            = CPHYSADDR(MSC_BASE) + 0x10000 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start          = IRQ_MSC,
+		.end            = IRQ_MSC,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static u64 jz_mmc_dmamask =  ~(u32)0;
+
+static struct platform_device jz_mmc_device = {
+	.name = "jz-mmc",
+	.id = 0,
+	.dev = {
+		.dma_mask               = &jz_mmc_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(jz_mmc_resources),
+	.resource       = jz_mmc_resources,
+};
+
+/** I2C controller **/
+static struct resource jz_i2c_resources[] = {
+	[0] = {
+		.start          = CPHYSADDR(I2C_BASE),
+		.end            = CPHYSADDR(I2C_BASE) + 0x10000 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start          = IRQ_I2C,
+		.end            = IRQ_I2C,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static u64 jz_i2c_dmamask =  ~(u32)0;
+
+static struct platform_device jz_i2c_device = {
+	.name = "jz_i2c",
+	.id = 0,
+	.dev = {
+		.dma_mask               = &jz_i2c_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(jz_i2c_resources),
+	.resource       = jz_i2c_resources,
+};
+
+/* All */
+static struct platform_device *jz_platform_devices[] __initdata = {
+	&jz_usb_ohci_device,
+	&jz_lcd_device,
+	&jz_usb_gdt_device,
+	&jz_mmc_device,
+	&jz_i2c_device,
+};
+
+static int __init jz_platform_init(void)
+{
+	return platform_add_devices(jz_platform_devices, ARRAY_SIZE(jz_platform_devices));
+}
+
+arch_initcall(jz_platform_init);
--- linux-2.6.24.7.old/arch/mips/jz4740/pm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/pm.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,462 @@
+/*
+ * linux/arch/mips/jz4740/common/pm.c
+ *
+ * JZ4740 Power Management Routines
+ *
+ * Copyright (C) 2006 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/pm.h>
+#include <linux/pm_legacy.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/sysctl.h>
+
+#include <asm/cacheops.h>
+#include <asm/jzsoc.h>
+
+#undef DEBUG
+//#define DEBUG
+#ifdef DEBUG
+#define dprintk(x...)	printk(x)
+#else
+#define dprintk(x...)
+#endif
+
+#define GPIO_WAKEUP 125 /* set SW7(GPIO 125) as WAKEUP key */
+
+/*
+ * __gpio_as_sleep set all pins to pull-disable, and set all pins as input
+ * except sdram, nand flash pins and the pins which can be used as CS1_N
+ * to CS4_N for chip select.
+ */
+#define __gpio_as_sleep()	              \
+do {	                                      \
+	REG_GPIO_PXFUNC(1) = ~0x9ff9ffff;     \
+	REG_GPIO_PXSELC(1) = ~0x9ff9ffff;     \
+	REG_GPIO_PXDIRC(1) = ~0x9ff9ffff;     \
+	REG_GPIO_PXPES(1)  =  0xffffffff;     \
+	REG_GPIO_PXFUNC(2) = ~0x37000000;     \
+	REG_GPIO_PXSELC(2) = ~0x37000000;     \
+	REG_GPIO_PXDIRC(2) = ~0x37000000;     \
+	REG_GPIO_PXPES(2)  =  0xffffffff;     \
+	REG_GPIO_PXFUNC(3) =  0xffffffff;     \
+	REG_GPIO_PXSELC(3) =  0xffffffff;     \
+	REG_GPIO_PXDIRC(3) =  0xffffffff;     \
+	REG_GPIO_PXPES(3)  =  0xffffffff;     \
+} while (0)
+
+static int jz_pm_do_hibernate(void)
+{
+	printk("Put CPU into hibernate mode.\n");
+
+	/* Mask all interrupts */
+	REG_INTC_IMSR = 0xffffffff;
+
+	/*
+	 * RTC Wakeup or 1Hz interrupt can be enabled or disabled
+	 * through  RTC driver's ioctl (linux/driver/char/rtc_jz.c).
+	 */
+
+	/* Set minimum wakeup_n pin low-level assertion time for wakeup: 100ms */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HWFCR = (100 << RTC_HWFCR_BIT);
+
+	/* Set reset pin low-level assertion time after wakeup: must  > 60ms */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HRCR = (60 << RTC_HRCR_BIT); /* 60 ms */
+
+	/* Scratch pad register to be reserved */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HSPR = 0x12345678;
+
+	/* clear wakeup status register */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HWRSR = 0x0;
+
+	/* Put CPU to power down mode */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HCR = RTC_HCR_PD;
+
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	while(1);
+
+	/* We can't get here */
+	return 0;
+}
+
+/* NOTES:
+ * 1: Pins that are floated (NC) should be set as input and pull-enable.
+ * 2: Pins that are pull-up or pull-down by outside should be set as input
+ *    and pull-disable.
+ * 3: Pins that are connected to a chip except sdram and nand flash
+ *    should be set as input and pull-disable, too.
+ */
+static void jz_board_do_sleep(unsigned long *ptr)
+{
+	unsigned char i;
+
+        /* Print messages of GPIO registers for debug */
+	for(i=0;i<4;i++) {
+		dprintk("run dat:%x pin:%x fun:%x sel:%x dir:%x pull:%x msk:%x trg:%x\n",        \
+			REG_GPIO_PXDAT(i),REG_GPIO_PXPIN(i),REG_GPIO_PXFUN(i),REG_GPIO_PXSEL(i), \
+			REG_GPIO_PXDIR(i),REG_GPIO_PXPE(i),REG_GPIO_PXIM(i),REG_GPIO_PXTRG(i));
+	}
+
+        /* Save GPIO registers */
+	for(i = 1; i < 4; i++) {
+		*ptr++ = REG_GPIO_PXFUN(i);
+		*ptr++ = REG_GPIO_PXSEL(i);
+		*ptr++ = REG_GPIO_PXDIR(i);
+		*ptr++ = REG_GPIO_PXPE(i);
+		*ptr++ = REG_GPIO_PXIM(i);
+		*ptr++ = REG_GPIO_PXDAT(i);
+		*ptr++ = REG_GPIO_PXTRG(i);
+	}
+
+        /*
+         * Set all pins to pull-disable, and set all pins as input except
+         * sdram, nand flash pins and the pins which can be used as CS1_N
+         * to CS4_N for chip select.
+         */
+        __gpio_as_sleep();
+
+        /*
+	 * Set proper status for GPB25 to GPB28 which can be used as CS1_N to CS4_N.
+	 * Keep the pins' function used for chip select(CS) here according to your
+         * system to avoid chip select crashing with sdram when resuming from sleep mode.
+         */
+
+#if defined(CONFIG_JZ4740_PAVO)
+        /* GPB25/CS1_N is used as chip select for nand flash, shouldn't be change. */
+
+        /* GPB26/CS2_N is connected to nand flash, needn't be changed. */
+
+        /* GPB27/CS3_N is used as EXT_INT for CS8900 on debug board, it should be set as input.*/
+	__gpio_as_input(32+27);
+
+        /* GPB28/CS4_N is used as cs8900's chip select, shouldn't be changed. */
+#endif
+
+ 	/*
+         * Enable pull for NC pins here according to your system
+	 */
+
+#if defined(CONFIG_JZ4740_PAVO)
+ 	/* GPB30-27 <-> J1: WE_N RD_N CS4_N EXT_INT */
+	for(i=27;i<31;i++) {
+		__gpio_enable_pull(32+i);
+	}
+
+	/* GPC27<-> WAIT_N */
+	__gpio_enable_pull(32*2+27);
+
+        /* GPD16<->SD_WP; GPD13-10<->MSC_D0-3; GPD9<->MSC_CMD; GPD8<->MSC_CLK */
+	__gpio_enable_pull(32*3+16);
+	for(i=8;i<14;i++) {
+		__gpio_enable_pull(32*3+i);
+	}
+#endif
+
+	/*
+         * If you must set some GPIOs as output to high level or low level,
+         * you can set them here, using:
+         * __gpio_as_output(n);
+         * __gpio_set_pin(n); or  __gpio_clear_pin(n);
+	 */
+
+#if defined(CONFIG_JZ4740_PAVO)
+	/* GPD16 which is used as AMPEN_N should be set to high to disable audio amplifier */
+	__gpio_set_pin(32*3+4);
+#endif
+
+#ifdef DEBUG
+        /* Keep uart0 function for printing debug message */
+	__gpio_as_uart0();
+
+        /* Print messages of GPIO registers for debug */
+	for(i=0;i<4;i++) {
+		dprintk("sleep dat:%x pin:%x fun:%x sel:%x dir:%x pull:%x msk:%x trg:%x\n",      \
+			REG_GPIO_PXDAT(i),REG_GPIO_PXPIN(i),REG_GPIO_PXFUN(i),REG_GPIO_PXSEL(i), \
+			REG_GPIO_PXDIR(i),REG_GPIO_PXPE(i),REG_GPIO_PXIM(i),REG_GPIO_PXTRG(i));
+	}
+#endif
+}
+
+static void jz_board_do_resume(unsigned long *ptr)
+{
+	unsigned char i;
+
+	/* Restore GPIO registers */
+	for(i = 1; i < 4; i++) {
+		 REG_GPIO_PXFUNS(i) = *ptr;
+		 REG_GPIO_PXFUNC(i) = ~(*ptr++);
+
+		 REG_GPIO_PXSELS(i) = *ptr;
+		 REG_GPIO_PXSELC(i) = ~(*ptr++);
+
+		 REG_GPIO_PXDIRS(i) = *ptr;
+		 REG_GPIO_PXDIRC(i) = ~(*ptr++);
+
+		 REG_GPIO_PXPES(i) = *ptr;
+		 REG_GPIO_PXPEC(i) = ~(*ptr++);
+
+		 REG_GPIO_PXIMS(i)=*ptr;
+		 REG_GPIO_PXIMC(i)=~(*ptr++);
+
+		 REG_GPIO_PXDATS(i)=*ptr;
+		 REG_GPIO_PXDATC(i)=~(*ptr++);
+
+		 REG_GPIO_PXTRGS(i)=*ptr;
+		 REG_GPIO_PXTRGC(i)=~(*ptr++);
+	}
+
+        /* Print messages of GPIO registers for debug */
+	for(i=0;i<4;i++) {
+		dprintk("resume dat:%x pin:%x fun:%x sel:%x dir:%x pull:%x msk:%x trg:%x\n",     \
+			REG_GPIO_PXDAT(i),REG_GPIO_PXPIN(i),REG_GPIO_PXFUN(i),REG_GPIO_PXSEL(i), \
+			REG_GPIO_PXDIR(i),REG_GPIO_PXPE(i),REG_GPIO_PXIM(i),REG_GPIO_PXTRG(i));
+	}
+}
+
+
+
+static int jz_pm_do_sleep(void)
+{
+	unsigned long delta;
+	unsigned long nfcsr = REG_EMC_NFCSR;
+	unsigned long scr = REG_CPM_SCR;
+	unsigned long imr = REG_INTC_IMR;
+	unsigned long sadc = REG_SADC_ENA;
+	unsigned long sleep_gpio_save[7*3];
+
+	printk("Put CPU into sleep mode.\n");
+
+	/* Preserve current time */
+	delta = xtime.tv_sec - REG_RTC_RSR;
+
+        /* Disable nand flash */
+	REG_EMC_NFCSR = ~0xff;
+
+        /* stop sadc */
+	REG_SADC_ENA &= ~0x7;
+	while((REG_SADC_ENA & 0x7) != 0);
+ 	udelay(100);
+
+        /*stop udc and usb*/
+	REG_CPM_SCR &= ~( 1<<6 | 1<<7);
+	REG_CPM_SCR |= 0<<6 | 1<<7;
+
+	/* Sleep on-board modules */
+	jz_board_do_sleep(sleep_gpio_save);
+
+	/* Mask all interrupts */
+	REG_INTC_IMSR = 0xffffffff;
+
+	/* Just allow following interrupts to wakeup the system.
+	 * Note: modify this according to your system.
+	 */
+
+	/* enable RTC alarm */
+	__intc_unmask_irq(IRQ_RTC);
+#if 0
+        /* make system wake up after n seconds by RTC alarm */
+	unsigned int v, n;
+	n = 10;
+	while (!__rtc_write_ready());
+	__rtc_enable_alarm();
+	while (!__rtc_write_ready());
+	__rtc_enable_alarm_irq();
+ 	while (!__rtc_write_ready());
+ 	v = __rtc_get_second();
+ 	while (!__rtc_write_ready());
+ 	__rtc_set_alarm_second(v+n);
+#endif
+
+	/* WAKEUP key */
+	__gpio_as_irq_rise_edge(GPIO_WAKEUP);
+	__gpio_unmask_irq(GPIO_WAKEUP);
+	__intc_unmask_irq(IRQ_GPIO3);  /* IRQ_GPIOn depends on GPIO_WAKEUP */
+
+ 	/* Enter SLEEP mode */
+	REG_CPM_LCR &= ~CPM_LCR_LPM_MASK;
+	REG_CPM_LCR |= CPM_LCR_LPM_SLEEP;
+	__asm__(".set\tmips3\n\t"
+		"wait\n\t"
+		".set\tmips0");
+
+	/* Restore to IDLE mode */
+	REG_CPM_LCR &= ~CPM_LCR_LPM_MASK;
+	REG_CPM_LCR |= CPM_LCR_LPM_IDLE;
+
+        /* Restore nand flash control register */
+	REG_EMC_NFCSR = nfcsr;
+
+	/* Restore interrupts */
+	REG_INTC_IMSR = imr;
+	REG_INTC_IMCR = ~imr;
+
+	/* Restore sadc */
+	REG_SADC_ENA = sadc;
+
+	/* Resume on-board modules */
+	jz_board_do_resume(sleep_gpio_save);
+
+	/* Restore sleep control register */
+	REG_CPM_SCR = scr;
+
+	/* Restore current time */
+	xtime.tv_sec = REG_RTC_RSR + delta;
+
+	return 0;
+}
+
+/* Put CPU to HIBERNATE mode */
+int jz_pm_hibernate(void)
+{
+	return jz_pm_do_hibernate();
+}
+
+#ifndef CONFIG_JZ_POWEROFF
+static irqreturn_t pm_irq_handler (int irq, void *dev_id)
+{
+	return IRQ_HANDLED;
+}
+#endif
+
+/* Put CPU to SLEEP mode */
+int jz_pm_sleep(void)
+{
+	int retval;
+
+#ifndef CONFIG_JZ_POWEROFF
+	if ((retval = request_irq (IRQ_GPIO_0 + GPIO_WAKEUP, pm_irq_handler, IRQF_DISABLED,
+				   "PM", NULL))) {
+		printk ("PM could not get IRQ for GPIO_WAKEUP\n");
+		return retval;
+	}
+#endif
+
+	pm_send_all(PM_SUSPEND, (void *)3);
+	retval = jz_pm_do_sleep();
+	pm_send_all(PM_RESUME, (void *)0);
+
+#ifndef CONFIG_JZ_POWEROFF
+	free_irq (IRQ_GPIO_0 + GPIO_WAKEUP, NULL);
+#endif
+
+	return retval;
+}
+
+#if 0
+/* Deprecated ,was used by dpm */
+void jz_pm_idle(void)
+{
+	local_irq_disable();
+	if (!need_resched()) {
+		local_irq_enable();
+		cpu_wait();
+	}
+}
+#endif
+
+#ifdef CONFIG_SYSCTL
+
+/*
+ * Use a temporary sysctl number. Horrid, but will be cleaned up in 2.6
+ * when all the PM interfaces exist nicely.
+ */
+#define CTL_PM_SUSPEND   1
+#define CTL_PM_HIBERNATE 2
+
+/*----------------------------------------------------------------------------
+ * Power Management sleep sysctl proc interface
+ *
+ * A write to /proc/sys/pm/suspend invokes this function
+ * which initiates a sleep.
+ *--------------------------------------------------------------------------*/
+static int sysctl_jz_pm_sleep(struct ctl_table *ctl, int write, struct file * filp,
+			      void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	return jz_pm_sleep();
+}
+
+/*----------------------------------------------------------------------------
+ * Power Management sleep sysctl proc interface
+ *
+ * A write to /proc/sys/pm/hibernate invokes this function
+ * which initiates a poweroff.
+ *--------------------------------------------------------------------------*/
+static int sysctl_jz_pm_hibernate(struct ctl_table *ctl, int write, struct file * filp,
+				  void __user *buffer, size_t *lenp, loff_t *ppos)
+{
+	return jz_pm_hibernate();
+}
+
+static struct ctl_table pm_table[] =
+{
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "suspend",
+		.data		= NULL,
+		.maxlen		= 0,
+		.mode		= 0600,
+		.proc_handler	= &sysctl_jz_pm_sleep,
+	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "hibernate",
+		.data		= NULL,
+		.maxlen		= 0,
+		.mode		= 0600,
+		.proc_handler	= &sysctl_jz_pm_hibernate,
+	},
+	{ .ctl_name = 0}
+};
+
+static struct ctl_table pm_dir_table[] =
+{
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "pm",
+		.mode		= 0555,
+		.child		= pm_table,
+	},
+	{ .ctl_name = 0}
+};
+
+#endif /* CONFIG_SYSCTL */
+
+/*
+ * Initialize power interface
+ */
+static int __init jz_pm_init(void)
+{
+	printk("Power Management for JZ\n");
+
+#ifdef CONFIG_SYSCTL
+	register_sysctl_table(pm_dir_table);
+#endif
+
+	return 0;
+}
+
+module_init(jz_pm_init);
+
--- linux-2.6.24.7.old/arch/mips/jz4740/proc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/proc.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,887 @@
+/*
+ * linux/arch/mips/jz4740/proc.c
+ *
+ * /proc/jz/ procfs for jz4740 on-chip modules.
+ *
+ * Copyright (C) 2006 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/sysctl.h>
+#include <linux/proc_fs.h>
+#include <linux/page-flags.h>
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+#include <asm/jzsoc.h>
+
+//#define DEBUG 1
+#undef DEBUG
+
+/* Define this to reserve total 4MB contineous physical memory for IPU.
+ * MPlayer will use IPU to optimize the decoding process.
+ *
+ * If you do not want to run the MPlayer, you can comment it.
+ */
+#define CONFIG_RESERVE_IPU_MEM 1
+
+struct proc_dir_entry *proc_jz_root;
+
+
+/*
+ * EMC Modules
+ */
+static int emc_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+
+	len += sprintf (page+len, "SMCR(0-5): 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", REG_EMC_SMCR0, REG_EMC_SMCR1, REG_EMC_SMCR2, REG_EMC_SMCR3, REG_EMC_SMCR4);
+	len += sprintf (page+len, "SACR(0-5): 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", REG_EMC_SACR0, REG_EMC_SACR1, REG_EMC_SACR2, REG_EMC_SACR3, REG_EMC_SACR4);
+	len += sprintf (page+len, "DMCR:      0x%08x\n", REG_EMC_DMCR);
+	len += sprintf (page+len, "RTCSR:     0x%04x\n", REG_EMC_RTCSR);
+	len += sprintf (page+len, "RTCOR:     0x%04x\n", REG_EMC_RTCOR);
+	return len;
+}
+
+/*
+ * Power Manager Module
+ */
+static int pmc_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	unsigned long lcr = REG_CPM_LCR;
+	unsigned long clkgr = REG_CPM_CLKGR;
+
+	len += sprintf (page+len, "Low Power Mode : %s\n",
+			((lcr & CPM_LCR_LPM_MASK) == (CPM_LCR_LPM_IDLE)) ?
+			"IDLE" : (((lcr & CPM_LCR_LPM_MASK) == (CPM_LCR_LPM_SLEEP)) ?
+				  "SLEEP" : "HIBERNATE"));
+	len += sprintf (page+len, "Doze Mode      : %s\n",
+			(lcr & CPM_LCR_DOZE_ON) ? "on" : "off");
+	if (lcr & CPM_LCR_DOZE_ON)
+		len += sprintf (page+len, "     duty      : %d\n", (int)((lcr & CPM_LCR_DOZE_DUTY_MASK) >> CPM_LCR_DOZE_DUTY_BIT));
+	len += sprintf (page+len, "IPU            : %s\n",
+			(clkgr & CPM_CLKGR_IPU) ? "stopped" : "running");
+	len += sprintf (page+len, "DMAC           : %s\n",
+			(clkgr & CPM_CLKGR_DMAC) ? "stopped" : "running");
+	len += sprintf (page+len, "UHC            : %s\n",
+			(clkgr & CPM_CLKGR_UHC) ? "stopped" : "running");
+	len += sprintf (page+len, "UDC            : %s\n",
+			(clkgr & CPM_CLKGR_UDC) ? "stopped" : "running");
+	len += sprintf (page+len, "LCD            : %s\n",
+			(clkgr & CPM_CLKGR_LCD) ? "stopped" : "running");
+	len += sprintf (page+len, "CIM            : %s\n",
+			(clkgr & CPM_CLKGR_CIM) ? "stopped" : "running");
+	len += sprintf (page+len, "SADC           : %s\n",
+			(clkgr & CPM_CLKGR_SADC) ? "stopped" : "running");
+	len += sprintf (page+len, "MSC            : %s\n",
+			(clkgr & CPM_CLKGR_MSC) ? "stopped" : "running");
+	len += sprintf (page+len, "AIC1           : %s\n",
+			(clkgr & CPM_CLKGR_AIC1) ? "stopped" : "running");
+	len += sprintf (page+len, "AIC2           : %s\n",
+			(clkgr & CPM_CLKGR_AIC2) ? "stopped" : "running");
+	len += sprintf (page+len, "SSI            : %s\n",
+			(clkgr & CPM_CLKGR_SSI) ? "stopped" : "running");
+	len += sprintf (page+len, "I2C            : %s\n",
+			(clkgr & CPM_CLKGR_I2C) ? "stopped" : "running");
+	len += sprintf (page+len, "RTC            : %s\n",
+			(clkgr & CPM_CLKGR_RTC) ? "stopped" : "running");
+	len += sprintf (page+len, "TCU            : %s\n",
+			(clkgr & CPM_CLKGR_TCU) ? "stopped" : "running");
+	len += sprintf (page+len, "UART1          : %s\n",
+			(clkgr & CPM_CLKGR_UART1) ? "stopped" : "running");
+	len += sprintf (page+len, "UART0          : %s\n",
+			(clkgr & CPM_CLKGR_UART0) ? "stopped" : "running");
+	return len;
+}
+
+static int pmc_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	REG_CPM_CLKGR = simple_strtoul(buffer, 0, 16);
+	return count;
+}
+
+/*
+ * Clock Generation Module
+ */
+#define TO_MHZ(x) (x/1000000),(x%1000000)/10000
+#define TO_KHZ(x) (x/1000),(x%1000)/10
+
+static int cgm_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	unsigned int cppcr = REG_CPM_CPPCR;  /* PLL Control Register */
+	unsigned int cpccr = REG_CPM_CPCCR;  /* Clock Control Register */
+	unsigned int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned int od[4] = {1, 2, 2, 4};
+
+	len += sprintf (page+len, "CPPCR          : 0x%08x\n", cppcr);
+	len += sprintf (page+len, "CPCCR          : 0x%08x\n", cpccr);
+	len += sprintf (page+len, "PLL            : %s\n",
+			(cppcr & CPM_CPPCR_PLLEN) ? "ON" : "OFF");
+	len += sprintf (page+len, "m:n:o          : %d:%d:%d\n",
+			__cpm_get_pllm() + 2,
+			__cpm_get_plln() + 2,
+			od[__cpm_get_pllod()]
+		);
+	len += sprintf (page+len, "C:H:M:P        : %d:%d:%d:%d\n",
+			div[__cpm_get_cdiv()],
+			div[__cpm_get_hdiv()],
+			div[__cpm_get_mdiv()],
+			div[__cpm_get_pdiv()]
+		);
+	len += sprintf (page+len, "PLL Freq       : %3d.%02d MHz\n", TO_MHZ(__cpm_get_pllout()));
+	len += sprintf (page+len, "CCLK           : %3d.%02d MHz\n", TO_MHZ(__cpm_get_cclk()));
+	len += sprintf (page+len, "HCLK           : %3d.%02d MHz\n", TO_MHZ(__cpm_get_hclk()));
+	len += sprintf (page+len, "MCLK           : %3d.%02d MHz\n", TO_MHZ(__cpm_get_mclk()));
+	len += sprintf (page+len, "PCLK           : %3d.%02d MHz\n", TO_MHZ(__cpm_get_pclk()));
+	len += sprintf (page+len, "LCDCLK         : %3d.%02d MHz\n", TO_MHZ(__cpm_get_lcdclk()));
+	len += sprintf (page+len, "PIXCLK         : %3d.%02d KHz\n", TO_KHZ(__cpm_get_pixclk()));
+	len += sprintf (page+len, "I2SCLK         : %3d.%02d MHz\n", TO_MHZ(__cpm_get_i2sclk()));
+	len += sprintf (page+len, "USBCLK         : %3d.%02d MHz\n", TO_MHZ(__cpm_get_usbclk()));
+	len += sprintf (page+len, "MSCCLK         : %3d.%02d MHz\n", TO_MHZ(__cpm_get_mscclk()));
+	len += sprintf (page+len, "EXTALCLK       : %3d.%02d MHz\n", TO_MHZ(__cpm_get_extalclk()));
+	len += sprintf (page+len, "RTCCLK         : %3d.%02d MHz\n", TO_MHZ(__cpm_get_rtcclk()));
+
+	return len;
+}
+
+static int cgm_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	REG_CPM_CPCCR = simple_strtoul(buffer, 0, 16);
+	return count;
+}
+
+
+/*
+ * UDC hotplug
+ */
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+extern int jz_udc_active;	/* defined in drivers/char/jzchar/jz_udc_hotplug.c */
+#endif
+
+#ifndef GPIO_UDC_HOTPLUG
+#define GPIO_UDC_HOTPLUG 86
+#endif
+
+static int udc_read_proc(char *page, char **start, off_t off,
+			 int count, int *eof, void *data)
+{
+        int len = 0;
+
+	if (__gpio_get_pin(GPIO_UDC_HOTPLUG)) {
+
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+
+		/* Cable has connected, wait for disconnection. */
+		__gpio_as_irq_fall_edge(GPIO_UDC_HOTPLUG);
+
+		if (jz_udc_active)
+			len += sprintf (page+len, "CONNECT_CABLE\n");
+		else
+			len += sprintf (page+len, "CONNECT_POWER\n");
+#else
+		len += sprintf (page+len, "CONNECT\n");
+#endif
+	}
+	else {
+
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+		/* Cable has disconnected, wait for connection. */
+		__gpio_as_irq_rise_edge(GPIO_UDC_HOTPLUG);
+#endif
+
+		len += sprintf (page+len, "REMOVE\n");
+	}
+
+        return len;
+}
+
+/*
+ * MMC/SD hotplug
+ */
+
+#ifndef MSC_HOTPLUG_PIN
+#define MSC_HOTPLUG_PIN 90
+#endif
+
+static int mmc_read_proc (char *page, char **start, off_t off,
+                          int count, int *eof, void *data)
+{
+        int len = 0;
+
+#if defined(CONFIG_JZ4740_LYRA)
+        if (!(__gpio_get_pin(MSC_HOTPLUG_PIN)))
+#else
+        if (__gpio_get_pin(MSC_HOTPLUG_PIN))
+#endif
+                len += sprintf (page+len, "REMOVE\n");
+        else
+                len += sprintf (page+len, "INSERT\n");
+
+        return len;
+}
+
+#ifdef CONFIG_RESERVE_IPU_MEM
+
+/* USAGE:
+ * echo n  > /proc/jz/ipu 	// n = [1,...,9], alloc mem, 2^n pages.
+ * echo FF > /proc/jz/ipu 	// 255, free all buffer
+ * echo xxxx > /proc/jz/ipu 	// free buffer which addr is xxxx
+ * echo llll > /proc/jz/ipu 	// add_wired_entry(l,l,l,l)
+ * echo 0  > /proc/jz/ipu 	// debug, print ipu_buf
+ * od -X /proc/jz/ipu 		// read mem addr
+ */
+
+typedef struct _ipu_buf {
+	unsigned int addr;	/* phys addr */
+	unsigned int page_shift;
+} ipu_buf_t;
+
+#define IPU_BUF_MAX 		4 	/* 4 buffers */
+
+static struct _ipu_buf ipu_buf[IPU_BUF_MAX];
+static int ipu_buf_cnt = 0;
+static unsigned char g_asid=0;
+
+extern void local_flush_tlb_all(void);
+
+/* CP0 hazard avoidance. */
+#define BARRIER __asm__ __volatile__(".set noreorder\n\t" \
+				     "nop; nop; nop; nop; nop; nop;\n\t" \
+				     ".set reorder\n\t")
+void show_tlb(void)
+{
+#define ASID_MASK 0xFF
+
+        unsigned long flags;
+        unsigned int old_ctx;
+	unsigned int entry;
+	unsigned int entrylo0, entrylo1, entryhi;
+	unsigned int pagemask;
+
+	local_irq_save(flags);
+
+	/* Save old context */
+	old_ctx = (read_c0_entryhi() & 0xff);
+
+	printk("TLB content:\n");
+	entry = 0;
+	while(entry < 32) {
+		write_c0_index(entry);
+		BARRIER;
+		tlb_read();
+		BARRIER;
+		entryhi = read_c0_entryhi();
+		entrylo0 = read_c0_entrylo0();
+		entrylo1 = read_c0_entrylo1();
+		pagemask = read_c0_pagemask();
+		printk("%02d: ASID=%02d%s VA=0x%08x ", entry, entryhi & ASID_MASK, (entrylo0 & entrylo1 & 1) ? "(G)" : "   ", entryhi & ~ASID_MASK);
+		printk("PA0=0x%08x C0=%x %s%s%s\n", (entrylo0>>6)<<12, (entrylo0>>3) & 7, (entrylo0 & 4) ? "Dirty " : "", (entrylo0 & 2) ? "Valid " : "Invalid ", (entrylo0 & 1) ? "Global" : "");
+		printk("\t\t\t     PA1=0x%08x C1=%x %s%s%s\n", (entrylo1>>6)<<12, (entrylo1>>3) & 7, (entrylo1 & 4) ? "Dirty " : "", (entrylo1 & 2) ? "Valid " : "Invalid ", (entrylo1 & 1) ? "Global" : "");
+
+		printk("\t\tpagemask=0x%08x", pagemask);
+		printk("\tentryhi=0x%08x\n", entryhi);
+		printk("\t\tentrylo0=0x%08x", entrylo0);
+		printk("\tentrylo1=0x%08x\n", entrylo1);
+
+		entry++;
+	}
+	BARRIER;
+	write_c0_entryhi(old_ctx);
+
+	local_irq_restore(flags);
+}
+
+static void ipu_add_wired_entry(unsigned long pid,
+				unsigned long entrylo0, unsigned long entrylo1,
+				unsigned long entryhi, unsigned long pagemask)
+{
+	unsigned long flags;
+	unsigned long wired;
+	unsigned long old_pagemask;
+	unsigned long old_ctx;
+	struct task_struct *g, *p;
+
+	/* We will lock an 4MB page size entry to map the 4MB reserved IPU memory */
+	wired = read_c0_wired();
+	if (wired) return;
+
+	do_each_thread(g, p) {
+		if (p->pid == pid )
+			g_asid = p->mm->context[0];
+	} while_each_thread(g, p);
+
+	local_irq_save(flags);
+
+	entrylo0 = entrylo0 >> 6;   /* PFN */
+	entrylo0 |= 0x6 | (0 << 3); /* Write-through cacheable, dirty, valid */
+
+	/* Save old context and create impossible VPN2 value */
+	old_ctx = read_c0_entryhi() & 0xff;
+	old_pagemask = read_c0_pagemask();
+	write_c0_wired(wired + 1);
+	write_c0_index(wired);
+	BARRIER;
+	entryhi &= ~0xff;	/* new add, 20070906 */
+	entryhi |= g_asid;	/* new add, 20070906 */
+//	entryhi |= old_ctx;	/* new add, 20070906 */
+	write_c0_pagemask(pagemask);
+	write_c0_entryhi(entryhi);
+	write_c0_entrylo0(entrylo0);
+	write_c0_entrylo1(entrylo1);
+	BARRIER;
+	tlb_write_indexed();
+	BARRIER;
+
+	write_c0_entryhi(old_ctx);
+	BARRIER;
+	write_c0_pagemask(old_pagemask);
+	local_flush_tlb_all();
+	local_irq_restore(flags);
+#if defined(DEBUG)
+	printk("\nold_ctx=%03d\n", old_ctx);
+
+	show_tlb();
+#endif
+}
+
+static void ipu_del_wired_entry( void )
+{
+	unsigned long flags;
+	unsigned long wired;
+
+	/* Free all lock entry */
+	local_irq_save(flags);
+	wired = read_c0_wired();
+	if (wired)
+		write_c0_wired(0);
+	local_irq_restore(flags);
+}
+
+static inline void ipu_buf_get( unsigned int page_shift )
+{
+	unsigned char * virt_addr;
+	int i;
+	for ( i=0; i< IPU_BUF_MAX; ++i ) {
+		if ( ipu_buf[i].addr == 0 ) {
+			break;
+		}
+	}
+
+	if ( (ipu_buf_cnt = i) == IPU_BUF_MAX ) {
+		printk("Error, no free ipu buffer.\n");
+		return ;
+	}
+
+	virt_addr =  (unsigned char *)__get_free_pages(GFP_KERNEL, page_shift);
+
+	if ( virt_addr ) {
+		ipu_buf[ipu_buf_cnt].addr = (unsigned int)virt_to_phys((void *)virt_addr);
+		ipu_buf[ipu_buf_cnt].page_shift = page_shift;
+
+		for (i = 0; i < (1<<page_shift); i++) {
+			SetPageReserved(virt_to_page(virt_addr));
+			virt_addr += PAGE_SIZE;
+		}
+	}
+	else {
+		printk("get memory Failed.\n");
+	}
+}
+
+static inline void ipu_buf_free( unsigned int phys_addr )
+{
+	unsigned char * virt_addr, *addr;
+	int cnt, i;
+
+	if ( phys_addr == 0 )
+		return ;
+
+	for ( cnt=0; cnt<IPU_BUF_MAX; ++cnt )
+		if ( phys_addr == ipu_buf[cnt].addr )
+			break;
+
+	if ( cnt == IPU_BUF_MAX ) {	/* addr not in the ipu buffers */
+		printk("Invalid addr:0x%08x\n", (unsigned int)phys_addr);
+	}
+
+	virt_addr = (unsigned char *)phys_to_virt(ipu_buf[cnt].addr);
+	addr = virt_addr;
+	for (i = 0; i < (1<<ipu_buf[cnt].page_shift); i++) {
+		ClearPageReserved(virt_to_page(addr));
+		addr += PAGE_SIZE;
+	}
+
+	if ( cnt == 0 )
+		ipu_del_wired_entry();
+
+	free_pages((unsigned long )virt_addr, ipu_buf[cnt].page_shift);
+
+	ipu_buf[cnt].addr = 0;
+	ipu_buf[cnt].page_shift = 0;
+}
+
+static int ipu_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+
+	/* read as binary */
+	unsigned int * pint;
+	pint = (unsigned int *) (page+len);
+
+	if ( ipu_buf_cnt >= IPU_BUF_MAX ) {	/* failed alloc mem, rturn 0 */
+		printk("no free buffer.\n");
+		*pint = 0;
+	}
+	else
+		*pint = (unsigned int )ipu_buf[ipu_buf_cnt].addr; /* phys addr */
+	len += sizeof(unsigned int);
+
+#if defined(DEBUG)
+		show_tlb();
+#endif
+	return len;
+
+}
+
+static int ipu_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	unsigned int val ;
+	int cnt,i;
+	char buf[12];
+	unsigned long pid, entrylo0, entrylo1, entryhi, pagemask;
+#if defined(DEBUG)
+	printk("ipu write count=%u\n", count);
+#endif
+	if (count == (8*5+1)) {
+		for (i=0;i<12;i++) buf[i]=0;
+		strncpy(buf, buffer+8*0, 8);
+		pid = simple_strtoul(buf, 0, 16);
+		for (i=0;i<12;i++) buf[i]=0;
+		strncpy(buf, buffer+8*1, 8);
+		entrylo0 = simple_strtoul(buf, 0, 16);
+		for (i=0;i<12;i++) buf[i]=0;
+		strncpy(buf, buffer+8*2, 8);
+		entrylo1 = simple_strtoul(buf, 0, 16);
+		for (i=0;i<12;i++) buf[i]=0;
+		strncpy(buf, buffer+8*3, 8);
+		entryhi = simple_strtoul(buf, 0, 16);
+		for (i=0;i<12;i++) buf[i]=0;
+		strncpy(buf, buffer+8*4, 8);
+		pagemask = simple_strtoul(buf, 0, 16);
+
+#if defined(DEBUG)
+		printk("pid=0x%08x, entrylo0=0x%08x, entrylo1=0x%08x, entryhi=0x%08x, pagemask=0x%08x\n",
+		       pid, entrylo0, entrylo1, entryhi, pagemask);
+#endif
+		ipu_add_wired_entry( pid, entrylo0, entrylo1, entryhi, pagemask);
+		return 41;
+	} else if ( count <= 8+1 ) {
+		for (i=0;i<12;i++) buf[i]=0;
+		strncpy(buf, buffer, 8);
+		val = simple_strtoul(buf, 0, 16);
+	} else if (count == 44) {
+		for (i = 0; i < 12; i++)
+			buf[i] = 0;
+		strncpy(buf, buffer, 10);
+		pid = simple_strtoul(buf, 0, 16);
+		for (i = 0; i < 12; i++)
+			buf[i] = 0;
+		strncpy(buf, buffer + 11, 10);
+		entryhi = simple_strtoul(buf, 0, 16);//vaddr
+		for (i = 0; i < 12; i++)
+			buf[i] = 0;
+		strncpy(buf, buffer + 22, 10);
+		entrylo0 = simple_strtoul(buf, 0, 16);//paddr
+		for (i = 0; i < 12; i++)
+			buf[i] = 0;
+		strncpy(buf, buffer + 33, 10);
+		pagemask = simple_strtoul(buf, 0, 16);
+		pagemask = 0x3ff << 13; /* Fixed to 4MB page size */
+		ipu_add_wired_entry(pid, entrylo0, 0, entryhi, pagemask);
+		return 44;
+	} else {
+		printk("ipu write count error, count=%d\n.", (unsigned int)count);
+		return -1;
+	}
+
+	/* val: 1-9, page_shift,  val>= 10: ipu_buf.addr */
+	if ( val == 0 ) {	/* debug, print ipu_buf info */
+		for ( cnt=0; cnt<IPU_BUF_MAX; ++cnt)
+			printk("ipu_buf[%d]: addr=0x%08x, page_shift=%d\n",
+			       cnt, ipu_buf[cnt].addr, ipu_buf[cnt].page_shift );
+#if defined(DEBUG)
+		show_tlb();
+#endif
+	}
+	else if ( 0< val && val < 10 ) {
+		ipu_buf_get(val);
+	}
+	else if ( val == 0xff ) { /* 255: free all ipu_buf */
+		for ( cnt=0; cnt<IPU_BUF_MAX; ++cnt ) {
+			ipu_buf_free(ipu_buf[cnt].addr);
+		}
+	}
+	else {
+		ipu_buf_free(val);
+	}
+
+	return count;
+}
+
+/***********************************************************************
+ * IPU memory management (used by mplayer and other apps)
+ *
+ * We reserved 4MB memory for IPU
+ * The memory base address is jz_ipu_framebuf
+ */
+
+/* Usage:
+ *
+ * echo n  > /proc/jz/imem 		// n = [0,...,10], allocate memory, 2^n pages
+ * echo xxxxxxxx > /proc/jz/imem	// free buffer which addr is xxxxxxxx
+ * echo FF > /proc/jz/ipu 		// FF, free all buffers
+ * od -X /proc/jz/imem 			// return the allocated buffer address and the max order of free buffer
+ */
+
+//#define DEBUG_IMEM 1
+
+#define IMEM_MAX_ORDER 10		/* max 2^10 * 4096 = 4MB */
+
+static unsigned int jz_imem_base;	/* physical base address of ipu memory */
+
+static unsigned int allocated_phys_addr = 0;
+
+/*
+ * Allocated buffer list
+ */
+typedef struct imem_list {
+	unsigned int phys_start;	/* physical start addr */
+	unsigned int phys_end;		/* physical end addr */
+	struct imem_list *next;
+} imem_list_t;
+
+static struct imem_list *imem_list_head = NULL; /* up sorted by phys_start */
+
+#ifdef DEBUG_IMEM
+static void dump_imem_list(void)
+{
+	struct imem_list *imem;
+
+	printk("*** dump_imem_list 0x%x ***\n", (u32)imem_list_head);
+	imem = imem_list_head;
+	while (imem) {
+		printk("imem=0x%x phys_start=0x%x phys_end=0x%x next=0x%x\n", (u32)imem, imem->phys_start, imem->phys_end, (u32)imem->next);
+		imem = imem->next;
+	}
+}
+#endif
+
+/* allocate 2^order pages inside the 4MB memory */
+static int imem_alloc(unsigned int order)
+{
+	int alloc_ok = 0;
+	unsigned int start, end;
+	unsigned int size = (1 << order) * PAGE_SIZE;
+	struct imem_list *imem, *imemn, *imemp;
+
+	allocated_phys_addr = 0;
+
+	start = jz_imem_base;
+	end = start + (1 << IMEM_MAX_ORDER) * PAGE_SIZE;
+
+	imem = imem_list_head;
+	while (imem) {
+		if ((imem->phys_start - start) >= size) {
+			/* we got a valid address range */
+			alloc_ok = 1;
+			break;
+		}
+
+		start = imem->phys_end + 1;
+		imem = imem->next;
+	}
+
+	if (!alloc_ok) {
+		if ((end - start) >= size)
+			alloc_ok = 1;
+	}
+
+	if (alloc_ok) {
+		end = start + size - 1;
+		allocated_phys_addr = start;
+
+		/* add to imem_list, up sorted by phys_start */
+		imemn = kmalloc(sizeof(struct imem_list), GFP_KERNEL);
+		if (!imemn) {
+			return -ENOMEM;
+		}
+		imemn->phys_start = start;
+		imemn->phys_end = end;
+		imemn->next = NULL;
+
+		if (!imem_list_head)
+			imem_list_head = imemn;
+		else {
+			imem = imemp = imem_list_head;
+			while (imem) {
+				if (start < imem->phys_start) {
+					break;
+				}
+
+				imemp = imem;
+				imem = imem->next;
+			}
+
+			if (imem == imem_list_head) {
+				imem_list_head = imemn;
+				imemn->next = imem;
+			}
+			else {
+				imemn->next = imemp->next;
+				imemp->next = imemn;
+			}
+		}
+	}
+
+#ifdef DEBUG_IMEM
+	dump_imem_list();
+#endif
+	return 0;
+}
+
+static void imem_free(unsigned int phys_addr)
+{
+	struct imem_list *imem, *imemp;
+
+	imem = imemp = imem_list_head;
+	while (imem) {
+		if (phys_addr == imem->phys_start) {
+			if (imem == imem_list_head) {
+				imem_list_head = imem->next;
+			}
+			else {
+				imemp->next = imem->next;
+			}
+
+			kfree(imem);
+			break;
+		}
+
+		imemp = imem;
+		imem = imem->next;
+	}
+
+#ifdef DEBUG_IMEM
+	dump_imem_list();
+#endif
+}
+
+static void imem_free_all(void)
+{
+	struct imem_list *imem;
+
+	imem = imem_list_head;
+	while (imem) {
+		kfree(imem);
+		imem = imem->next;
+	}
+
+	imem_list_head = NULL;
+
+	allocated_phys_addr = 0;
+
+#ifdef DEBUG_IMEM
+	dump_imem_list();
+#endif
+}
+
+/*
+ * Return the allocated buffer address and the max order of free buffer
+ */
+static int imem_read_proc(char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	unsigned int start_addr, end_addr, max_order, max_size;
+	struct imem_list *imem;
+
+	unsigned int *tmp = (unsigned int *)(page + len);
+
+	start_addr = jz_imem_base;
+	end_addr = start_addr + (1 << IMEM_MAX_ORDER) * PAGE_SIZE;
+
+	if (!imem_list_head)
+		max_size = end_addr - start_addr;
+	else {
+		max_size = 0;
+		imem = imem_list_head;
+		while (imem) {
+			if (max_size < (imem->phys_start - start_addr))
+				max_size = imem->phys_start - start_addr;
+
+			start_addr = imem->phys_end + 1;
+			imem = imem->next;
+		}
+
+		if (max_size < (end_addr - start_addr))
+			max_size = end_addr - start_addr;
+	}
+
+	if (max_size > 0) {
+		max_order = get_order(max_size);
+		if (((1 << max_order) * PAGE_SIZE) > max_size)
+		    max_order--;
+	}
+	else {
+		max_order = 0xffffffff;	/* No any free buffer */
+	}
+
+	*tmp++ = allocated_phys_addr;	/* address allocated by 'echo n > /proc/jz/imem' */
+	*tmp = max_order;		/* max order of current free buffers */
+
+	len += 2 * sizeof(unsigned int);
+
+	return len;
+}
+
+static int imem_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	unsigned int val;
+
+	val = simple_strtoul(buffer, 0, 16);
+
+	if (val == 0xff) {
+		/* free all memory */
+		imem_free_all();
+		ipu_del_wired_entry();
+	}
+	else if ((val >= 0) && (val <= IMEM_MAX_ORDER)) {
+		/* allocate 2^val pages */
+		imem_alloc(val);
+	}
+	else {
+		/* free buffer which phys_addr is val */
+		imem_free(val);
+	}
+
+	return count;
+}
+
+#endif /* CONFIG_RESERVE_IPU_MEM */
+
+/*
+ * /proc/jz/xxx entry
+ *
+ */
+static int __init jz_proc_init(void)
+{
+	struct proc_dir_entry *res;
+#ifdef CONFIG_RESERVE_IPU_MEM
+	unsigned int virt_addr, i;
+#endif
+
+	proc_jz_root = proc_mkdir("jz", 0);
+
+	/* External Memory Controller */
+	res = create_proc_entry("emc", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = emc_read_proc;
+		res->write_proc = NULL;
+		res->data = NULL;
+	}
+
+	/* Power Management Controller */
+	res = create_proc_entry("pmc", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = pmc_read_proc;
+		res->write_proc = pmc_write_proc;
+		res->data = NULL;
+	}
+
+	/* Clock Generation Module */
+	res = create_proc_entry("cgm", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = cgm_read_proc;
+		res->write_proc = cgm_write_proc;
+		res->data = NULL;
+	}
+
+	/* udc hotplug */
+	res = create_proc_entry("udc", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = udc_read_proc;
+		res->write_proc = NULL;
+		res->data = NULL;
+	}
+
+	/* mmc hotplug */
+	res = create_proc_entry("mmc", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = mmc_read_proc;
+		res->write_proc = NULL;
+		res->data = NULL;
+	}
+
+#ifdef CONFIG_RESERVE_IPU_MEM
+	/* Image process unit */
+	res = create_proc_entry("ipu", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = ipu_read_proc;
+		res->write_proc = ipu_write_proc;
+		res->data = NULL;
+	}
+
+	/*
+	 * Reserve a 4MB memory for IPU on JZ4740.
+	 */
+	jz_imem_base = (unsigned int)__get_free_pages(GFP_KERNEL, IMEM_MAX_ORDER);
+	if (jz_imem_base) {
+		/* imem (IPU memory management) */
+		res = create_proc_entry("imem", 0644, proc_jz_root);
+		if (res) {
+			res->read_proc = imem_read_proc;
+			res->write_proc = imem_write_proc;
+			res->data = NULL;
+		}
+
+		/* Set page reserved */
+		virt_addr = jz_imem_base;
+		for (i = 0; i < (1 << IMEM_MAX_ORDER); i++) {
+			SetPageReserved(virt_to_page((void *)virt_addr));
+			virt_addr += PAGE_SIZE;
+		}
+
+		/* Convert to physical address */
+		jz_imem_base = virt_to_phys((void *)jz_imem_base);
+
+		printk("Total %dMB memory at 0x%x was reserved for IPU\n",
+		       (unsigned int)((1 << IMEM_MAX_ORDER) * PAGE_SIZE)/1000000, jz_imem_base);
+	}
+#endif
+
+	return 0;
+}
+
+__initcall(jz_proc_init);
--- linux-2.6.24.7.old/arch/mips/jz4740/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/prom.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,198 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *    PROM library initialisation code, supports YAMON and U-Boot.
+ *
+ * Copyright 2000, 2001, 2006 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	ppopov@mvista.com or source@mvista.com
+ *
+ * This file was derived from Carsten Langgaard's
+ * arch/mips/mips-boards/xx files.
+ *
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+#include <asm/jzsoc.h>
+
+/* #define DEBUG_CMDLINE */
+
+int prom_argc;
+char **prom_argv, **prom_envp;
+
+char * prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
+
+void  prom_init_cmdline(void)
+{
+	char *cp;
+	int actr;
+
+	actr = 1; /* Always ignore argv[0] */
+
+	cp = &(arcs_cmdline[0]);
+	while(actr < prom_argc) {
+	        strcpy(cp, prom_argv[actr]);
+		cp += strlen(prom_argv[actr]);
+		*cp++ = ' ';
+		actr++;
+	}
+	if (cp != &(arcs_cmdline[0])) /* get rid of trailing space */
+		--cp;
+	if (prom_argc > 1)
+		*cp = '\0';
+
+}
+
+
+char *prom_getenv(char *envname)
+{
+#if 0
+	/*
+	 * Return a pointer to the given environment variable.
+	 * YAMON uses "name", "value" pairs, while U-Boot uses "name=value".
+	 */
+
+	char **env = prom_envp;
+	int i = strlen(envname);
+	int yamon = (*env && strchr(*env, '=') == NULL);
+
+	while (*env) {
+		if (yamon) {
+			if (strcmp(envname, *env++) == 0)
+				return *env;
+		} else {
+			if (strncmp(envname, *env, i) == 0 && (*env)[i] == '=')
+				return *env + i + 1;
+		}
+		env++;
+	}
+#endif
+	return NULL;
+}
+
+inline unsigned char str2hexnum(unsigned char c)
+{
+	if(c >= '0' && c <= '9')
+		return c - '0';
+	if(c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	if(c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	return 0; /* foo */
+}
+
+inline void str2eaddr(unsigned char *ea, unsigned char *str)
+{
+	int i;
+
+	for(i = 0; i < 6; i++) {
+		unsigned char num;
+
+		if((*str == '.') || (*str == ':'))
+			str++;
+		num = str2hexnum(*str++) << 4;
+		num |= (str2hexnum(*str++));
+		ea[i] = num;
+	}
+}
+
+int get_ethernet_addr(char *ethernet_addr)
+{
+        char *ethaddr_str;
+
+        ethaddr_str = prom_getenv("ethaddr");
+	if (!ethaddr_str) {
+	        printk("ethaddr not set in boot prom\n");
+		return -1;
+	}
+	str2eaddr(ethernet_addr, ethaddr_str);
+
+#if 0
+	{
+		int i;
+
+	printk("get_ethernet_addr: ");
+	for (i=0; i<5; i++)
+		printk("%02x:", (unsigned char)*(ethernet_addr+i));
+	printk("%02x\n", *(ethernet_addr+i));
+	}
+#endif
+
+	return 0;
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
+
+void __init prom_init(void)
+{
+	unsigned char *memsize_str;
+	unsigned long memsize;
+
+	prom_argc = (int) fw_arg0;
+	prom_argv = (char **) fw_arg1;
+	prom_envp = (char **) fw_arg2;
+
+	mips_machtype = MACH_INGENIC_JZ4740;
+
+	prom_init_cmdline();
+	memsize_str = prom_getenv("memsize");
+	if (!memsize_str) {
+		memsize = 0x04000000;
+	} else {
+		memsize = simple_strtol(memsize_str, NULL, 0);
+	}
+	add_memory_region(0, memsize, BOOT_MEM_RAM);
+}
+
+/* used by early printk */
+void prom_putchar(char c)
+{
+	volatile u8 *uart_lsr = (volatile u8 *)(UART0_BASE + OFF_LSR);
+	volatile u8 *uart_tdr = (volatile u8 *)(UART0_BASE + OFF_TDR);
+
+	/* Wait for fifo to shift out some bytes */
+	while ( !((*uart_lsr & (UARTLSR_TDRQ | UARTLSR_TEMT)) == 0x60) );
+
+	*uart_tdr = (u8)c;
+}
+
+const char *get_system_type(void)
+{
+	return "JZ4740";
+}
+
+EXPORT_SYMBOL(prom_getcmdline);
+EXPORT_SYMBOL(get_ethernet_addr);
+EXPORT_SYMBOL(str2eaddr);
--- linux-2.6.24.7.old/arch/mips/jz4740/reset.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/reset.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,46 @@
+/*
+ * linux/arch/mips/jz4740/reset.c
+ *
+ * JZ4740 reset routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <yliu@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/reboot.h>
+#include <asm/system.h>
+#include <asm/jzsoc.h>
+
+void jz_restart(char *command)
+{
+	printk("Restarting after 4 ms\n");
+	REG_WDT_TCSR = WDT_TCSR_PRESCALE4 | WDT_TCSR_EXT_EN;
+	REG_WDT_TCNT = 0;
+	REG_WDT_TDR = JZ_EXTAL/1000;   /* reset after 4ms */
+	REG_TCU_TSCR = TCU_TSSR_WDTSC; /* enable wdt clock */
+	REG_WDT_TCER = WDT_TCER_TCEN;  /* wdt start */
+	while (1);
+}
+
+void jz_halt(void)
+{
+	printk(KERN_NOTICE "\n** You can safely turn off the power\n");
+
+	while (1)
+		__asm__(".set\tmips3\n\t"
+	                "wait\n\t"
+			".set\tmips0");
+}
+
+void jz_power_off(void)
+{
+	jz_halt();
+}
--- linux-2.6.24.7.old/arch/mips/jz4740/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/setup.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,182 @@
+/*
+ * linux/arch/mips/jz4740/common/setup.c
+ *
+ * JZ4740 common setup routines.
+ *
+ * Copyright (C) 2006 Ingenic Semiconductor Inc.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/ioport.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_8250.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/pgtable.h>
+#include <asm/time.h>
+#include <asm/jzsoc.h>
+
+#ifdef CONFIG_PC_KEYB
+#include <asm/keyboard.h>
+#endif
+
+jz_clocks_t jz_clocks;
+
+extern char * __init prom_getcmdline(void);
+extern void __init jz_board_setup(void);
+extern void jz_restart(char *);
+extern void jz_halt(void);
+extern void jz_power_off(void);
+extern void jz_time_init(void);
+
+static void __init sysclocks_setup(void)
+{
+#ifndef CONFIG_MIPS_JZ_EMURUS /* FPGA */
+	jz_clocks.cclk = __cpm_get_cclk();
+	jz_clocks.hclk = __cpm_get_hclk();
+	jz_clocks.pclk = __cpm_get_pclk();
+	jz_clocks.mclk = __cpm_get_mclk();
+	jz_clocks.lcdclk = __cpm_get_lcdclk();
+	jz_clocks.pixclk = __cpm_get_pixclk();
+	jz_clocks.i2sclk = __cpm_get_i2sclk();
+	jz_clocks.usbclk = __cpm_get_usbclk();
+	jz_clocks.mscclk = __cpm_get_mscclk();
+	jz_clocks.extalclk = __cpm_get_extalclk();
+	jz_clocks.rtcclk = __cpm_get_rtcclk();
+#else
+
+#define FPGACLK 8000000
+
+	jz_clocks.cclk = FPGACLK;
+	jz_clocks.hclk = FPGACLK;
+	jz_clocks.pclk = FPGACLK;
+	jz_clocks.mclk = FPGACLK;
+	jz_clocks.lcdclk = FPGACLK;
+	jz_clocks.pixclk = FPGACLK;
+	jz_clocks.i2sclk = FPGACLK;
+	jz_clocks.usbclk = FPGACLK;
+	jz_clocks.mscclk = FPGACLK;
+	jz_clocks.extalclk = FPGACLK;
+	jz_clocks.rtcclk = FPGACLK;
+#endif
+
+	printk("CPU clock: %dMHz, System clock: %dMHz, Peripheral clock: %dMHz, Memory clock: %dMHz\n",
+	       (jz_clocks.cclk + 500000) / 1000000,
+	       (jz_clocks.hclk + 500000) / 1000000,
+	       (jz_clocks.pclk + 500000) / 1000000,
+	       (jz_clocks.mclk + 500000) / 1000000);
+}
+
+static void __init soc_cpm_setup(void)
+{
+	/* Start all module clocks
+	 */
+	__cpm_start_all();
+
+	/* Enable CKO to external memory */
+	__cpm_enable_cko();
+
+	/* CPU enters IDLE mode when executing 'wait' instruction */
+	__cpm_idle_mode();
+
+	/* Setup system clocks */
+	sysclocks_setup();
+}
+
+static void __init soc_harb_setup(void)
+{
+//	__harb_set_priority(0x00);  /* CIM>LCD>DMA>ETH>PCI>USB>CBB */
+//	__harb_set_priority(0x03);  /* LCD>CIM>DMA>ETH>PCI>USB>CBB */
+//	__harb_set_priority(0x0a);  /* ETH>LCD>CIM>DMA>PCI>USB>CBB */
+}
+
+static void __init soc_emc_setup(void)
+{
+}
+
+static void __init soc_dmac_setup(void)
+{
+	__dmac_enable_module();
+}
+
+static void __init jz_soc_setup(void)
+{
+	soc_cpm_setup();
+	soc_harb_setup();
+	soc_emc_setup();
+	soc_dmac_setup();
+}
+
+static void __init jz_serial_setup(void)
+{
+#ifdef CONFIG_SERIAL_8250
+	struct uart_port s;
+	REG8(UART0_FCR) |= UARTFCR_UUE; /* enable UART module */
+	memset(&s, 0, sizeof(s));
+	s.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST;
+	s.iotype = SERIAL_IO_MEM;
+	s.regshift = 2;
+	s.uartclk = jz_clocks.extalclk ;
+
+	s.line = 0;
+	s.membase = (u8 *)UART0_BASE;
+	s.irq = IRQ_UART0;
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial ttyS0 setup failed!\n");
+	}
+
+	s.line = 1;
+	s.membase = (u8 *)UART1_BASE;
+	s.irq = IRQ_UART1;
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial ttyS1 setup failed!\n");
+	}
+#endif
+}
+
+void __init plat_mem_setup(void)
+{
+	char *argptr;
+
+	argptr = prom_getcmdline();
+
+	/* IO/MEM resources. Which will be the addtion value in `inX' and
+	 * `outX' macros defined in asm/io.h */
+	set_io_port_base(0);
+	ioport_resource.start	= 0x00000000;
+	ioport_resource.end	= 0xffffffff;
+	iomem_resource.start	= 0x00000000;
+	iomem_resource.end	= 0xffffffff;
+
+	_machine_restart = jz_restart;
+	_machine_halt = jz_halt;
+	pm_power_off = jz_power_off;
+
+	jz_soc_setup();
+	jz_serial_setup();
+	jz_board_setup();
+}
+
--- linux-2.6.24.7.old/arch/mips/jz4740/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4740/time.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,158 @@
+/*
+ * linux/arch/mips/jz4740/time.c
+ *
+ * Setting up the clock on the JZ4740 boards.
+ *
+ * Copyright (C) 2008 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/clockchips.h>
+
+#include <asm/time.h>
+#include <asm/jzsoc.h>
+
+/* This is for machines which generate the exact clock. */
+
+#define JZ_TIMER_CHAN  0
+#define JZ_TIMER_IRQ  IRQ_TCU0
+
+#define JZ_TIMER_CLOCK (JZ_EXTAL>>4) /* Jz timer clock frequency */
+
+static struct clocksource clocksource_jz; /* Jz clock source */
+static struct clock_event_device jz_clockevent_device; /* Jz clock event */
+
+void (*jz_timer_callback)(void);
+
+static irqreturn_t jz_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *cd = dev_id;
+
+	REG_TCU_TFCR = 1 << JZ_TIMER_CHAN; /* ACK timer */
+
+	if (jz_timer_callback)
+		jz_timer_callback();
+
+	cd->event_handler(cd);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction jz_irqaction = {
+	.handler	= jz_timer_interrupt,
+	.flags		= IRQF_DISABLED | IRQF_PERCPU | IRQF_TIMER,
+	.name		= "jz-timerirq",
+};
+
+
+cycle_t jz_get_cycles(void)
+{
+	/* convert jiffes to jz timer cycles */
+	return (cycle_t)( jiffies*((JZ_TIMER_CLOCK)/HZ) + REG_TCU_TCNT(JZ_TIMER_CHAN));
+}
+
+static struct clocksource clocksource_jz = {
+	.name 		= "jz_clocksource",
+	.rating		= 300,
+	.read		= jz_get_cycles,
+	.mask		= 0xFFFF,
+	.shift 		= 10,
+	.flags		= CLOCK_SOURCE_WATCHDOG,
+};
+
+static int __init jz_clocksource_init(void)
+{
+	clocksource_jz.mult = clocksource_hz2mult(JZ_TIMER_CLOCK, clocksource_jz.shift);
+	clocksource_register(&clocksource_jz);
+	return 0;
+}
+
+static int jz_set_next_event(unsigned long evt,
+				  struct clock_event_device *unused)
+{
+	return 0;
+}
+
+static void jz_set_mode(enum clock_event_mode mode,
+			struct clock_event_device *evt)
+{
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+                break;
+        case CLOCK_EVT_MODE_ONESHOT:
+        case CLOCK_EVT_MODE_UNUSED:
+        case CLOCK_EVT_MODE_SHUTDOWN:
+                break;
+        case CLOCK_EVT_MODE_RESUME:
+                break;
+        }
+}
+
+static struct clock_event_device jz_clockevent_device = {
+	.name		= "jz-clockenvent",
+	.features	= CLOCK_EVT_FEAT_PERIODIC,
+//	.features	= CLOCK_EVT_FEAT_ONESHOT, /* Jz4740 not support dynamic clock now */
+
+	/* .mult, .shift, .max_delta_ns and .min_delta_ns left uninitialized */
+	.rating		= 300,
+	.irq		= JZ_TIMER_IRQ,
+	.set_mode	= jz_set_mode,
+	.set_next_event	= jz_set_next_event,
+};
+
+static void __init jz_clockevent_init(void)
+{
+	struct clock_event_device *cd = &jz_clockevent_device;
+	unsigned int cpu = smp_processor_id();
+
+	cd->cpumask = cpumask_of_cpu(cpu);
+	clockevents_register_device(cd);
+}
+
+static void __init jz_timer_setup(void)
+{
+	jz_clocksource_init();	/* init jz clock source */
+	jz_clockevent_init();	/* init jz clock event */
+
+	/*
+	 * Make irqs happen for the system timer
+	 */
+	jz_irqaction.dev_id = &jz_clockevent_device;
+	setup_irq(JZ_TIMER_IRQ, &jz_irqaction);
+}
+
+
+void __init plat_time_init(void)
+{
+	unsigned int latch;
+	/* Init timer */
+	latch = ( JZ_TIMER_CLOCK + (HZ>>1)) / HZ;
+
+	REG_TCU_TCSR(JZ_TIMER_CHAN) = TCU_TCSR_PRESCALE16 | TCU_TCSR_EXT_EN;
+	REG_TCU_TCNT(JZ_TIMER_CHAN) = 0;
+	REG_TCU_TDHR(JZ_TIMER_CHAN) = 0;
+	REG_TCU_TDFR(JZ_TIMER_CHAN) = latch;
+
+	REG_TCU_TMSR = (1 << (JZ_TIMER_CHAN + 16)); /* mask half irq */
+	REG_TCU_TMCR = (1 << JZ_TIMER_CHAN); /* unmask full irq */
+	REG_TCU_TSCR = (1 << JZ_TIMER_CHAN); /* enable timer clock */
+	REG_TCU_TESR = (1 << JZ_TIMER_CHAN); /* start counting up */
+
+	jz_timer_setup();
+}
--- linux-2.6.24.7.old/arch/mips/jz4750/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750/Makefile	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,23 @@
+#
+# Makefile for the Ingenic JZ4750.
+#
+
+# Object file lists.
+
+obj-y += prom.o irq.o time.o reset.o setup.o dma.o \
+	platform.o i2c.o
+
+obj-$(CONFIG_PROC_FS)		+= proc.o
+
+# board specific support
+
+obj-$(CONFIG_JZ4750_FUWA)	+= board-fuwa.o
+obj-$(CONFIG_JZ4750_APUS)	+= board-apus.o
+
+# PM support
+
+obj-$(CONFIG_PM_LEGACY)         +=pm.o
+
+# CPU Frequency scaling support
+
+obj-$(CONFIG_CPU_FREQ_JZ)       +=cpufreq.o
--- linux-2.6.24.7.old/arch/mips/jz4750/board-apus.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750/board-apus.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+ * linux/arch/mips/jz4750/board-apus.c
+ *
+ * JZ4750 APUS board setup routines.
+ *
+ * Copyright (c) 2006-2008  Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+
+#include <asm/jzsoc.h>
+
+extern void (*jz_timer_callback)(void);
+
+static void dancing(void)
+{
+}
+
+static void apus_timer_callback(void)
+{
+	static unsigned long count = 0;
+
+	if ((++count) % 50 == 0) {
+		dancing();
+		count = 0;
+	}
+}
+
+static void __init board_cpm_setup(void)
+{
+	/* Stop unused module clocks here.
+	 * We have started all module clocks at arch/mips/jz4750/setup.c.
+	 */
+}
+
+static void __init board_gpio_setup(void)
+{
+	__gpio_as_pcm();
+}
+
+void __init jz_board_setup(void)
+{
+	printk("JZ4750 APUS board setup\n");
+
+	board_cpm_setup();
+	board_gpio_setup();
+
+	jz_timer_callback = apus_timer_callback;
+}
--- linux-2.6.24.7.old/arch/mips/jz4750/board-fuwa.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750/board-fuwa.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,105 @@
+/*
+ * linux/arch/mips/jz4750/board-fuwa.c
+ *
+ * JZ4750 FUWA board setup routines.
+ *
+ * Copyright (c) 2006-2008  Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+
+#include <asm/jzsoc.h>
+
+extern void (*jz_timer_callback)(void);
+
+static void dancing(void)
+{
+	static unsigned char slash[] = "\\|/-";
+//	static volatile unsigned char *p = (unsigned char *)0xb6000058;
+	static volatile unsigned char *p = (unsigned char *)0xb6000016;
+	static unsigned int count = 0;
+	*p = slash[count++];
+	count &= 3;
+}
+
+static void fuwa_timer_callback(void)
+{
+	static unsigned long count = 0;
+
+	if ((++count) % 50 == 0) {
+		dancing();
+		count = 0;
+	}
+}
+
+static void __init board_cpm_setup(void)
+{
+	/* Stop unused module clocks here.
+	 * We have started all module clocks at arch/mips/jz4750/setup.c.
+	 */
+}
+
+static void __init board_gpio_setup(void)
+{
+	/*
+	 * Initialize SDRAM pins
+	 */
+
+	/* PORT A: D0 ~ D31 */
+	REG_GPIO_PXFUNS(0) = 0xffffffff;
+	REG_GPIO_PXSELC(0) = 0xffffffff;
+
+	/* PORT B: A0 ~ A16, DCS#, RAS#, CAS#, CKE#, RDWE#, CKO#, WE0# */
+	REG_GPIO_PXFUNS(1) = 0x81f9ffff;
+	REG_GPIO_PXSELC(1) = 0x81f9ffff;
+
+	/* PORT C: WE1#, WE2#, WE3# */
+	REG_GPIO_PXFUNS(2) = 0x07000000;
+	REG_GPIO_PXSELC(2) = 0x07000000;
+
+
+	/*
+	 * Initialize UART0 pins
+	 */
+
+	/* PORT D: TXD/RXD */
+	REG_GPIO_PXFUNS(3) = 0x06000000;
+	REG_GPIO_PXSELS(3) = 0x06000000;
+
+
+	/*
+	 * Initialize LED pins
+	 */
+	__gpio_as_lcd_18bit();
+
+	/* CS2# */
+	REG_GPIO_PXFUNS(1) = 0x04000000;
+	REG_GPIO_PXSELC(1) = 0x04000000;
+
+	__gpio_as_pcm();
+}
+
+void __init jz_board_setup(void)
+{
+	printk("JZ4750 FUWA board setup\n");
+
+	board_cpm_setup();
+	board_gpio_setup();
+
+	jz_timer_callback = fuwa_timer_callback;
+}
--- linux-2.6.24.7.old/arch/mips/jz4750/board-slt50.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750/board-slt50.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+ * linux/arch/mips/jz4750/board-apus.c
+ *
+ * JZ4750 APUS board setup routines.
+ *
+ * Copyright (c) 2006-2008  Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+
+#include <asm/jzsoc.h>
+
+extern void (*jz_timer_callback)(void);
+
+static void dancing(void)
+{
+}
+
+static void apus_timer_callback(void)
+{
+	static unsigned long count = 0;
+
+	if ((++count) % 50 == 0) {
+		dancing();
+		count = 0;
+	}
+}
+
+static void __init board_cpm_setup(void)
+{
+	/* Stop unused module clocks here.
+	 * We have started all module clocks at arch/mips/jz4750/setup.c.
+	 */
+}
+
+static void __init board_gpio_setup(void)
+{
+	__gpio_as_pcm();
+}
+
+void __init jz_board_setup(void)
+{
+	printk("JZ4750 SLT_50 board setup\n");
+
+	board_cpm_setup();
+	board_gpio_setup();
+
+	jz_timer_callback = apus_timer_callback;
+}
--- linux-2.6.24.7.old/arch/mips/jz4750/cpufreq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750/cpufreq.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,601 @@
+/*
+ * linux/arch/mips/jz4750/cpufreq.c
+ *
+ * cpufreq driver for JZ4750
+ *
+ * Copyright (c) 2006-2008  Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <linux/cpufreq.h>
+
+#include <asm/jzsoc.h>
+#include <asm/processor.h>
+
+#define dprintk(msg...) cpufreq_debug_printk(CPUFREQ_DEBUG_DRIVER, \
+						"cpufreq-jz4750", msg)
+
+#undef CHANGE_PLL
+
+#define PLL_UNCHANGED 0
+#define PLL_GOES_UP   1
+#define PLL_GOES_DOWN 2
+
+#define PLL_WAIT_500NS (500*(__cpm_get_cclk()/1000000000))
+
+/* Saved the boot-time parameters */
+static struct {
+	/* SDRAM parameters */
+	unsigned int mclk;  /* memory clock, KHz */
+	unsigned int tras;  /* RAS pulse width, cycles of mclk */
+	unsigned int rcd;   /* RAS to CAS Delay, cycles of mclk */
+	unsigned int tpc;   /* RAS Precharge time, cycles of mclk */
+	unsigned int trwl;  /* Write Precharge Time, cycles of mclk */
+	unsigned int trc;   /* RAS Cycle Time, cycles of mclk */
+	unsigned int rtcor; /* Refresh Time Constant */
+	unsigned int sdram_initialized;
+
+	/* LCD parameters */
+	unsigned int lcd_clk;    /* LCD clock, Hz */
+	unsigned int lcdpix_clk; /* LCD Pixel clock, Hz */
+	unsigned int lcd_clks_initialized;
+} boot_config;
+
+struct jz4750_freq_percpu_info {
+	struct cpufreq_frequency_table table[7];
+};
+
+static struct jz4750_freq_percpu_info jz4750_freq_table;
+
+/*
+ * This contains the registers value for an operating point.
+ * If only part of a register needs to change then there is
+ * a mask value for that register.
+ * When going to a new operating point the current register
+ * value is ANDed with the ~mask and ORed with the new value.
+ */
+struct dpm_regs {
+	u32 cpccr;        /* Clock Freq Control Register */
+	u32 cpccr_mask;   /* Clock Freq Control Register mask */
+	u32 cppcr;        /* PLL1 Control Register */
+	u32 cppcr_mask;   /* PLL1 Control Register mask */
+	u32 pll_up_flag;  /* New PLL freq is higher than current or not */
+};
+
+extern jz_clocks_t jz_clocks;
+
+static void jz_update_clocks(void)
+{
+	/* Next clocks must be updated if we have changed
+	 * the PLL or divisors.
+	 */
+	jz_clocks.cclk = __cpm_get_cclk();
+	jz_clocks.hclk = __cpm_get_hclk();
+	jz_clocks.mclk = __cpm_get_mclk();
+	jz_clocks.pclk = __cpm_get_pclk();
+	jz_clocks.lcdclk = __cpm_get_lcdclk();
+	jz_clocks.pixclk = __cpm_get_pixclk();
+	jz_clocks.i2sclk = __cpm_get_i2sclk();
+	jz_clocks.usbclk = __cpm_get_usbclk();
+	jz_clocks.mscclk = __cpm_get_mscclk(0);
+}
+
+static void
+jz_init_boot_config(void)
+{
+	if (!boot_config.lcd_clks_initialized) {
+		/* the first time to scale pll */
+		boot_config.lcd_clk = __cpm_get_lcdclk();
+		boot_config.lcdpix_clk = __cpm_get_pixclk();
+		boot_config.lcd_clks_initialized = 1;
+	}
+
+	if (!boot_config.sdram_initialized) {
+		/* the first time to scale frequencies */
+		unsigned int dmcr, rtcor;
+		unsigned int tras, rcd, tpc, trwl, trc;
+
+		dmcr = REG_EMC_DMCR;
+		rtcor = REG_EMC_RTCOR;
+
+		tras = (dmcr >> 13) & 0x7;
+		rcd = (dmcr >> 11) & 0x3;
+		tpc = (dmcr >> 8) & 0x7;
+		trwl = (dmcr >> 5) & 0x3;
+		trc = (dmcr >> 2) & 0x7;
+
+		boot_config.mclk = __cpm_get_mclk() / 1000;
+		boot_config.tras = tras + 4;
+		boot_config.rcd = rcd + 1;
+		boot_config.tpc = tpc + 1;
+		boot_config.trwl = trwl + 1;
+		boot_config.trc = trc * 2 + 1;
+		boot_config.rtcor = rtcor;
+
+		boot_config.sdram_initialized = 1;
+	}
+}
+
+static void jz_update_dram_rtcor(unsigned int new_mclk)
+{
+	unsigned int rtcor;
+
+	new_mclk /= 1000;
+	rtcor = boot_config.rtcor * new_mclk / boot_config.mclk;
+	rtcor--;
+
+	if (rtcor < 1) rtcor = 1;
+	if (rtcor > 255) rtcor = 255;
+
+	REG_EMC_RTCOR = rtcor;
+	REG_EMC_RTCNT = rtcor;
+}
+
+static void jz_update_dram_dmcr(unsigned int new_mclk)
+{
+	unsigned int dmcr;
+	unsigned int tras, rcd, tpc, trwl, trc;
+	unsigned int valid_time, new_time; /* ns */
+
+	new_mclk /= 1000;
+	tras = boot_config.tras * new_mclk / boot_config.mclk;
+	rcd = boot_config.rcd * new_mclk / boot_config.mclk;
+	tpc = boot_config.tpc * new_mclk / boot_config.mclk;
+	trwl = boot_config.trwl * new_mclk / boot_config.mclk;
+	trc = boot_config.trc * new_mclk / boot_config.mclk;
+
+	/* Validation checking */
+	valid_time = (boot_config.tras * 1000000) / boot_config.mclk;
+	new_time = (tras * 1000000) / new_mclk;
+	if (new_time < valid_time) tras += 1;
+
+	valid_time = (boot_config.rcd * 1000000) / boot_config.mclk;
+	new_time = (rcd * 1000000) / new_mclk;
+	if (new_time < valid_time) rcd += 1;
+
+	valid_time = (boot_config.tpc * 1000000) / boot_config.mclk;
+	new_time = (tpc * 1000000) / new_mclk;
+	if (new_time < valid_time) tpc += 1;
+
+	valid_time = (boot_config.trwl * 1000000) / boot_config.mclk;
+	new_time = (trwl * 1000000) / new_mclk;
+	if (new_time < valid_time) trwl += 1;
+
+	valid_time = (boot_config.trc * 1000000) / boot_config.mclk;
+	new_time = (trc * 1000000) / new_mclk;
+	if (new_time < valid_time) trc += 2;
+
+	tras = (tras < 4) ? 4: tras;
+	tras = (tras > 11) ? 11: tras;
+	tras -= 4;
+
+	rcd = (rcd < 1) ? 1: rcd;
+	rcd = (rcd > 4) ? 4: rcd;
+	rcd -= 1;
+
+	tpc = (tpc < 1) ? 1: tpc;
+	tpc = (tpc > 8) ? 8: tpc;
+	tpc -= 1;
+
+	trwl = (trwl < 1) ? 1: trwl;
+	trwl = (trwl > 4) ? 4: trwl;
+	trwl -= 1;
+
+	trc = (trc < 1) ? 1: trc;
+	trc = (trc > 15) ? 15: trc;
+	trc /= 2;
+
+	dmcr = REG_EMC_DMCR;
+
+	dmcr &= ~(EMC_DMCR_TRAS_MASK | EMC_DMCR_RCD_MASK | EMC_DMCR_TPC_MASK | EMC_DMCR_TRWL_MASK | EMC_DMCR_TRC_MASK);
+	dmcr |= ((tras << EMC_DMCR_TRAS_BIT) | (rcd << EMC_DMCR_RCD_BIT) | (tpc << EMC_DMCR_TPC_BIT) | (trwl << EMC_DMCR_TRWL_BIT) | (trc << EMC_DMCR_TRC_BIT));
+
+	REG_EMC_DMCR = dmcr;
+}
+
+static void jz_update_dram_prev(unsigned int cur_mclk, unsigned int new_mclk)
+{
+	/* No risk, no fun: run with interrupts on! */
+	if (new_mclk > cur_mclk) {
+		/* We're going FASTER, so first update TRAS, RCD, TPC, TRWL
+		 * and TRC of DMCR before changing the frequency.
+		 */
+		jz_update_dram_dmcr(new_mclk);
+	} else {
+		/* We're going SLOWER: first update RTCOR value
+		 * before changing the frequency.
+		 */
+		jz_update_dram_rtcor(new_mclk);
+	}
+}
+
+static void jz_update_dram_post(unsigned int cur_mclk, unsigned int new_mclk)
+{
+	/* No risk, no fun: run with interrupts on! */
+	if (new_mclk > cur_mclk) {
+		/* We're going FASTER, so update RTCOR
+		 * after changing the frequency
+		 */
+		jz_update_dram_rtcor(new_mclk);
+	} else {
+		/* We're going SLOWER: so update TRAS, RCD, TPC, TRWL
+		 * and TRC of DMCR after changing the frequency.
+		 */
+		jz_update_dram_dmcr(new_mclk);
+	}
+}
+
+static void jz_scale_divisors(struct dpm_regs *regs)
+{
+	unsigned int cpccr;
+	unsigned int cur_mclk, new_mclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned int tmp = 0, wait = PLL_WAIT_500NS;
+
+	cpccr = REG_CPM_CPCCR;
+	cpccr &= ~((unsigned long)regs->cpccr_mask);
+	cpccr |= regs->cpccr;
+	cpccr |= CPM_CPCCR_CE;       /* update immediately */
+
+	cur_mclk = __cpm_get_mclk();
+	new_mclk = __cpm_get_pllout() / div[(cpccr & CPM_CPCCR_MDIV_MASK) >> CPM_CPCCR_MDIV_BIT];
+
+	/* Update some DRAM parameters before changing frequency */
+	jz_update_dram_prev(cur_mclk, new_mclk);
+
+	/* update register to change the clocks.
+	 * align this code to a cache line.
+	 */
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".align 5\n"
+		"sw %1,0(%0)\n\t"
+		"li %3,0\n\t"
+		"1:\n\t"
+		"bne %3,%2,1b\n\t"
+		"addi %3, 1\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set reorder\n\t"
+		:
+		: "r" (CPM_CPCCR), "r" (cpccr), "r" (wait), "r" (tmp));
+
+	/* Update some other DRAM parameters after changing frequency */
+	jz_update_dram_post(cur_mclk, new_mclk);
+}
+
+#ifdef CHANGE_PLL
+/* Maintain the LCD clock and pixel clock */
+static void jz_scale_lcd_divisors(struct dpm_regs *regs)
+{
+	unsigned int new_pll, new_lcd_div, new_lcdpix_div;
+	unsigned int cpccr;
+	unsigned int tmp = 0, wait = PLL_WAIT_500NS;
+
+	if (!boot_config.lcd_clks_initialized) return;
+
+	new_pll = __cpm_get_pllout();
+	new_lcd_div = new_pll / boot_config.lcd_clk;
+	new_lcdpix_div = new_pll / boot_config.lcdpix_clk;
+
+	if (new_lcd_div < 1)
+		new_lcd_div = 1;
+	if (new_lcd_div > 16)
+		new_lcd_div = 16;
+
+	if (new_lcdpix_div < 1)
+		new_lcdpix_div = 1;
+	if (new_lcdpix_div > 512)
+		new_lcdpix_div = 512;
+
+//	REG_CPM_CPCCR2 = new_lcdpix_div - 1;
+
+	cpccr = REG_CPM_CPCCR;
+	cpccr &= ~CPM_CPCCR_LDIV_MASK;
+	cpccr |= ((new_lcd_div - 1) << CPM_CPCCR_LDIV_BIT);
+	cpccr |= CPM_CPCCR_CE;       /* update immediately */
+
+	/* update register to change the clocks.
+	 * align this code to a cache line.
+	 */
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".align 5\n"
+		"sw %1,0(%0)\n\t"
+		"li %3,0\n\t"
+		"1:\n\t"
+		"bne %3,%2,1b\n\t"
+		"addi %3, 1\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set reorder\n\t"
+		:
+		: "r" (CPM_CPCCR), "r" (cpccr), "r" (wait), "r" (tmp));
+}
+
+static void jz_scale_pll(struct dpm_regs *regs)
+{
+	unsigned int cppcr;
+	unsigned int cur_mclk, new_mclk, new_pll;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	int od[] = {1, 2, 2, 4};
+
+	cppcr = REG_CPM_CPPCR;
+	cppcr &= ~(regs->cppcr_mask | CPM_CPPCR_PLLS | CPM_CPPCR_PLLEN | CPM_CPPCR_PLLST_MASK);
+	regs->cppcr &= ~CPM_CPPCR_PLLEN;
+	cppcr |= (regs->cppcr | 0xff);
+
+	/* Update some DRAM parameters before changing frequency */
+	new_pll = JZ_EXTAL * ((cppcr>>23)+2) / ((((cppcr>>18)&0x1f)+2) * od[(cppcr>>16)&0x03]);
+	cur_mclk = __cpm_get_mclk();
+	new_mclk = new_pll / div[(REG_CPM_CPCCR>>16) & 0xf];
+
+	/*
+	 * Update some SDRAM parameters
+	 */
+	jz_update_dram_prev(cur_mclk, new_mclk);
+
+	/*
+	 * Update PLL, align code to cache line.
+	 */
+	cppcr |= CPM_CPPCR_PLLEN;
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".align 5\n"
+		"sw %1,0(%0)\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set reorder\n\t"
+		:
+		: "r" (CPM_CPPCR), "r" (cppcr));
+
+	/* Update some other DRAM parameters after changing frequency */
+	jz_update_dram_post(cur_mclk, new_mclk);
+}
+#endif
+
+static void jz4750_transition(struct dpm_regs *regs)
+{
+	/*
+	 * Get and save some boot-time conditions.
+	 */
+	jz_init_boot_config();
+
+#ifdef CHANGE_PLL
+	/*
+	 * Disable LCD before scaling pll.
+	 * LCD and LCD pixel clocks should not be changed even if the PLL
+	 * output frequency has been changed.
+	 */
+	REG_LCD_CTRL &= ~LCD_CTRL_ENA;
+
+	/*
+	 * Stop module clocks before scaling PLL
+	 */
+	__cpm_stop_eth();
+	__cpm_stop_aic(1);
+	__cpm_stop_aic(2);
+#endif
+
+	/* ... add more as necessary */
+
+	if (regs->pll_up_flag == PLL_GOES_UP) {
+		/* the pll frequency is going up, so change dividors first */
+		jz_scale_divisors(regs);
+#ifdef CHANGE_PLL
+		jz_scale_pll(regs);
+#endif
+	}
+	else if (regs->pll_up_flag == PLL_GOES_DOWN) {
+		/* the pll frequency is going down, so change pll first */
+#ifdef CHANGE_PLL
+		jz_scale_pll(regs);
+#endif
+		jz_scale_divisors(regs);
+	}
+	else {
+		/* the pll frequency is unchanged, so change divisors only */
+		jz_scale_divisors(regs);
+	}
+
+#ifdef CHANGE_PLL
+	/*
+	 * Restart module clocks before scaling PLL
+	 */
+	__cpm_start_eth();
+	__cpm_start_aic(1);
+	__cpm_start_aic(2);
+
+	/* ... add more as necessary */
+
+	/* Scale the LCD divisors after scaling pll */
+	if (regs->pll_up_flag != PLL_UNCHANGED) {
+		jz_scale_lcd_divisors(regs);
+	}
+
+	/* Enable LCD controller */
+	REG_LCD_CTRL &= ~LCD_CTRL_DIS;
+	REG_LCD_CTRL |= LCD_CTRL_ENA;
+#endif
+
+	/* Update system clocks */
+	jz_update_clocks();
+}
+
+extern unsigned int idle_times;
+static unsigned int jz4750_freq_get(unsigned int cpu)
+{
+	return  (__cpm_get_cclk() / 1000);
+}
+
+static unsigned int index_to_divisor(unsigned int index, struct dpm_regs *regs)
+{
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[4] = {1, 2, 2, 2}; /* divisors of I:S:P:M */
+	unsigned int div_of_cclk, new_freq, i;
+
+	regs->pll_up_flag = PLL_UNCHANGED;
+	regs->cpccr_mask = CPM_CPCCR_CDIV_MASK | CPM_CPCCR_HDIV_MASK | CPM_CPCCR_PDIV_MASK | CPM_CPCCR_MDIV_MASK;
+
+	new_freq = jz4750_freq_table.table[index].frequency;
+
+	do {
+		div_of_cclk = __cpm_get_pllout() / (1000 * new_freq);
+	} while (div_of_cclk==0);
+
+	if(div_of_cclk == 1 || div_of_cclk == 2 || div_of_cclk == 4) {
+		for(i = 1; i<4; i++) {
+			div[i] = 3;
+		}
+	} else {
+		for(i = 1; i<4; i++) {
+			div[i] = 2;
+		}
+	}
+
+	for(i = 0; i<4; i++) {
+		div[i] *= div_of_cclk;
+	}
+
+	dprintk("divisors of I:S:P:M = %d:%d:%d:%d\n", div[0], div[1], div[2], div[3]);
+
+	regs->cpccr =
+		(n2FR[div[0]] << CPM_CPCCR_CDIV_BIT) |
+		(n2FR[div[1]] << CPM_CPCCR_HDIV_BIT) |
+		(n2FR[div[2]] << CPM_CPCCR_PDIV_BIT) |
+		(n2FR[div[3]] << CPM_CPCCR_MDIV_BIT);
+
+	return  div_of_cclk;
+}
+
+static void jz4750_set_cpu_divider_index(unsigned int cpu, unsigned int index)
+{
+	unsigned long divisor, old_divisor;
+	struct cpufreq_freqs freqs;
+	struct dpm_regs regs;
+
+	old_divisor = __cpm_get_pllout() /  __cpm_get_cclk();
+	divisor = index_to_divisor(index, &regs);
+
+	freqs.old = __cpm_get_cclk() / 1000;
+	freqs.new =  __cpm_get_pllout() / (1000 * divisor);
+	freqs.cpu = cpu;
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+	if (old_divisor != divisor)
+		jz4750_transition(&regs);
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+}
+
+static int jz4750_freq_target(struct cpufreq_policy *policy,
+			  unsigned int target_freq,
+			  unsigned int relation)
+{
+	unsigned int new_index = 0;
+
+	if (cpufreq_frequency_table_target(policy,
+					   &jz4750_freq_table.table[0],
+					   target_freq, relation, &new_index))
+		return -EINVAL;
+
+	jz4750_set_cpu_divider_index(policy->cpu, new_index);
+
+	dprintk("new frequency is %d KHz (REG_CPM_CPCCR:0x%x)\n", __cpm_get_cclk() / 1000, REG_CPM_CPCCR);
+
+	return 0;
+}
+
+static int jz4750_freq_verify(struct cpufreq_policy *policy)
+{
+	return cpufreq_frequency_table_verify(policy,
+					      &jz4750_freq_table.table[0]);
+}
+
+static int __init jz4750_cpufreq_driver_init(struct cpufreq_policy *policy)
+{
+
+	struct cpufreq_frequency_table *table =	&jz4750_freq_table.table[0];
+	unsigned int MAX_FREQ;
+
+	dprintk(KERN_INFO "Jz4750 cpufreq driver\n");
+
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	policy->cur = MAX_FREQ = __cpm_get_cclk() / 1000; /* in kHz. Current and max frequency is determined by u-boot */
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+
+	policy->cpuinfo.min_freq = MAX_FREQ/8;
+	policy->cpuinfo.max_freq = MAX_FREQ;
+	policy->cpuinfo.transition_latency = 100000; /* in 10^(-9) s = nanoseconds */
+
+	table[0].index = 0;
+	table[0].frequency = MAX_FREQ/8;
+	table[1].index = 1;
+	table[1].frequency = MAX_FREQ/6;
+	table[2].index = 2;
+	table[2].frequency = MAX_FREQ/4;
+	table[3].index = 3;
+	table[3].frequency = MAX_FREQ/3;
+	table[4].index = 4;
+	table[4].frequency = MAX_FREQ/2;
+	table[5].index = 5;
+	table[5].frequency = MAX_FREQ;
+	table[6].index = 6;
+	table[6].frequency = CPUFREQ_TABLE_END;
+
+#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
+	cpufreq_frequency_table_get_attr(table, policy->cpu); /* for showing /sys/devices/system/cpu/cpuX/cpufreq/stats/ */
+#endif
+
+	return  cpufreq_frequency_table_cpuinfo(policy, table);
+}
+
+static struct cpufreq_driver cpufreq_jz4750_driver = {
+//	.flags		= CPUFREQ_STICKY,
+	.init		= jz4750_cpufreq_driver_init,
+	.verify		= jz4750_freq_verify,
+	.target		= jz4750_freq_target,
+	.get		= jz4750_freq_get,
+	.name		= "jz4750",
+};
+
+static int __init jz4750_cpufreq_init(void)
+{
+	return cpufreq_register_driver(&cpufreq_jz4750_driver);
+}
+
+static void __exit jz4750_cpufreq_exit(void)
+{
+	cpufreq_unregister_driver(&cpufreq_jz4750_driver);
+}
+
+module_init(jz4750_cpufreq_init);
+module_exit(jz4750_cpufreq_exit);
+
+MODULE_AUTHOR("Regen <lhhuang@ingenic.cn>");
+MODULE_DESCRIPTION("cpufreq driver for Jz4750");
+MODULE_LICENSE("GPL");
--- linux-2.6.24.7.old/arch/mips/jz4750/dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750/dma.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,836 @@
+/*
+ * linux/arch/mips/jz4750/dma.c
+ *
+ * Support functions for the JZ4750 internal DMA channels.
+ * No-descriptor transfer only.
+ * Descriptor transfer should also call jz_request_dma() to get a free
+ * channel and call jz_free_dma() to free the channel. And driver should
+ * build the DMA descriptor and setup the DMA channel by itself.
+ *
+ * Copyright (C) 2006 - 2008 Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/soundcard.h>
+
+#include <asm/system.h>
+#include <asm/addrspace.h>
+#include <asm/jzsoc.h>
+
+/*
+ * A note on resource allocation:
+ *
+ * All drivers needing DMA channels, should allocate and release them
+ * through the public routines `jz_request_dma()' and `jz_free_dma()'.
+ *
+ * In order to avoid problems, all processes should allocate resources in
+ * the same sequence and release them in the reverse order.
+ *
+ * So, when allocating DMAs and IRQs, first allocate the DMA, then the IRQ.
+ * When releasing them, first release the IRQ, then release the DMA. The
+ * main reason for this order is that, if you are requesting the DMA buffer
+ * done interrupt, you won't know the irq number until the DMA channel is
+ * returned from jz_request_dma().
+ */
+
+struct jz_dma_chan jz_dma_table[MAX_DMA_NUM] = {
+	{dev_id:DMA_ID_BCH_ENC,}, /* DMAC0 channel 0, reserved for BCH */
+	{dev_id:-1,},		/* DMAC0 channel 1 */
+	{dev_id:-1,},		/* DMAC0 channel 2 */
+	{dev_id:-1,},		/* DMAC0 channel 3 */
+	{dev_id:-1,},		/* DMAC0 channel 4 */
+	{dev_id:-1,},		/* DMAC0 channel 5 */
+	{dev_id:-1,},		/* DMAC1 channel 0 */
+	{dev_id:-1,},		/* DMAC1 channel 1 */
+	{dev_id:-1,},		/* DMAC1 channel 2 */
+	{dev_id:-1,},		/* DMAC1 channel 3 */
+	{dev_id:-1,},		/* DMAC1 channel 4 */
+	{dev_id:-1,},		/* DMAC1 channel 5 */
+};
+
+// Device FIFO addresses and default DMA modes
+static const struct {
+	unsigned int fifo_addr;
+	unsigned int dma_mode;
+	unsigned int dma_source;
+} dma_dev_table[DMA_ID_MAX] = {
+	{0, DMA_AUTOINIT, DMAC_DRSR_RS_EXT}, /* External request with DREQn */
+	{0x18000000, DMA_AUTOINIT, DMAC_DRSR_RS_NAND}, /* NAND request */
+	{CPHYSADDR(BCH_DR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_BCH_ENC},
+	{CPHYSADDR(BCH_DR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_BCH_DEC},
+	{0, DMA_AUTOINIT, DMAC_DRSR_RS_AUTO},
+//	{CPHYSADDR(TSSI_FIFO), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_TSSIIN},
+	{CPHYSADDR(UART3_TDR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_UART3OUT},
+	{CPHYSADDR(UART3_RDR), DMA_8BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_UART3IN},
+	{CPHYSADDR(UART2_TDR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_UART2OUT},
+	{CPHYSADDR(UART2_RDR), DMA_8BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_UART2IN},
+	{CPHYSADDR(UART1_TDR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_UART1OUT},
+	{CPHYSADDR(UART1_RDR), DMA_8BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_UART1IN},
+	{CPHYSADDR(UART0_TDR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_UART0OUT},
+	{CPHYSADDR(UART0_RDR), DMA_8BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_UART0IN},
+	{CPHYSADDR(SSI_DR(0)), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_SSI0OUT},
+	{CPHYSADDR(SSI_DR(0)), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_SSI0IN},
+	{CPHYSADDR(AIC_DR), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_AICOUT},
+	{CPHYSADDR(AIC_DR), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_AICIN},
+	{CPHYSADDR(MSC_TXFIFO(0)), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_MSC0OUT},
+	{CPHYSADDR(MSC_RXFIFO(0)), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_MSC0IN},
+	{0, DMA_AUTOINIT, DMAC_DRSR_RS_TCU},
+	{SADC_TSDAT, DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_SADC},/* Touch Screen Data Register */
+	{CPHYSADDR(MSC_TXFIFO(1)), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_MSC1OUT}, /* SSC1 TX */
+	{CPHYSADDR(MSC_RXFIFO(1)), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_MSC1IN},	/* SSC1 RX */
+	{CPHYSADDR(SSI_DR(1)), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_SSI1OUT},
+	{CPHYSADDR(SSI_DR(1)), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_SSI1IN},
+	{CPHYSADDR(PCM_DP), DMA_16BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_PMOUT},
+	{CPHYSADDR(PCM_DP), DMA_16BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_PMIN},
+	{},
+};
+
+
+int jz_dma_read_proc(char *buf, char **start, off_t fpos,
+			 int length, int *eof, void *data)
+{
+	int i, len = 0;
+	struct jz_dma_chan *chan;
+
+	for (i = 0; i < MAX_DMA_NUM; i++) {
+		if ((chan = get_dma_chan(i)) != NULL) {
+			len += sprintf(buf + len, "%2d: %s\n",
+				       i, chan->dev_str);
+		}
+	}
+
+	if (fpos >= len) {
+		*start = buf;
+		*eof = 1;
+		return 0;
+	}
+	*start = buf + fpos;
+	if ((len -= fpos) > length)
+		return length;
+	*eof = 1;
+	return len;
+}
+
+
+void dump_jz_dma_channel(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan;
+
+	if (dmanr > MAX_DMA_NUM)
+		return;
+	chan = &jz_dma_table[dmanr];
+
+	printk("DMA%d Registers:\n", dmanr);
+	printk("  DMACR  = 0x%08x\n", REG_DMAC_DMACR(chan->io/HALF_DMA_NUM));
+	printk("  DSAR   = 0x%08x\n", REG_DMAC_DSAR(dmanr));
+	printk("  DTAR   = 0x%08x\n", REG_DMAC_DTAR(dmanr));
+	printk("  DTCR   = 0x%08x\n", REG_DMAC_DTCR(dmanr));
+	printk("  DRSR   = 0x%08x\n", REG_DMAC_DRSR(dmanr));
+	printk("  DCCSR  = 0x%08x\n", REG_DMAC_DCCSR(dmanr));
+	printk("  DCMD  = 0x%08x\n", REG_DMAC_DCMD(dmanr));
+	printk("  DDA  = 0x%08x\n", REG_DMAC_DDA(dmanr));
+	printk("  DMADBR = 0x%08x\n", REG_DMAC_DMADBR(chan->io/HALF_DMA_NUM));
+}
+
+
+/**
+ * jz_request_dma - dynamically allcate an idle DMA channel to return
+ * @dev_id: the specified dma device id or DMA_ID_RAW_SET
+ * @dev_str: the specified dma device string name
+ * @irqhandler: the irq handler, or NULL
+ * @irqflags: the irq handler flags
+ * @irq_dev_id: the irq handler device id for shared irq
+ *
+ * Finds a free channel, and binds the requested device to it.
+ * Returns the allocated channel number, or negative on error.
+ * Requests the DMA done IRQ if irqhandler != NULL.
+ *
+*/
+/*int jz_request_dma(int dev_id, const char *dev_str,
+		   void (*irqhandler)(int, void *, struct pt_regs *),
+		   unsigned long irqflags,
+		   void *irq_dev_id)
+*/
+
+int jz_request_dma(int dev_id, const char *dev_str,
+		   irqreturn_t (*irqhandler)(int, void *),
+		   unsigned long irqflags,
+		   void *irq_dev_id)
+{
+	struct jz_dma_chan *chan;
+	int i, ret, chan0;
+
+	if (dev_id < 0 || dev_id >= DMA_ID_MAX)
+		return -EINVAL;
+
+        /* Because of a bug in DMA controller of jz4750, which causes auto
+           request and device request can't be allocated in a same DMA
+           controller, all device requests should be put in the second DMA
+           controller
+         */
+	if (dev_id > DMA_ID_AUTO)
+		chan0 = 6;
+	else
+		chan0 = 0;
+
+	for (i = chan0; i < MAX_DMA_NUM; i++) {
+		if (jz_dma_table[i].dev_id < 0)
+			break;
+	}
+	if (i == MAX_DMA_NUM)  /* no free channel */
+		return -ENODEV;
+
+	/* we got a free channel */
+	chan = &jz_dma_table[i];
+
+	if (irqhandler) {
+		chan->irq = IRQ_DMA_0 + i;	// allocate irq number
+		chan->irq_dev = irq_dev_id;
+		if ((ret = request_irq(chan->irq, irqhandler, irqflags,
+				       dev_str, chan->irq_dev))) {
+			chan->irq = -1;
+			chan->irq_dev = NULL;
+			return ret;
+		}
+	} else {
+		chan->irq = -1;
+		chan->irq_dev = NULL;
+	}
+
+	// fill it in
+	chan->io = i;
+	chan->dev_id = dev_id;
+	chan->dev_str = dev_str;
+	chan->fifo_addr = dma_dev_table[dev_id].fifo_addr;
+	chan->mode = dma_dev_table[dev_id].dma_mode;
+	chan->source = dma_dev_table[dev_id].dma_source;
+
+	if (i < 6)
+		REG_DMAC_DMACKE(0) = 1 << i;
+	else
+		REG_DMAC_DMACKE(1) = 1 << (i - 6);
+
+	return i;
+}
+
+void jz_free_dma(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan) {
+		printk("Trying to free DMA%d\n", dmanr);
+		return;
+	}
+
+	disable_dma(dmanr);
+	if (chan->irq)
+		free_irq(chan->irq, chan->irq_dev);
+
+	chan->irq = -1;
+	chan->irq_dev = NULL;
+	chan->dev_id = -1;
+}
+
+void jz_set_dma_dest_width(int dmanr, int nbit)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+	       	return;
+
+	chan->mode &= ~DMAC_DCMD_DWDH_MASK;
+	switch (nbit) {
+	case 8:
+		chan->mode |= DMAC_DCMD_DWDH_8;
+		break;
+	case 16:
+		chan->mode |= DMAC_DCMD_DWDH_16;
+		break;
+	case 32:
+		chan->mode |= DMAC_DCMD_DWDH_32;
+		break;
+	}
+}
+
+void jz_set_dma_src_width(int dmanr, int nbit)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+	       	return;
+
+	chan->mode &= ~DMAC_DCMD_SWDH_MASK;
+	switch (nbit) {
+	case 8:
+		chan->mode |= DMAC_DCMD_SWDH_8;
+		break;
+	case 16:
+		chan->mode |= DMAC_DCMD_SWDH_16;
+		break;
+	case 32:
+		chan->mode |= DMAC_DCMD_SWDH_32;
+		break;
+	}
+}
+
+void jz_set_dma_block_size(int dmanr, int nbyte)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	chan->mode &= ~DMAC_DCMD_DS_MASK;
+	switch (nbyte) {
+	case 1:
+		chan->mode |= DMAC_DCMD_DS_8BIT;
+		break;
+	case 2:
+		chan->mode |= DMAC_DCMD_DS_16BIT;
+		break;
+	case 4:
+		chan->mode |= DMAC_DCMD_DS_32BIT;
+		break;
+	case 16:
+		chan->mode |= DMAC_DCMD_DS_16BYTE;
+		break;
+	case 32:
+		chan->mode |= DMAC_DCMD_DS_32BYTE;
+		break;
+	}
+}
+
+unsigned int jz_get_dma_command(int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	return chan->mode;
+}
+
+/**
+ * jz_set_dma_mode - do the raw settings for the specified DMA channel
+ * @dmanr: the specified DMA channel
+ * @mode: dma operate mode, DMA_MODE_READ or DMA_MODE_WRITE
+ * @dma_mode: dma raw mode
+ * @dma_source: dma raw request source
+ * @fifo_addr: dma raw device fifo address
+ *
+ * Ensure call jz_request_dma(DMA_ID_RAW_SET, ...) first, then call
+ * jz_set_dma_mode() rather than set_dma_mode() if you work with
+ * and external request dma device.
+ *
+ * NOTE: Don not dynamically allocate dma channel if one external request
+ *       dma device will occupy this channel.
+*/
+int jz_set_dma_mode(unsigned int dmanr, unsigned int mode,
+		    unsigned int dma_mode, unsigned int dma_source,
+		    unsigned int fifo_addr)
+{
+	int dev_id, i;
+	struct jz_dma_chan *chan;
+
+	if (dmanr > MAX_DMA_NUM)
+		return -ENODEV;
+	for (i = 0; i < MAX_DMA_NUM; i++) {
+		if (jz_dma_table[i].dev_id < 0)
+			break;
+	}
+	if (i == MAX_DMA_NUM)
+		return -ENODEV;
+
+	chan = &jz_dma_table[dmanr];
+	dev_id = chan->dev_id;
+	if (dev_id > 0) {
+		printk(KERN_DEBUG "%s sets the allocated DMA channel %d!\n",
+		       __FUNCTION__, dmanr);
+		return -ENODEV;
+	}
+
+	/* clone it from the dynamically allocated. */
+	if (i != dmanr) {
+		chan->irq = jz_dma_table[i].irq;
+		chan->irq_dev = jz_dma_table[i].irq_dev;
+		chan->dev_str = jz_dma_table[i].dev_str;
+		jz_dma_table[i].irq = 0;
+		jz_dma_table[i].irq_dev = NULL;
+		jz_dma_table[i].dev_id = -1;
+	}
+	chan->dev_id = DMA_ID_RAW_SET;
+	chan->io = dmanr;
+	chan->fifo_addr = fifo_addr;
+	chan->mode = dma_mode;
+	chan->source = dma_source;
+
+	set_dma_mode(dmanr, dma_mode);
+
+	return dmanr;
+}
+
+void enable_dma(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	REG_DMAC_DCCSR(dmanr) &= ~(DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR);
+	REG_DMAC_DCCSR(dmanr) |= DMAC_DCCSR_NDES; /* No-descriptor transfer */
+	__dmac_enable_channel(dmanr);
+	if (chan->irq)
+		__dmac_channel_enable_irq(dmanr);
+}
+
+#define DMA_DISABLE_POLL 0x10000
+
+void disable_dma(unsigned int dmanr)
+{
+	int i;
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	if (!__dmac_channel_enabled(dmanr))
+		return;
+
+	for (i = 0; i < DMA_DISABLE_POLL; i++)
+		if (__dmac_channel_transmit_end_detected(dmanr))
+			break;
+#if 0
+	if (i == DMA_DISABLE_POLL)
+		printk(KERN_INFO "disable_dma: poll expired!\n");
+#endif
+
+	__dmac_disable_channel(dmanr);
+	if (chan->irq)
+		__dmac_channel_disable_irq(dmanr);
+}
+
+/* Note: DMA_MODE_MASK is simulated by sw */
+void set_dma_mode(unsigned int dmanr, unsigned int mode)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+	mode &= DMA_MODE_MASK;
+	if (mode == DMA_MODE_READ) {
+		chan->mode |= DMAC_DCMD_DAI;
+		chan->mode &= ~DMAC_DCMD_SAI;
+	} else if (mode == DMA_MODE_WRITE) {
+		chan->mode |= DMAC_DCMD_SAI;
+		chan->mode &= ~DMAC_DCMD_DAI;
+	} else {
+		printk(KERN_DEBUG "set_dma_mode() just supports DMA_MODE_READ or DMA_MODE_WRITE!\n");
+	}
+	REG_DMAC_DCMD(chan->io) = chan->mode & ~DMA_MODE_MASK;
+	REG_DMAC_DRSR(chan->io) = chan->source;
+}
+
+void set_dma_addr(unsigned int dmanr, unsigned int phyaddr)
+{
+	unsigned int mode;
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	mode = chan->mode & DMA_MODE_MASK;
+	if (mode == DMA_MODE_READ) {
+		REG_DMAC_DSAR(chan->io) = chan->fifo_addr;
+		REG_DMAC_DTAR(chan->io) = phyaddr;
+	} else if (mode == DMA_MODE_WRITE) {
+		REG_DMAC_DSAR(chan->io) = phyaddr;
+		REG_DMAC_DTAR(chan->io) = chan->fifo_addr;
+	} else
+		printk(KERN_DEBUG "Driver should call set_dma_mode() ahead set_dma_addr()!\n");
+}
+
+void set_dma_count(unsigned int dmanr, unsigned int bytecnt)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	int dma_ds[] = {4, 1, 2, 16, 32};
+	unsigned int ds;
+
+	if (!chan)
+	       	return;
+
+       	ds = (chan->mode & DMAC_DCMD_DS_MASK) >> DMAC_DCMD_DS_BIT;
+	REG_DMAC_DTCR(chan->io) = bytecnt / dma_ds[ds]; // transfer count
+}
+
+unsigned int get_dma_residue(unsigned int dmanr)
+{
+	unsigned int count, ds;
+	int dma_ds[] = {4, 1, 2, 16, 32};
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 0;
+
+	ds = (chan->mode & DMAC_DCMD_DS_MASK) >> DMAC_DCMD_DS_BIT;
+	count = REG_DMAC_DTCR(chan->io);
+	count = count * dma_ds[ds];
+
+	return count;
+}
+
+void jz_set_oss_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	switch (audio_fmt) {
+	case AFMT_U8:
+		/* burst mode : 32BIT */
+		break;
+	case AFMT_S16_LE:
+		/* burst mode : 16BYTE */
+		if (mode == DMA_MODE_READ) {
+			chan->mode = DMA_AIC_32_16BYTE_RX_CMD | DMA_MODE_READ;
+			chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCMD_DAI;
+			chan->mode &= ~DMAC_DCMD_SAI;
+		} else if (mode == DMA_MODE_WRITE) {
+			chan->mode = DMA_AIC_32_16BYTE_TX_CMD | DMA_MODE_WRITE;
+			//chan->mode = DMA_AIC_16BYTE_TX_CMD | DMA_MODE_WRITE;
+			chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCMD_SAI;
+			chan->mode &= ~DMAC_DCMD_DAI;
+		} else
+			printk("oss_dma_burst_mode() just supports DMA_MODE_READ or DMA_MODE_WRITE!\n");
+
+		REG_DMAC_DCMD(chan->io) = chan->mode & ~DMA_MODE_MASK;
+		REG_DMAC_DRSR(chan->io) = chan->source;
+		break;
+	}
+}
+
+void jz_set_alsa_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	switch (audio_fmt) {
+	case 8:
+		/* SNDRV_PCM_FORMAT_S8 burst mode : 32BIT */
+		break;
+	case 16:
+		/* SNDRV_PCM_FORMAT_S16_LE burst mode : 16BYTE */
+		if (mode == DMA_MODE_READ) {
+			chan->mode = DMA_AIC_16BYTE_RX_CMD | DMA_MODE_READ;
+			chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCMD_DAI;
+			chan->mode &= ~DMAC_DCMD_SAI;
+		} else if (mode == DMA_MODE_WRITE) {
+			chan->mode = DMA_AIC_16BYTE_TX_CMD | DMA_MODE_WRITE;
+			chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCMD_SAI;
+			chan->mode &= ~DMAC_DCMD_DAI;
+		} else
+			printk("alsa_dma_burst_mode() just supports DMA_MODE_READ or DMA_MODE_WRITE!\n");
+
+		REG_DMAC_DCMD(chan->io) = chan->mode & ~DMA_MODE_MASK;
+		REG_DMAC_DRSR(chan->io) = chan->source;
+		break;
+	}
+}
+
+//#define JZ4750_DMAC_TEST_ENABLE
+#undef JZ4750_DMAC_TEST_ENABLE
+
+#ifdef JZ4750_DMAC_TEST_ENABLE
+
+/*
+ * DMA test: external address <--> external address
+ */
+#define TEST_DMA_SIZE  16*1024
+
+static jz_dma_desc *dma_desc;
+
+static int dma_chan;
+static dma_addr_t dma_desc_phys_addr;
+static unsigned int dma_src_addr, dma_src_phys_addr, dma_dst_addr, dma_dst_phys_addr;
+
+static int dma_check_result(void *src, void *dst, int size)
+{
+	unsigned int addr1, addr2, i, err = 0;
+
+	addr1 = (unsigned int)src;
+	addr2 = (unsigned int)dst;
+
+	for (i = 0; i < size; i += 4) {
+		if (*(volatile unsigned int *)addr1 != *(volatile unsigned int *)addr2) {
+			err++;
+			printk("wrong data at 0x%08x: src 0x%08x  dst 0x%08x\n", addr2, *(volatile unsigned int *)addr1, *(volatile unsigned int *)addr2);
+		}
+		addr1 += 4;
+		addr2 += 4;
+	}
+	printk("check DMA result err=%d\n", err);
+	return err;
+}
+
+static irqreturn_t jz4750_dma_irq(int irq, void *dev_id)
+{
+	printk("jz4750_dma_irq %d\n", irq);
+
+
+	if (__dmac_channel_transmit_halt_detected(dma_chan)) {
+		printk("DMA HALT\n");
+		REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+		__dmac_channel_clear_transmit_halt(dma_chan);
+	}
+
+	if (__dmac_channel_address_error_detected(dma_chan)) {
+		printk("DMA ADDR ERROR\n");
+		REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+		REG_DMAC_DSAR(dma_chan) = 0; /* clear source address register */
+		REG_DMAC_DTAR(dma_chan) = 0; /* clear target address register */
+		__dmac_channel_clear_address_error(dma_chan);
+	}
+
+	if (__dmac_channel_descriptor_invalid_detected(dma_chan)) {
+		REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+		printk("DMA DESC INVALID\n");
+		__dmac_channel_clear_descriptor_invalid(dma_chan);
+	}
+
+	if (__dmac_channel_count_terminated_detected(dma_chan)) {
+		printk("DMA CT\n");
+		__dmac_channel_clear_count_terminated(dma_chan);
+	}
+
+	if (__dmac_channel_transmit_end_detected(dma_chan)) {
+		REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+		printk("DMA TT\n");
+		__dmac_channel_clear_transmit_end(dma_chan);
+		dump_jz_dma_channel(dma_chan);
+		dma_check_result((void *)dma_src_addr, (void *)dma_dst_addr, TEST_DMA_SIZE);
+	}
+
+	return IRQ_HANDLED;
+}
+
+void dma_nodesc_test(void)
+{
+	unsigned int addr, i;
+
+	printk("dma_nodesc_test\n");
+
+	/* Request DMA channel and setup irq handler */
+	dma_chan = jz_request_dma(DMA_ID_AUTO, "auto", jz4750_dma_irq,
+				  IRQF_DISABLED, NULL);
+	if (dma_chan < 0) {
+		printk("Setup irq failed\n");
+		return;
+	}
+
+	printk("Requested DMA channel = %d\n", dma_chan);
+
+	/* Allocate DMA buffers */
+	dma_src_addr = __get_free_pages(GFP_KERNEL, 2); /* 16KB */
+	dma_dst_addr = __get_free_pages(GFP_KERNEL, 2); /* 16KB */
+
+	dma_src_phys_addr = CPHYSADDR(dma_src_addr);
+	dma_dst_phys_addr = CPHYSADDR(dma_dst_addr);
+
+	printk("Buffer addresses: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+	       dma_src_addr, dma_src_phys_addr, dma_dst_addr, dma_dst_phys_addr);
+
+	/* Prepare data for source buffer */
+	addr = (unsigned int)dma_src_addr;
+	for (i = 0; i < TEST_DMA_SIZE; i += 4) {
+		*(volatile unsigned int *)addr = addr;
+		addr += 4;
+	}
+	dma_cache_wback((unsigned long)dma_src_addr, TEST_DMA_SIZE);
+
+	/* Init target buffer */
+	memset((void *)dma_dst_addr, 0, TEST_DMA_SIZE);
+	dma_cache_wback((unsigned long)dma_dst_addr, TEST_DMA_SIZE);
+
+	/* Init DMA module */
+	printk("Starting DMA\n");
+	REG_DMAC_DMACR(dma_chan/HALF_DMA_NUM) = 0;
+	REG_DMAC_DCCSR(dma_chan) = 0;
+	REG_DMAC_DRSR(dma_chan) = DMAC_DRSR_RS_AUTO;
+	REG_DMAC_DSAR(dma_chan) = dma_src_phys_addr;
+	REG_DMAC_DTAR(dma_chan) = dma_dst_phys_addr;
+	REG_DMAC_DTCR(dma_chan) = 512;
+	REG_DMAC_DCMD(dma_chan) = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_32BYTE | DMAC_DCMD_TIE;
+	REG_DMAC_DCCSR(dma_chan) = DMAC_DCCSR_NDES | DMAC_DCCSR_EN;
+	REG_DMAC_DMACR(dma_chan/HALF_DMA_NUM) = DMAC_DMACR_DMAE; /* global DMA enable bit */
+
+	printk("DMA started. IMR=%08x\n", REG_INTC_IMR);
+
+	/* wait a long time, ensure transfer end */
+	printk("wait 3s...\n");
+	mdelay(3000);		/* wait 3s */
+
+	REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+	/* free buffers */
+	printk("free DMA buffers\n");
+	free_pages(dma_src_addr, 2);
+	free_pages(dma_dst_addr, 2);
+
+	if (dma_desc)
+		free_pages((unsigned int)dma_desc, 0);
+
+	/* free dma */
+	jz_free_dma(dma_chan);
+}
+
+void dma_desc_test(void)
+{
+	unsigned int next, addr, i;
+	static jz_dma_desc *desc;
+
+	printk("dma_desc_test\n");
+
+	/* Request DMA channel and setup irq handler */
+	dma_chan = jz_request_dma(DMA_ID_AUTO, "auto", jz4750_dma_irq,
+				  IRQF_DISABLED, NULL);
+	if (dma_chan < 0) {
+		printk("Setup irq failed\n");
+		return;
+	}
+
+	printk("Requested DMA channel = %d\n", dma_chan);
+
+	/* Allocate DMA buffers */
+	dma_src_addr = __get_free_pages(GFP_KERNEL, 2); /* 16KB */
+	dma_dst_addr = __get_free_pages(GFP_KERNEL, 2); /* 16KB */
+
+	dma_src_phys_addr = CPHYSADDR(dma_src_addr);
+	dma_dst_phys_addr = CPHYSADDR(dma_dst_addr);
+
+	printk("Buffer addresses: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+	       dma_src_addr, dma_src_phys_addr, dma_dst_addr, dma_dst_phys_addr);
+
+	/* Prepare data for source buffer */
+	addr = (unsigned int)dma_src_addr;
+	for (i = 0; i < TEST_DMA_SIZE; i += 4) {
+		*(volatile unsigned int *)addr = addr;
+		addr += 4;
+	}
+	dma_cache_wback((unsigned long)dma_src_addr, TEST_DMA_SIZE);
+
+	/* Init target buffer */
+	memset((void *)dma_dst_addr, 0, TEST_DMA_SIZE);
+	dma_cache_wback((unsigned long)dma_dst_addr, TEST_DMA_SIZE);
+
+	/* Allocate DMA descriptors */
+	dma_desc = (jz_dma_desc *)__get_free_pages(GFP_KERNEL, 0);
+	dma_desc_phys_addr = CPHYSADDR((unsigned long)dma_desc);
+
+	printk("DMA descriptor address: 0x%08x  0x%08x\n", (u32)dma_desc, dma_desc_phys_addr);
+
+	/* Setup DMA descriptors */
+	desc = dma_desc;
+	next = (dma_desc_phys_addr + (sizeof(jz_dma_desc))) >> 4;
+
+	desc->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_32BYTE | DMAC_DCMD_DES_V | DMAC_DCMD_DES_VM | DMAC_DCMD_DES_VIE | DMAC_DCMD_TIE | DMAC_DCMD_LINK;
+	desc->dsadr = dma_src_phys_addr;    /* DMA source address */
+	desc->dtadr = dma_dst_phys_addr;    /* DMA target address */
+	desc->ddadr = (next << 24) + 128;    /* size: 128*32 bytes = 4096 bytes */
+
+	desc++;
+	next = (dma_desc_phys_addr + 2*(sizeof(jz_dma_desc))) >> 4;
+
+	desc->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_16BYTE | DMAC_DCMD_DES_V | DMAC_DCMD_DES_VM | DMAC_DCMD_DES_VIE | DMAC_DCMD_TIE | DMAC_DCMD_LINK;
+	desc->dsadr = dma_src_phys_addr + 4096;	/* DMA source address */
+	desc->dtadr = dma_dst_phys_addr + 4096;	/* DMA target address */
+	desc->ddadr = (next << 24) + 256;    /* size: 256*16 bytes = 4096 bytes */
+
+	desc++;
+	next = (dma_desc_phys_addr + 3*(sizeof(jz_dma_desc))) >> 4;
+
+	desc->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_16BYTE | DMAC_DCMD_DES_V | DMAC_DCMD_DES_VM | DMAC_DCMD_DES_VIE | DMAC_DCMD_TIE | DMAC_DCMD_LINK;
+	desc->dsadr = dma_src_phys_addr + 8192;	/* DMA source address */
+	desc->dtadr = dma_dst_phys_addr + 8192;	/* DMA target address */
+	desc->ddadr = (next << 24) + 256;    /* size: 256*16 bytes = 4096 bytes */
+
+	desc++;
+	next = (dma_desc_phys_addr + 4*(sizeof(jz_dma_desc))) >> 4;
+
+	desc->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_32BIT | DMAC_DCMD_DES_V | DMAC_DCMD_DES_VM | DMAC_DCMD_DES_VIE | DMAC_DCMD_TIE;
+	desc->dsadr = dma_src_phys_addr + 12*1024;	/* DMA source address */
+	desc->dtadr = dma_dst_phys_addr + 12*1024;	/* DMA target address */
+	desc->ddadr = (next << 24) + 1024;    /* size: 1024*4 bytes = 4096 bytes */
+
+	dma_cache_wback((unsigned long)dma_desc, 4*(sizeof(jz_dma_desc)));
+
+	/* Setup DMA descriptor address */
+	REG_DMAC_DDA(dma_chan) = dma_desc_phys_addr;
+
+	/* Setup request source */
+	REG_DMAC_DRSR(dma_chan) = DMAC_DRSR_RS_AUTO;
+
+	/* Setup DMA channel control/status register */
+	REG_DMAC_DCCSR(dma_chan) = DMAC_DCCSR_EN;	/* descriptor transfer, clear status, start channel */
+
+	/* Enable DMA */
+	REG_DMAC_DMACR(dma_chan/HALF_DMA_NUM) = DMAC_DMACR_DMAE;
+
+	/* DMA doorbell set -- start DMA now ... */
+	REG_DMAC_DMADBSR(dma_chan/HALF_DMA_NUM) = 1 << dma_chan;
+
+	printk("DMA started. IMR=%08x\n", REG_INTC_IMR);
+	/* wait a long time, ensure transfer end */
+	printk("wait 3s...\n");
+	mdelay(3000);		/* wait 3s */
+
+	REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+	/* free buffers */
+	printk("free DMA buffers\n");
+	free_pages(dma_src_addr, 2);
+	free_pages(dma_dst_addr, 2);
+
+	if (dma_desc)
+		free_pages((unsigned int)dma_desc, 0);
+
+	/* free dma */
+	jz_free_dma(dma_chan);
+}
+
+#endif
+
+//EXPORT_SYMBOL_NOVERS(jz_dma_table);
+EXPORT_SYMBOL(jz_dma_table);
+EXPORT_SYMBOL(jz_request_dma);
+EXPORT_SYMBOL(jz_free_dma);
+EXPORT_SYMBOL(jz_set_dma_src_width);
+EXPORT_SYMBOL(jz_set_dma_dest_width);
+EXPORT_SYMBOL(jz_set_dma_block_size);
+EXPORT_SYMBOL(jz_set_dma_mode);
+EXPORT_SYMBOL(set_dma_mode);
+EXPORT_SYMBOL(jz_set_oss_dma);
+EXPORT_SYMBOL(jz_set_alsa_dma);
+EXPORT_SYMBOL(set_dma_addr);
+EXPORT_SYMBOL(set_dma_count);
+EXPORT_SYMBOL(get_dma_residue);
+EXPORT_SYMBOL(enable_dma);
+EXPORT_SYMBOL(disable_dma);
+EXPORT_SYMBOL(dump_jz_dma_channel);
--- linux-2.6.24.7.old/arch/mips/jz4750/i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750/i2c.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,273 @@
+/*
+ * linux/arch/mips/jz4750/i2c.c
+ *
+ * Jz4750 I2C routines.
+ *
+ * Copyright (C) 2005,2006 Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <asm/addrspace.h>
+
+#include <asm/jzsoc.h>
+
+/* I2C protocol */
+#define I2C_READ	1
+#define I2C_WRITE	0
+
+#define TIMEOUT         1000
+
+/*
+ * I2C bus protocol basic routines
+ */
+static int i2c_put_data(unsigned char data)
+{
+	unsigned int timeout = TIMEOUT*10;
+
+	__i2c_write(data);
+	__i2c_set_drf();
+	while (__i2c_check_drf() != 0);
+	while (!__i2c_transmit_ended());
+	while (!__i2c_received_ack() && timeout)
+		timeout--;
+
+	if (timeout)
+		return 0;
+	else
+		return -ETIMEDOUT;
+}
+
+#ifdef CONFIG_JZ_TPANEL_ATA2508
+static int i2c_put_data_nack(unsigned char data)
+{
+	unsigned int timeout = TIMEOUT*10;
+
+	__i2c_write(data);
+	__i2c_set_drf();
+	while (__i2c_check_drf() != 0);
+	while (!__i2c_transmit_ended());
+	while (timeout--);
+		return 0;
+}
+#endif
+
+static int i2c_get_data(unsigned char *data, int ack)
+{
+	int timeout = TIMEOUT*10;
+
+	if (!ack)
+		__i2c_send_nack();
+	else
+		__i2c_send_ack();
+
+	while (__i2c_check_drf() == 0 && timeout)
+		timeout--;
+
+	if (timeout) {
+		if (!ack)
+			__i2c_send_stop();
+		*data = __i2c_read();
+		__i2c_clear_drf();
+		return 0;
+	} else
+		return -ETIMEDOUT;
+}
+
+/*
+ * I2C interface
+ */
+void i2c_open(void)
+{
+	__i2c_set_clk(jz_clocks.extalclk, 10000); /* default 10 KHz */
+	__i2c_enable();
+}
+
+void i2c_close(void)
+{
+	udelay(300); /* wait for STOP goes over. */
+	__i2c_disable();
+}
+
+void i2c_setclk(unsigned int i2cclk)
+{
+	__i2c_set_clk(jz_clocks.extalclk, i2cclk);
+}
+
+int i2c_lseek(unsigned char device, unsigned char offset)
+{
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_err;
+	if (i2c_put_data(offset) < 0)
+		goto address_err;
+	return 0;
+ device_err:
+	printk(KERN_DEBUG "No I2C device (0x%02x) installed.\n", device);
+	__i2c_send_stop();
+	return -ENODEV;
+ address_err:
+	printk(KERN_DEBUG "No I2C device (0x%02x) response.\n", device);
+	__i2c_send_stop();
+	return -EREMOTEIO;
+}
+
+int i2c_read(unsigned char device, unsigned char *buf,
+	       unsigned char address, int count)
+{
+	int cnt = count;
+	int timeout = 5;
+
+L_try_again:
+
+	if (timeout < 0)
+		goto L_timeout;
+
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_werr;
+	if (i2c_put_data(address) < 0)
+		goto address_err;
+
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_READ ) < 0)
+		goto device_rerr;
+	__i2c_send_ack();	/* Master sends ACK for continue reading */
+	while (cnt) {
+		if (cnt == 1) {
+			if (i2c_get_data(buf, 0) < 0)
+				break;
+		} else {
+			if (i2c_get_data(buf, 1) < 0)
+				break;
+		}
+		cnt--;
+		buf++;
+	}
+
+	__i2c_send_stop();
+	return count - cnt;
+ device_rerr:
+ device_werr:
+ address_err:
+	timeout --;
+	__i2c_send_stop();
+	goto L_try_again;
+
+L_timeout:
+	__i2c_send_stop();
+	printk("Read I2C device 0x%2x failed.\n", device);
+	return -ENODEV;
+}
+
+int i2c_write(unsigned char device, unsigned char *buf,
+		unsigned char address, int count)
+{
+	int cnt = count;
+	int cnt_in_pg;
+	int timeout = 5;
+	unsigned char *tmpbuf;
+	unsigned char tmpaddr;
+
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+
+ W_try_again:
+	if (timeout < 0)
+		goto W_timeout;
+
+	cnt = count;
+	tmpbuf = (unsigned char *)buf;
+	tmpaddr = address;
+
+ start_write_page:
+	cnt_in_pg = 0;
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_err;
+#ifdef CONFIG_JZ_TPANEL_ATA2508
+	if (address == 0xff) {
+		if (i2c_put_data_nack(tmpaddr) < 0)
+			goto address_err;
+		while (cnt) {
+			if (++cnt_in_pg > 8) {
+				__i2c_send_stop();
+				mdelay(1);
+				tmpaddr += 8;
+				goto start_write_page;
+			}
+			if (i2c_put_data_nack(*tmpbuf) < 0)
+				break;
+			cnt--;
+			tmpbuf++;
+		}
+	}
+	else {
+
+		if (i2c_put_data(tmpaddr) < 0)
+			goto address_err;
+		while (cnt) {
+			if (++cnt_in_pg > 8) {
+				__i2c_send_stop();
+				mdelay(1);
+				tmpaddr += 8;
+				goto start_write_page;
+			}
+			if (i2c_put_data(*tmpbuf) < 0)
+				break;
+			cnt--;
+			tmpbuf++;
+		}
+	}
+#else
+	if (i2c_put_data(tmpaddr) < 0)
+		goto address_err;
+	while (cnt) {
+		if (++cnt_in_pg > 8) {
+			__i2c_send_stop();
+			mdelay(1);
+			tmpaddr += 8;
+			goto start_write_page;
+		}
+		if (i2c_put_data(*tmpbuf) < 0)
+			break;
+		cnt--;
+		tmpbuf++;
+	}
+#endif
+	__i2c_send_stop();
+	return count - cnt;
+ device_err:
+ address_err:
+	timeout--;
+	__i2c_send_stop();
+	goto W_try_again;
+
+ W_timeout:
+	printk(KERN_DEBUG "Write I2C device 0x%2x failed.\n", device);
+	__i2c_send_stop();
+	return -ENODEV;
+}
+
+EXPORT_SYMBOL(i2c_open);
+EXPORT_SYMBOL(i2c_close);
+EXPORT_SYMBOL(i2c_setclk);
+EXPORT_SYMBOL(i2c_read);
+EXPORT_SYMBOL(i2c_write);
--- linux-2.6.24.7.old/arch/mips/jz4750/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750/irq.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,299 @@
+/*
+ * linux/arch/mips/jz4750/irq.c
+ *
+ * JZ4750 interrupt routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/jzsoc.h>
+
+/*
+ * INTC irq type
+ */
+
+static void enable_intc_irq(unsigned int irq)
+{
+	__intc_unmask_irq(irq);
+}
+
+static void disable_intc_irq(unsigned int irq)
+{
+	__intc_mask_irq(irq);
+}
+
+static void mask_and_ack_intc_irq(unsigned int irq)
+{
+	__intc_mask_irq(irq);
+	__intc_ack_irq(irq);
+}
+
+static void end_intc_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		enable_intc_irq(irq);
+	}
+}
+
+static unsigned int startup_intc_irq(unsigned int irq)
+{
+	enable_intc_irq(irq);
+	return 0;
+}
+
+static void shutdown_intc_irq(unsigned int irq)
+{
+	disable_intc_irq(irq);
+}
+
+static struct irq_chip intc_irq_type = {
+	.typename = "INTC",
+	.startup = startup_intc_irq,
+	.shutdown = shutdown_intc_irq,
+	.enable = enable_intc_irq,
+	.disable = disable_intc_irq,
+	.ack = mask_and_ack_intc_irq,
+	.end = end_intc_irq,
+};
+
+/*
+ * GPIO irq type
+ */
+
+static void enable_gpio_irq(unsigned int irq)
+{
+	unsigned int intc_irq;
+
+	if (irq < (IRQ_GPIO_0 + 32)) {
+		intc_irq = IRQ_GPIO0;
+	}
+	else if (irq < (IRQ_GPIO_0 + 64)) {
+		intc_irq = IRQ_GPIO1;
+	}
+	else if (irq < (IRQ_GPIO_0 + 96)) {
+		intc_irq = IRQ_GPIO2;
+	}
+	else if (irq < (IRQ_GPIO_0 + 128)) {
+		intc_irq = IRQ_GPIO3;
+	}
+	else if (irq < (IRQ_GPIO_0 + 160)) {
+		intc_irq = IRQ_GPIO4;
+	}
+	else {
+		intc_irq = IRQ_GPIO5;
+	}
+
+	enable_intc_irq(intc_irq);
+	__gpio_unmask_irq(irq - IRQ_GPIO_0);
+}
+
+static void disable_gpio_irq(unsigned int irq)
+{
+	__gpio_mask_irq(irq - IRQ_GPIO_0);
+}
+
+static void mask_and_ack_gpio_irq(unsigned int irq)
+{
+	__gpio_mask_irq(irq - IRQ_GPIO_0);
+	__gpio_ack_irq(irq - IRQ_GPIO_0);
+}
+
+static void end_gpio_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		enable_gpio_irq(irq);
+	}
+}
+
+static unsigned int startup_gpio_irq(unsigned int irq)
+{
+	enable_gpio_irq(irq);
+	return 0;
+}
+
+static void shutdown_gpio_irq(unsigned int irq)
+{
+	disable_gpio_irq(irq);
+}
+
+static struct irq_chip gpio_irq_type = {
+	.typename = "GPIO",
+	.startup = startup_gpio_irq,
+	.shutdown = shutdown_gpio_irq,
+	.enable = enable_gpio_irq,
+	.disable = disable_gpio_irq,
+	.ack = mask_and_ack_gpio_irq,
+	.end = end_gpio_irq,
+};
+
+/*
+ * DMA irq type
+ */
+
+static void enable_dma_irq(unsigned int irq)
+{
+	unsigned int intc_irq;
+
+	if ( irq < (IRQ_DMA_0 + HALF_DMA_NUM) ) 	/* DMAC Group 0 irq */
+		intc_irq = IRQ_DMAC0;
+	else if ( irq < (IRQ_DMA_0 + MAX_DMA_NUM) ) 	/* DMAC Group 1 irq */
+		intc_irq = IRQ_DMAC1;
+	else {
+		printk("%s, unexpected dma irq #%d\n", __FILE__, irq);
+		return;
+	}
+	__intc_unmask_irq(intc_irq);
+	__dmac_channel_enable_irq(irq - IRQ_DMA_0);
+}
+
+static void disable_dma_irq(unsigned int irq)
+{
+	__dmac_channel_disable_irq(irq - IRQ_DMA_0);
+}
+
+static void mask_and_ack_dma_irq(unsigned int irq)
+{
+	unsigned int intc_irq;
+
+	if ( irq < (IRQ_DMA_0 + HALF_DMA_NUM) ) 	/* DMAC Group 0 irq */
+		intc_irq = IRQ_DMAC0;
+	else if ( irq < (IRQ_DMA_0 + MAX_DMA_NUM) ) 	/* DMAC Group 1 irq */
+		intc_irq = IRQ_DMAC1;
+	else {
+		printk("%s, unexpected dma irq #%d\n", __FILE__, irq);
+		return ;
+	}
+	__intc_ack_irq(intc_irq);
+	__dmac_channel_ack_irq(irq-IRQ_DMA_0); /* needed?? add 20080506, Wolfgang */
+	__dmac_channel_disable_irq(irq - IRQ_DMA_0);
+}
+
+static void end_dma_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		enable_dma_irq(irq);
+	}
+}
+
+static unsigned int startup_dma_irq(unsigned int irq)
+{
+	enable_dma_irq(irq);
+	return 0;
+}
+
+static void shutdown_dma_irq(unsigned int irq)
+{
+	disable_dma_irq(irq);
+}
+
+static struct irq_chip dma_irq_type = {
+	.typename = "DMA",
+	.startup = startup_dma_irq,
+	.shutdown = shutdown_dma_irq,
+	.enable = enable_dma_irq,
+	.disable = disable_dma_irq,
+	.ack = mask_and_ack_dma_irq,
+	.end = end_dma_irq,
+};
+
+//----------------------------------------------------------------------
+
+void __init arch_init_irq(void)
+{
+	int i;
+
+	clear_c0_status(0xff04); /* clear ERL */
+	set_c0_status(0x0400);   /* set IP2 */
+
+	/* Set up INTC irq
+	 */
+	for (i = 0; i < 32; i++) {
+		disable_intc_irq(i);
+		irq_desc[i].chip = &intc_irq_type;
+	}
+
+	/* Set up DMAC irq
+	 */
+	for (i = 0; i < NUM_DMA; i++) {
+		disable_dma_irq(IRQ_DMA_0 + i);
+		irq_desc[IRQ_DMA_0 + i].chip = &dma_irq_type;
+	}
+
+	/* Set up GPIO irq
+	 */
+	for (i = 0; i < NUM_GPIO; i++) {
+		disable_gpio_irq(IRQ_GPIO_0 + i);
+		irq_desc[IRQ_GPIO_0 + i].chip = &gpio_irq_type;
+	}
+}
+
+static int plat_real_irq(int irq)
+{
+	switch (irq) {
+	case IRQ_GPIO0:
+		irq = __gpio_group_irq(0) + IRQ_GPIO_0;
+		break;
+	case IRQ_GPIO1:
+		irq = __gpio_group_irq(1) + IRQ_GPIO_0 + 32;
+		break;
+	case IRQ_GPIO2:
+		irq = __gpio_group_irq(2) + IRQ_GPIO_0 + 64;
+		break;
+	case IRQ_GPIO3:
+		irq = __gpio_group_irq(3) + IRQ_GPIO_0 + 96;
+		break;
+	case IRQ_GPIO4:
+		irq = __gpio_group_irq(4) + IRQ_GPIO_0 + 128;
+		break;
+	case IRQ_GPIO5:
+		irq = __gpio_group_irq(5) + IRQ_GPIO_0 + 160;
+		break;
+	case IRQ_DMAC0:
+	case IRQ_DMAC1:
+		irq = __dmac_get_irq() + IRQ_DMA_0;
+		break;
+	}
+
+	return irq;
+}
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	int irq = 0;
+	static unsigned long intc_ipr = 0;
+
+	intc_ipr |= REG_INTC_IPR;
+
+	if (!intc_ipr)	return;
+
+	irq = ffs(intc_ipr) - 1;
+	intc_ipr &= ~(1<<irq);
+
+	irq = plat_real_irq(irq);
+	do_IRQ(irq);
+}
--- linux-2.6.24.7.old/arch/mips/jz4750/platform.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750/platform.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,141 @@
+/*
+ * Platform device support for Jz4740 SoC.
+ *
+ * Copyright 2007, <yliu@ingenic.cn>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/resource.h>
+
+#include <asm/jzsoc.h>
+
+/* OHCI (USB full speed host controller) */
+static struct resource jz_usb_ohci_resources[] = {
+	[0] = {
+		.start		= CPHYSADDR(UHC_BASE), // phys addr for ioremap
+		.end		= CPHYSADDR(UHC_BASE) + 0x10000 - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_UHC,
+		.end		= IRQ_UHC,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+/* The dmamask must be set for OHCI to work */
+static u64 ohci_dmamask = ~(u32)0;
+
+static struct platform_device jz_usb_ohci_device = {
+	.name		= "jz-ohci",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &ohci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(jz_usb_ohci_resources),
+	.resource	= jz_usb_ohci_resources,
+};
+
+/*** LCD controller ***/
+static struct resource jz_lcd_resources[] = {
+	[0] = {
+		.start          = CPHYSADDR(LCD_BASE),
+		.end            = CPHYSADDR(LCD_BASE) + 0x10000 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start          = IRQ_LCD,
+		.end            = IRQ_LCD,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static u64 jz_lcd_dmamask = ~(u32)0;
+
+static struct platform_device jz_lcd_device = {
+	.name           = "jz-lcd",
+	.id             = 0,
+	.dev = {
+		.dma_mask               = &jz_lcd_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(jz_lcd_resources),
+	.resource       = jz_lcd_resources,
+};
+
+/* UDC (USB gadget controller) */
+static struct resource jz_usb_gdt_resources[] = {
+	[0] = {
+		.start		= CPHYSADDR(UDC_BASE),
+		.end		= CPHYSADDR(UDC_BASE) + 0x10000 - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_UDC,
+		.end		= IRQ_UDC,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static u64 udc_dmamask = ~(u32)0;
+
+static struct platform_device jz_usb_gdt_device = {
+	.name		= "jz-udc",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &udc_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(jz_usb_gdt_resources),
+	.resource	= jz_usb_gdt_resources,
+};
+
+/** MMC/SD controller **/
+static struct resource jz_mmc_resources[] = {
+	[0] = {
+		.start          = CPHYSADDR(MSC_BASE),
+		.end            = CPHYSADDR(MSC_BASE) + 0x10000 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start          = IRQ_MSC0,
+		.end            = IRQ_MSC0,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static u64 jz_mmc_dmamask =  ~(u32)0;
+
+static struct platform_device jz_mmc_device = {
+	.name = "jz-mmc",
+	.id = 0,
+	.dev = {
+		.dma_mask               = &jz_mmc_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(jz_mmc_resources),
+	.resource       = jz_mmc_resources,
+};
+
+/* All */
+static struct platform_device *jz_platform_devices[] __initdata = {
+	&jz_usb_ohci_device,
+	&jz_lcd_device,
+	&jz_usb_gdt_device,
+	&jz_mmc_device,
+};
+
+static int __init jz_platform_init(void)
+{
+	return platform_add_devices(jz_platform_devices, ARRAY_SIZE(jz_platform_devices));
+}
+
+arch_initcall(jz_platform_init);
--- linux-2.6.24.7.old/arch/mips/jz4750/pm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750/pm.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,461 @@
+/*
+ * linux/arch/mips/jz4750/common/pm.c
+ *
+ * JZ4750 Power Management Routines
+ *
+ * Copyright (C) 2006 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/pm.h>
+#include <linux/pm_legacy.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/sysctl.h>
+
+#include <asm/cacheops.h>
+#include <asm/jzsoc.h>
+
+#undef DEBUG
+//#define DEBUG
+#ifdef DEBUG
+#define dprintk(x...)	printk(x)
+#else
+#define dprintk(x...)
+#endif
+
+#define GPIO_PORT_NUM   6
+
+/*
+ * __gpio_as_sleep set all pins to pull-disable, and set all pins as input
+ * except sdram and the pins which can be used as CS1_N to CS4_N for chip select.
+ */
+#define __gpio_as_sleep()	              \
+do {	                                      \
+	REG_GPIO_PXFUNC(1) = ~0x03ff7fff;     \
+	REG_GPIO_PXSELC(1) = ~0x03ff7fff;     \
+	REG_GPIO_PXDIRC(1) = ~0x03ff7fff;     \
+	REG_GPIO_PXPES(1)  =  0xffffffff;     \
+	REG_GPIO_PXFUNC(2) = ~0x01e00000;     \
+	REG_GPIO_PXSELC(2) = ~0x01e00000;     \
+	REG_GPIO_PXDIRC(2) = ~0x01e00000;     \
+	REG_GPIO_PXPES(2)  =  0xffffffff;     \
+	REG_GPIO_PXFUNC(3) =  0xffffffff;     \
+	REG_GPIO_PXSELC(3) =  0xffffffff;     \
+	REG_GPIO_PXDIRC(3) =  0xffffffff;     \
+	REG_GPIO_PXPES(3)  =  0xffffffff;     \
+	REG_GPIO_PXFUNC(4) =  0xffffffff;     \
+	REG_GPIO_PXSELC(4) =  0xffffffff;     \
+	REG_GPIO_PXDIRC(4) =  0xffffffff;     \
+	REG_GPIO_PXPES(4)  =  0xffffffff;     \
+	REG_GPIO_PXFUNC(5) =  0xffffffff;     \
+	REG_GPIO_PXSELC(5) =  0xffffffff;     \
+	REG_GPIO_PXDIRC(5) =  0xffffffff;     \
+	REG_GPIO_PXPES(5)  =  0xffffffff;     \
+} while (0)
+
+static int jz_pm_do_hibernate(void)
+{
+	printk("Put CPU into hibernate mode.\n");
+
+	/* Mask all interrupts */
+	REG_INTC_IMSR = 0xffffffff;
+
+	/*
+	 * RTC Wakeup or 1Hz interrupt can be enabled or disabled
+	 * through  RTC driver's ioctl (linux/driver/char/rtc_jz.c).
+	 */
+
+	/* Set minimum wakeup_n pin low-level assertion time for wakeup: 100ms */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HWFCR = (100 << RTC_HWFCR_BIT);
+
+	/* Set reset pin low-level assertion time after wakeup: must  > 60ms */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HRCR = (60 << RTC_HRCR_BIT); /* 60 ms */
+
+	/* Scratch pad register to be reserved */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HSPR = 0x12345678;
+
+	/* clear wakeup status register */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HWRSR = 0x0;
+
+	/* Put CPU to power down mode */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HCR = RTC_HCR_PD;
+
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	while(1);
+
+	/* We can't get here */
+	return 0;
+}
+
+/* NOTES:
+ * 1: Pins that are floated (NC) should be set as input and pull-enable.
+ * 2: Pins that are pull-up or pull-down by outside should be set as input
+ *    and pull-disable.
+ * 3: Pins that are connected to a chip except sdram and nand flash
+ *    should be set as input and pull-disable, too.
+ */
+static void jz_board_do_sleep(unsigned long *ptr)
+{
+	unsigned char i;
+
+        /* Print messages of GPIO registers for debug */
+	for(i=0;i<GPIO_PORT_NUM;i++) {
+		dprintk("run dat:%x pin:%x fun:%x sel:%x dir:%x pull:%x msk:%x trg:%x\n",        \
+			REG_GPIO_PXDAT(i),REG_GPIO_PXPIN(i),REG_GPIO_PXFUN(i),REG_GPIO_PXSEL(i), \
+			REG_GPIO_PXDIR(i),REG_GPIO_PXPE(i),REG_GPIO_PXIM(i),REG_GPIO_PXTRG(i));
+	}
+
+        /* Save GPIO registers */
+	for(i = 1; i < GPIO_PORT_NUM; i++) {
+		*ptr++ = REG_GPIO_PXFUN(i);
+		*ptr++ = REG_GPIO_PXSEL(i);
+		*ptr++ = REG_GPIO_PXDIR(i);
+		*ptr++ = REG_GPIO_PXPE(i);
+		*ptr++ = REG_GPIO_PXIM(i);
+		*ptr++ = REG_GPIO_PXDAT(i);
+		*ptr++ = REG_GPIO_PXTRG(i);
+	}
+
+        /*
+         * Set all pins to pull-disable, and set all pins as input except
+         * sdram and the pins which can be used as CS1_N to CS4_N for chip select.
+         */
+        __gpio_as_sleep();
+
+        /*
+	 * Set proper status for GPC21 to GPC24 which can be used as CS1_N to CS4_N.
+	 * Keep the pins' function used for chip select(CS) here according to your
+         * system to avoid chip select crashing with sdram when resuming from sleep mode.
+         */
+
+#if defined(CONFIG_JZ4750_APUS)
+        /* GPB25/CS1_N is used as chip select for nand flash, shouldn't be change. */
+
+        /* GPB26/CS2_N is connected to nand flash, needn't be changed. */
+
+        /* GPB28/CS3_N is used as cs8900's chip select, shouldn't be changed. */
+
+	/* GPB27/CS4_N is used as NOR's chip select, shouldn't be changed. */
+#endif
+
+ 	/*
+         * Enable pull for NC pins here according to your system
+	 */
+
+#if defined(CONFIG_JZ4750_APUS)
+#endif
+
+	/*
+         * If you must set some GPIOs as output to high level or low level,
+         * you can set them here, using:
+         * __gpio_as_output(n);
+         * __gpio_set_pin(n); or  __gpio_clear_pin(n);
+	 */
+
+#if defined(CONFIG_JZ4750_APUS)
+	/* GPC7 which is used as AMPEN_N should be set to high to disable audio amplifier */
+	__gpio_as_output(32*2+7);
+	__gpio_set_pin(32*2+7);
+#endif
+
+#ifdef DEBUG
+        /* Keep uart function for printing debug message */
+	__gpio_as_uart0();
+	__gpio_as_uart1();
+	__gpio_as_uart2();
+	__gpio_as_uart3();
+
+        /* Print messages of GPIO registers for debug */
+	for(i=0;i<GPIO_PORT_NUM;i++) {
+		dprintk("sleep dat:%x pin:%x fun:%x sel:%x dir:%x pull:%x msk:%x trg:%x\n",      \
+			REG_GPIO_PXDAT(i),REG_GPIO_PXPIN(i),REG_GPIO_PXFUN(i),REG_GPIO_PXSEL(i), \
+			REG_GPIO_PXDIR(i),REG_GPIO_PXPE(i),REG_GPIO_PXIM(i),REG_GPIO_PXTRG(i));
+	}
+#endif
+}
+
+static void jz_board_do_resume(unsigned long *ptr)
+{
+	unsigned char i;
+
+	/* Restore GPIO registers */
+	for(i = 1; i < GPIO_PORT_NUM; i++) {
+		 REG_GPIO_PXFUNS(i) = *ptr;
+		 REG_GPIO_PXFUNC(i) = ~(*ptr++);
+
+		 REG_GPIO_PXSELS(i) = *ptr;
+		 REG_GPIO_PXSELC(i) = ~(*ptr++);
+
+		 REG_GPIO_PXDIRS(i) = *ptr;
+		 REG_GPIO_PXDIRC(i) = ~(*ptr++);
+
+		 REG_GPIO_PXPES(i) = *ptr;
+		 REG_GPIO_PXPEC(i) = ~(*ptr++);
+
+		 REG_GPIO_PXIMS(i)=*ptr;
+		 REG_GPIO_PXIMC(i)=~(*ptr++);
+
+		 REG_GPIO_PXDATS(i)=*ptr;
+		 REG_GPIO_PXDATC(i)=~(*ptr++);
+
+		 REG_GPIO_PXTRGS(i)=*ptr;
+		 REG_GPIO_PXTRGC(i)=~(*ptr++);
+	}
+
+        /* Print messages of GPIO registers for debug */
+	for(i=0;i<GPIO_PORT_NUM;i++) {
+		dprintk("resume dat:%x pin:%x fun:%x sel:%x dir:%x pull:%x msk:%x trg:%x\n",     \
+			REG_GPIO_PXDAT(i),REG_GPIO_PXPIN(i),REG_GPIO_PXFUN(i),REG_GPIO_PXSEL(i), \
+			REG_GPIO_PXDIR(i),REG_GPIO_PXPE(i),REG_GPIO_PXIM(i),REG_GPIO_PXTRG(i));
+	}
+}
+
+
+
+static int jz_pm_do_sleep(void)
+{
+	unsigned long delta;
+	unsigned long nfcsr = REG_EMC_NFCSR;
+	unsigned long opcr = REG_CPM_OPCR;
+	unsigned long imr = REG_INTC_IMR;
+	unsigned long sadc = REG_SADC_ENA;
+	unsigned long sleep_gpio_save[7*(GPIO_PORT_NUM-1)];
+
+	printk("Put CPU into sleep mode.\n");
+
+	/* Preserve current time */
+	delta = xtime.tv_sec - REG_RTC_RSR;
+
+        /* Disable nand flash */
+	REG_EMC_NFCSR = ~0xff;
+
+        /* stop sadc */
+	REG_SADC_ENA &= ~0x7;
+	while((REG_SADC_ENA & 0x7) != 0);
+ 	udelay(100);
+
+        /*stop udc and usb*/
+	__cpm_suspend_uhcphy();
+	__cpm_suspend_udcphy();
+
+	/* Sleep on-board modules */
+	jz_board_do_sleep(sleep_gpio_save);
+
+	/* Mask all interrupts */
+	REG_INTC_IMSR = 0xffffffff;
+
+	/* Just allow following interrupts to wakeup the system.
+	 * Note: modify this according to your system.
+	 */
+
+	/* enable RTC alarm */
+	__intc_unmask_irq(IRQ_RTC);
+#if 0
+        /* make system wake up after n seconds by RTC alarm */
+	unsigned int v, n;
+	n = 10;
+	while (!__rtc_write_ready());
+	__rtc_enable_alarm();
+	while (!__rtc_write_ready());
+	__rtc_enable_alarm_irq();
+ 	while (!__rtc_write_ready());
+ 	v = __rtc_get_second();
+ 	while (!__rtc_write_ready());
+ 	__rtc_set_alarm_second(v+n);
+#endif
+
+	/* WAKEUP key */
+	__gpio_as_irq_rise_edge(GPIO_WAKEUP);
+	__gpio_unmask_irq(GPIO_WAKEUP);
+	__intc_unmask_irq(IRQ_GPIO0 - (GPIO_WAKEUP/32));  /* unmask IRQ_GPIOn depends on GPIO_WAKEUP */
+
+	/* disable externel clock Oscillator in sleep mode */
+	__cpm_disable_osc_in_sleep();
+	/* select 32K crystal as RTC clock in sleep mode */
+	__cpm_select_rtcclk_rtc();
+
+ 	/* Enter SLEEP mode */
+	REG_CPM_LCR &= ~CPM_LCR_LPM_MASK;
+	REG_CPM_LCR |= CPM_LCR_LPM_SLEEP;
+	__asm__(".set\tmips3\n\t"
+		"wait\n\t"
+		".set\tmips0");
+
+	/* Restore to IDLE mode */
+	REG_CPM_LCR &= ~CPM_LCR_LPM_MASK;
+	REG_CPM_LCR |= CPM_LCR_LPM_IDLE;
+
+        /* Restore nand flash control register */
+	REG_EMC_NFCSR = nfcsr;
+
+	/* Restore interrupts */
+	REG_INTC_IMSR = imr;
+	REG_INTC_IMCR = ~imr;
+
+	/* Restore sadc */
+	REG_SADC_ENA = sadc;
+
+	/* Resume on-board modules */
+	jz_board_do_resume(sleep_gpio_save);
+
+	/* Restore Oscillator and Power Control Register */
+	REG_CPM_OPCR = opcr;
+
+	/* Restore current time */
+	xtime.tv_sec = REG_RTC_RSR + delta;
+
+	return 0;
+}
+
+/* Put CPU to HIBERNATE mode */
+int jz_pm_hibernate(void)
+{
+	return jz_pm_do_hibernate();
+}
+
+#ifndef CONFIG_JZ_POWEROFF
+static irqreturn_t pm_irq_handler (int irq, void *dev_id)
+{
+	return IRQ_HANDLED;
+}
+#endif
+
+/* Put CPU to SLEEP mode */
+int jz_pm_sleep(void)
+{
+	int retval;
+
+#ifndef CONFIG_JZ_POWEROFF
+	if ((retval = request_irq (IRQ_GPIO_0 + GPIO_WAKEUP, pm_irq_handler, IRQF_DISABLED,
+				   "PM", NULL))) {
+		printk ("PM could not get IRQ for GPIO_WAKEUP\n");
+		return retval;
+	}
+#endif
+
+	pm_send_all(PM_SUSPEND, (void *)3);
+	retval = jz_pm_do_sleep();
+	pm_send_all(PM_RESUME, (void *)0);
+
+#ifndef CONFIG_JZ_POWEROFF
+	free_irq (IRQ_GPIO_0 + GPIO_WAKEUP, NULL);
+#endif
+
+	return retval;
+}
+
+#if 0
+/* Deprecated ,was used by dpm */
+void jz_pm_idle(void)
+{
+	local_irq_disable();
+	if (!need_resched()) {
+		local_irq_enable();
+		cpu_wait();
+	}
+}
+#endif
+
+
+#ifdef CONFIG_SYSCTL
+
+/*
+ * Use a temporary sysctl number. Horrid, but will be cleaned up in 2.6
+ * when all the PM interfaces exist nicely.
+ */
+#define CTL_PM_SUSPEND   1
+#define CTL_PM_HIBERNATE 2
+
+/*----------------------------------------------------------------------------
+ * Power Management sleep sysctl proc interface
+ *
+ * A write to /proc/sys/pm/suspend invokes this function
+ * which initiates a sleep.
+ *--------------------------------------------------------------------------*/
+static int sysctl_jz_pm_sleep(void)
+{
+	return jz_pm_sleep();
+}
+
+/*----------------------------------------------------------------------------
+ * Power Management sleep sysctl proc interface
+ *
+ * A write to /proc/sys/pm/hibernate invokes this function
+ * which initiates a poweroff.
+ *--------------------------------------------------------------------------*/
+static int sysctl_jz_pm_hibernate(void)
+{
+	return jz_pm_hibernate();
+}
+
+static struct ctl_table pm_table[] =
+{
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "suspend",
+		.data		= NULL,
+		.maxlen		= 0,
+		.mode		= 0600,
+		.proc_handler	= &sysctl_jz_pm_sleep,
+	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "hibernate",
+		.data		= NULL,
+		.maxlen		= 0,
+		.mode		= 0600,
+		.proc_handler	= &sysctl_jz_pm_hibernate,
+	},
+	{ .ctl_name = 0}
+};
+
+static struct ctl_table pm_dir_table[] =
+{
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "pm",
+		.mode		= 0555,
+		.child		= pm_table,
+	},
+	{ .ctl_name = 0}
+};
+
+#endif /* CONFIG_SYSCTL */
+
+/*
+ * Initialize power interface
+ */
+static int __init jz_pm_init(void)
+{
+	printk("Power Management for JZ\n");
+
+#ifdef CONFIG_SYSCTL
+	register_sysctl_table(pm_dir_table);
+#endif
+
+	return 0;
+}
+
+module_init(jz_pm_init);
--- linux-2.6.24.7.old/arch/mips/jz4750/proc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750/proc.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,905 @@
+/*
+ * linux/arch/mips/jz4750/proc.c
+ *
+ * /proc/jz/ procfs for jz4750 on-chip modules.
+ *
+ * Copyright (C) 2006 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/sysctl.h>
+#include <linux/proc_fs.h>
+#include <linux/page-flags.h>
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+#include <asm/jzsoc.h>
+
+//#define DEBUG 1
+#undef DEBUG
+
+
+struct proc_dir_entry *proc_jz_root;
+
+
+/*
+ * EMC Modules
+ */
+static int emc_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+
+	len += sprintf (page+len, "SMCR(0-5): 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", REG_EMC_SMCR0, REG_EMC_SMCR1, REG_EMC_SMCR2, REG_EMC_SMCR3, REG_EMC_SMCR4);
+	len += sprintf (page+len, "SACR(0-5): 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", REG_EMC_SACR0, REG_EMC_SACR1, REG_EMC_SACR2, REG_EMC_SACR3, REG_EMC_SACR4);
+	len += sprintf (page+len, "DMCR:      0x%08x\n", REG_EMC_DMCR);
+	len += sprintf (page+len, "RTCSR:     0x%04x\n", REG_EMC_RTCSR);
+	len += sprintf (page+len, "RTCOR:     0x%04x\n", REG_EMC_RTCOR);
+	return len;
+}
+
+/*
+ * Power Manager Module
+ */
+static int pmc_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	unsigned long lcr = REG_CPM_LCR;
+	unsigned long clkgr = REG_CPM_CLKGR;
+
+	len += sprintf (page+len, "Low Power Mode : %s\n",
+			((lcr & CPM_LCR_LPM_MASK) == (CPM_LCR_LPM_IDLE)) ?
+			"IDLE" : (((lcr & CPM_LCR_LPM_MASK) == (CPM_LCR_LPM_SLEEP)) ?
+				  "SLEEP" : "HIBERNATE"));
+	len += sprintf (page+len, "Doze Mode      : %s\n",
+			(lcr & CPM_LCR_DOZE_ON) ? "on" : "off");
+	if (lcr & CPM_LCR_DOZE_ON)
+		len += sprintf (page+len, "     duty      : %d\n", (int)((lcr & CPM_LCR_DOZE_DUTY_MASK) >> CPM_LCR_DOZE_DUTY_BIT));
+	len += sprintf (page+len, "IPU            : %s\n",
+			(clkgr & CPM_CLKGR_IPU) ? "stopped" : "running");
+	len += sprintf (page+len, "DMAC           : %s\n",
+			(clkgr & CPM_CLKGR_DMAC) ? "stopped" : "running");
+	len += sprintf (page+len, "UHC            : %s\n",
+			(clkgr & CPM_CLKGR_UHC) ? "stopped" : "running");
+	len += sprintf (page+len, "UDC            : %s\n",
+			(clkgr & CPM_CLKGR_UDC) ? "stopped" : "running");
+	len += sprintf (page+len, "LCD            : %s\n",
+			(clkgr & CPM_CLKGR_LCD) ? "stopped" : "running");
+	len += sprintf (page+len, "CIM            : %s\n",
+			(clkgr & CPM_CLKGR_CIM) ? "stopped" : "running");
+	len += sprintf (page+len, "SADC           : %s\n",
+			(clkgr & CPM_CLKGR_SADC) ? "stopped" : "running");
+	len += sprintf (page+len, "MSC0           : %s\n",
+			(clkgr & CPM_CLKGR_MSC0) ? "stopped" : "running");
+	len += sprintf (page+len, "MSC1           : %s\n",
+			(clkgr & CPM_CLKGR_MSC1) ? "stopped" : "running");
+	len += sprintf (page+len, "AIC1           : %s\n",
+			(clkgr & CPM_CLKGR_AIC1) ? "stopped" : "running");
+	len += sprintf (page+len, "AIC2           : %s\n",
+			(clkgr & CPM_CLKGR_AIC2) ? "stopped" : "running");
+	len += sprintf (page+len, "SSI0           : %s\n",
+			(clkgr & CPM_CLKGR_SSI0) ? "stopped" : "running");
+	len += sprintf (page+len, "SSI1           : %s\n",
+			(clkgr & CPM_CLKGR_SSI1) ? "stopped" : "running");
+	len += sprintf (page+len, "I2C            : %s\n",
+			(clkgr & CPM_CLKGR_I2C) ? "stopped" : "running");
+	len += sprintf (page+len, "RTC            : %s\n",
+			(clkgr & CPM_CLKGR_RTC) ? "stopped" : "running");
+	len += sprintf (page+len, "TCU            : %s\n",
+			(clkgr & CPM_CLKGR_TCU) ? "stopped" : "running");
+	len += sprintf (page+len, "UART1          : %s\n",
+			(clkgr & CPM_CLKGR_UART1) ? "stopped" : "running");
+	len += sprintf (page+len, "UART0          : %s\n",
+			(clkgr & CPM_CLKGR_UART0) ? "stopped" : "running");
+	return len;
+}
+
+static int pmc_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	REG_CPM_CLKGR = simple_strtoul(buffer, 0, 16);
+	return count;
+}
+
+/*
+ * Clock Generation Module
+ */
+#define TO_MHZ(x) (x/1000000),(x%1000000)/10000
+#define TO_KHZ(x) (x/1000),(x%1000)/10
+
+static int cgm_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	unsigned int cppcr = REG_CPM_CPPCR;  /* PLL Control Register */
+	unsigned int cpccr = REG_CPM_CPCCR;  /* Clock Control Register */
+	unsigned int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned int od[4] = {1, 2, 2, 4};
+
+	len += sprintf (page+len, "CPPCR          : 0x%08x\n", cppcr);
+	len += sprintf (page+len, "CPCCR          : 0x%08x\n", cpccr);
+	len += sprintf (page+len, "PLL            : %s\n",
+			(cppcr & CPM_CPPCR_PLLEN) ? "ON" : "OFF");
+	len += sprintf (page+len, "m:n:o          : %d:%d:%d\n",
+			__cpm_get_pllm() + 2,
+			__cpm_get_plln() + 2,
+			od[__cpm_get_pllod()]
+		);
+	len += sprintf (page+len, "C:H:M:P        : %d:%d:%d:%d\n",
+			div[__cpm_get_cdiv()],
+			div[__cpm_get_hdiv()],
+			div[__cpm_get_mdiv()],
+			div[__cpm_get_pdiv()]
+		);
+	len += sprintf (page+len, "PLL Freq        : %3d.%02d MHz\n", TO_MHZ(__cpm_get_pllout()));
+	len += sprintf (page+len, "CCLK            : %3d.%02d MHz\n", TO_MHZ(__cpm_get_cclk()));
+	len += sprintf (page+len, "HCLK            : %3d.%02d MHz\n", TO_MHZ(__cpm_get_hclk()));
+	len += sprintf (page+len, "MCLK            : %3d.%02d MHz\n", TO_MHZ(__cpm_get_mclk()));
+	len += sprintf (page+len, "PCLK            : %3d.%02d MHz\n", TO_MHZ(__cpm_get_pclk()));
+	len += sprintf (page+len, "LCDCLK          : %3d.%02d MHz\n", TO_MHZ(__cpm_get_lcdclk()));
+	len += sprintf (page+len, "PIXCLK          : %3d.%02d KHz\n", TO_KHZ(__cpm_get_pixclk()));
+	len += sprintf (page+len, "I2SCLK          : %3d.%02d MHz\n", TO_MHZ(__cpm_get_i2sclk()));
+	len += sprintf (page+len, "USBCLK          : %3d.%02d MHz\n", TO_MHZ(__cpm_get_usbclk()));
+	len += sprintf (page+len, "MSC0CLK         : %3d.%02d MHz\n", TO_MHZ(__cpm_get_mscclk(0)));
+	len += sprintf (page+len, "MSC1CLK         : %3d.%02d MHz\n", TO_MHZ(__cpm_get_mscclk(1)));
+	len += sprintf (page+len, "EXTALCLK0       : %3d.%02d MHz\n", TO_MHZ(__cpm_get_extalclk0()));
+	len += sprintf (page+len, "EXTALCLK(by CPM): %3d.%02d MHz\n", TO_MHZ(__cpm_get_extalclk()));
+	len += sprintf (page+len, "RTCCLK          : %3d.%02d MHz\n", TO_MHZ(__cpm_get_rtcclk()));
+
+	return len;
+}
+
+static int cgm_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	REG_CPM_CPCCR = simple_strtoul(buffer, 0, 16);
+	return count;
+}
+
+
+/* USAGE:
+ * echo n  > /proc/jz/ipu 	// n = [1,...,9], alloc mem, 2^n pages.
+ * echo FF > /proc/jz/ipu 	// 255, free all buffer
+ * echo xxxx > /proc/jz/ipu 	// free buffer which addr is xxxx
+ * echo llll > /proc/jz/ipu 	// add_wired_entry(l,l,l,l)
+ * echo 0  > /proc/jz/ipu 	// debug, print ipu_buf
+ * od -X /proc/jz/ipu 		// read mem addr
+ */
+
+typedef struct _ipu_buf {
+	unsigned int addr;	/* phys addr */
+	unsigned int page_shift;
+} ipu_buf_t;
+
+#define IPU_BUF_MAX 		4 	/* 4 buffers */
+
+static struct _ipu_buf ipu_buf[IPU_BUF_MAX];
+static int ipu_buf_cnt = 0;
+static unsigned char g_asid=0;
+
+extern void local_flush_tlb_all(void);
+
+/* CP0 hazard avoidance. */
+#define BARRIER __asm__ __volatile__(".set noreorder\n\t" \
+				     "nop; nop; nop; nop; nop; nop;\n\t" \
+				     ".set reorder\n\t")
+void show_tlb(void)
+{
+#define ASID_MASK 0xFF
+
+        unsigned long flags;
+        unsigned int old_ctx;
+	unsigned int entry;
+	unsigned int entrylo0, entrylo1, entryhi;
+	unsigned int pagemask;
+
+	local_irq_save(flags);
+
+	/* Save old context */
+	old_ctx = (read_c0_entryhi() & 0xff);
+
+	printk("TLB content:\n");
+	entry = 0;
+	while(entry < 32) {
+		write_c0_index(entry);
+		BARRIER;
+		tlb_read();
+		BARRIER;
+		entryhi = read_c0_entryhi();
+		entrylo0 = read_c0_entrylo0();
+		entrylo1 = read_c0_entrylo1();
+		pagemask = read_c0_pagemask();
+		printk("%02d: ASID=%02d%s VA=0x%08x ", entry, entryhi & ASID_MASK, (entrylo0 & entrylo1 & 1) ? "(G)" : "   ", entryhi & ~ASID_MASK);
+		printk("PA0=0x%08x C0=%x %s%s%s\n", (entrylo0>>6)<<12, (entrylo0>>3) & 7, (entrylo0 & 4) ? "Dirty " : "", (entrylo0 & 2) ? "Valid " : "Invalid ", (entrylo0 & 1) ? "Global" : "");
+		printk("\t\t\t     PA1=0x%08x C1=%x %s%s%s\n", (entrylo1>>6)<<12, (entrylo1>>3) & 7, (entrylo1 & 4) ? "Dirty " : "", (entrylo1 & 2) ? "Valid " : "Invalid ", (entrylo1 & 1) ? "Global" : "");
+
+		printk("\t\tpagemask=0x%08x", pagemask);
+		printk("\tentryhi=0x%08x\n", entryhi);
+		printk("\t\tentrylo0=0x%08x", entrylo0);
+		printk("\tentrylo1=0x%08x\n", entrylo1);
+
+		entry++;
+	}
+	BARRIER;
+	write_c0_entryhi(old_ctx);
+
+	local_irq_restore(flags);
+}
+
+static void ipu_add_wired_entry(unsigned long pid,
+				unsigned long entrylo0, unsigned long entrylo1,
+				unsigned long entryhi, unsigned long pagemask)
+{
+	unsigned long flags;
+	unsigned long wired;
+	unsigned long old_pagemask;
+	unsigned long old_ctx;
+	struct task_struct *g, *p;
+
+	/* We will lock an 4MB page size entry to map the 4MB reserved IPU memory */
+	entrylo0 = entrylo0 >> 6;
+	entrylo0 |= 0x6 | (0 << 3);
+	/*entrylo0 |= 0x6 | (1 << 3);*/
+
+	do_each_thread(g, p) {
+		if (p->pid == pid )
+			g_asid = p->mm->context[0];
+	} while_each_thread(g, p);
+
+	local_irq_save(flags);
+	/* Save old context and create impossible VPN2 value */
+	old_ctx = read_c0_entryhi() & 0xff;
+	old_pagemask = read_c0_pagemask();
+	wired = read_c0_wired();
+	write_c0_wired(wired + 1);
+	write_c0_index(wired);
+	BARRIER;
+	entryhi &= ~0xff;	/* new add, 20070906 */
+	entryhi |= g_asid;	/* new add, 20070906 */
+//	entryhi |= old_ctx;	/* new add, 20070906 */
+	write_c0_pagemask(pagemask);
+	write_c0_entryhi(entryhi);
+	write_c0_entrylo0(entrylo0);
+	write_c0_entrylo1(entrylo1);
+	BARRIER;
+	tlb_write_indexed();
+	BARRIER;
+
+	write_c0_entryhi(old_ctx);
+	BARRIER;
+	write_c0_pagemask(old_pagemask);
+	local_flush_tlb_all();
+	local_irq_restore(flags);
+#if defined(DEBUG)
+	printk("\nold_ctx=%03d\n", old_ctx);
+
+	show_tlb();
+#endif
+}
+
+static void ipu_del_wired_entry( void )
+{
+	unsigned long flags;
+	unsigned long wired;
+
+	local_irq_save(flags);
+	wired = read_c0_wired();
+	if (wired) {
+		write_c0_wired(0);
+	}
+	local_irq_restore(flags);
+}
+
+static inline void ipu_buf_get( unsigned int page_shift )
+{
+	unsigned char * virt_addr;
+	int i;
+	for ( i=0; i< IPU_BUF_MAX; ++i ) {
+		if ( ipu_buf[i].addr == 0 ) {
+			break;
+		}
+	}
+
+	if ( (ipu_buf_cnt = i) == IPU_BUF_MAX ) {
+		printk("Error, no free ipu buffer.\n");
+		return ;
+	}
+
+	virt_addr =  (unsigned char *)__get_free_pages(GFP_KERNEL, page_shift);
+
+	if ( virt_addr ) {
+		ipu_buf[ipu_buf_cnt].addr = (unsigned int)virt_to_phys((void *)virt_addr);
+		ipu_buf[ipu_buf_cnt].page_shift = page_shift;
+
+		for (i = 0; i < (1<<page_shift); i++) {
+			SetPageReserved(virt_to_page(virt_addr));
+			virt_addr += PAGE_SIZE;
+		}
+	}
+	else {
+		printk("get memory Failed.\n");
+	}
+}
+
+static inline void ipu_buf_free( unsigned int phys_addr )
+{
+	unsigned char * virt_addr, *addr;
+	int cnt, i;
+
+	if ( phys_addr == 0 )
+		return ;
+
+	for ( cnt=0; cnt<IPU_BUF_MAX; ++cnt )
+		if ( phys_addr == ipu_buf[cnt].addr )
+			break;
+
+	if ( cnt == IPU_BUF_MAX ) {	/* addr not in the ipu buffers */
+		printk("Invalid addr:0x%08x\n", (unsigned int)phys_addr);
+	}
+
+	virt_addr = (unsigned char *)phys_to_virt(ipu_buf[cnt].addr);
+	addr = virt_addr;
+	for (i = 0; i < (1<<ipu_buf[cnt].page_shift); i++) {
+		ClearPageReserved(virt_to_page(addr));
+		addr += PAGE_SIZE;
+	}
+
+	if ( cnt == 0 )
+		ipu_del_wired_entry();
+
+	free_pages((unsigned long )virt_addr, ipu_buf[cnt].page_shift);
+
+	ipu_buf[cnt].addr = 0;
+	ipu_buf[cnt].page_shift = 0;
+}
+
+static int tlb_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	show_tlb();
+	return 0;
+}
+
+static int ipu_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+
+	/* read as binary */
+	unsigned int * pint;
+	pint = (unsigned int *) (page+len);
+
+	if ( ipu_buf_cnt >= IPU_BUF_MAX ) {	/* failed alloc mem, rturn 0 */
+		printk("no free buffer.\n");
+		*pint = 0;
+	}
+	else
+		*pint = (unsigned int )ipu_buf[ipu_buf_cnt].addr; /* phys addr */
+	len += sizeof(unsigned int);
+
+#if defined(DEBUG)
+		show_tlb();
+#endif
+	return len;
+
+}
+
+static int ipu_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	unsigned int val ;
+	int cnt,i;
+	char buf[12];
+	unsigned long pid, entrylo0, entrylo1, entryhi, pagemask;
+#if defined(DEBUG)
+	printk("ipu write count=%u\n", count);
+#endif
+	if (count == 41) {
+		for (i=0;i<12;i++)
+			buf[i]=0;
+		strncpy(buf, buffer+8*0, 8);
+		pid = simple_strtoul(buf, 0, 16);
+		for (i=0;i<12;i++)
+			buf[i]=0;
+		strncpy(buf, buffer+8*1, 8);
+		entrylo0 = simple_strtoul(buf, 0, 16);
+		for (i=0;i<12;i++)
+			buf[i]=0;
+		strncpy(buf, buffer+8*2, 8);
+		entrylo1 = simple_strtoul(buf, 0, 16);
+		for (i=0;i<12;i++)
+			buf[i]=0;
+		strncpy(buf, buffer+8*3, 8);
+		entryhi = simple_strtoul(buf, 0, 16);
+		for (i=0;i<12;i++)
+			buf[i]=0;
+		strncpy(buf, buffer+8*4, 8);
+		pagemask = simple_strtoul(buf, 0, 16);
+
+#if defined(DEBUG)
+		printk("pid=0x%08x, entrylo0=0x%08x, entrylo1=0x%08x, entryhi=0x%08x, pagemask=0x%08x\n",
+		       pid, entrylo0, entrylo1, entryhi, pagemask);
+#endif
+		ipu_add_wired_entry( pid, entrylo0, entrylo1, entryhi, pagemask);
+		return 41;
+	} else if ( count <= 9 ) {
+		for (i=0;i<12;i++) buf[i]=0;
+		strncpy(buf, buffer, 8);
+		val = simple_strtoul(buf, 0, 16);
+	} else if (count == 44) {
+		for (i = 0; i < 12; i++)
+			buf[i] = 0;
+		strncpy(buf, buffer, 10);
+		pid = simple_strtoul(buf, 0, 16);
+
+		for (i = 0; i < 12; i++)
+			buf[i] = 0;
+		strncpy(buf, buffer + 11, 10);
+		entryhi = simple_strtoul(buf, 0, 16);//vaddr
+
+		for (i = 0; i < 12; i++)
+			buf[i] = 0;
+		strncpy(buf, buffer + 22, 10);
+		entrylo0 = simple_strtoul(buf, 0, 16);//paddr
+
+		for (i = 0; i < 12; i++)
+			buf[i] = 0;
+		strncpy(buf, buffer + 33, 10);
+		pagemask = simple_strtoul(buf, 0, 16);
+		pagemask = 0x3ff << 13; /* Fixed to 4MB page size */
+		//pagemask = 0xfff << 13; /* Fixed to 16MB page size */
+
+		ipu_add_wired_entry(pid, entrylo0, 0, entryhi, pagemask);
+		return 44;
+	} else if (count == 12) {
+		printk("\necho release tlb > /proc/jz/ipu\n");
+		ipu_del_wired_entry();
+		return 12;
+	} else {
+		printk("ipu write count error, count=%d\n.", (unsigned int)count);
+		return -1;
+	}
+
+	/* val: 1-9, page_shift,  val>= 10: ipu_buf.addr */
+	if ( val == 0 ) {	/* debug, print ipu_buf info */
+		for ( cnt=0; cnt<IPU_BUF_MAX; ++cnt)
+			printk("ipu_buf[%d]: addr=0x%08x, page_shift=%d\n",
+			       cnt, ipu_buf[cnt].addr, ipu_buf[cnt].page_shift );
+#if defined(DEBUG)
+		show_tlb();
+#endif
+	}
+	else if ( 0< val && val < 10 ) {
+		ipu_buf_get(val);
+	}
+	else if ( val == 0xff ) { /* 255: free all ipu_buf */
+		for ( cnt=0; cnt<IPU_BUF_MAX; ++cnt ) {
+			ipu_buf_free(ipu_buf[cnt].addr);
+		}
+	}
+	else {
+		ipu_buf_free(val);
+	}
+
+	return count;
+}
+
+/*
+ * UDC hotplug
+ */
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+extern int jz_udc_active;	/* defined in drivers/char/jzchar/jz_udc_hotplug.c */
+#endif
+
+#ifndef GPIO_UDC_HOTPLUG
+#define GPIO_UDC_HOTPLUG 86
+#endif
+
+static int udc_read_proc(char *page, char **start, off_t off,
+			 int count, int *eof, void *data)
+{
+        int len = 0;
+
+	if (__gpio_get_pin(GPIO_UDC_HOTPLUG)) {
+
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+
+		/* Cable has connected, wait for disconnection. */
+		__gpio_as_irq_fall_edge(GPIO_UDC_HOTPLUG);
+
+		if (jz_udc_active)
+			len += sprintf (page+len, "CONNECT_CABLE\n");
+		else
+			len += sprintf (page+len, "CONNECT_POWER\n");
+#else
+		len += sprintf (page+len, "CONNECT\n");
+#endif
+	}
+	else {
+
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+		/* Cable has disconnected, wait for connection. */
+		__gpio_as_irq_rise_edge(GPIO_UDC_HOTPLUG);
+#endif
+
+		len += sprintf (page+len, "REMOVE\n");
+	}
+
+        return len;
+}
+
+/*
+ * MMC/SD hotplug
+ */
+
+#ifndef MSC_HOTPLUG_PIN
+#define MSC_HOTPLUG_PIN 90
+#endif
+
+static int mmc_read_proc (char *page, char **start, off_t off,
+                          int count, int *eof, void *data)
+{
+        int len = 0;
+
+#if defined(CONFIG_JZ4750_LYRA)
+        if (!(__gpio_get_pin(MSC_HOTPLUG_PIN)))
+#else
+        if (__gpio_get_pin(MSC_HOTPLUG_PIN))
+#endif
+                len += sprintf (page+len, "REMOVE\n");
+        else
+                len += sprintf (page+len, "INSERT\n");
+
+        return len;
+}
+
+/***********************************************************************
+ * IPU memory management (used by mplayer and other apps)
+ *
+ * We reserved 4MB memory for IPU
+ * The memory base address is jz_ipu_framebuf
+ */
+
+/* Usage:
+ *
+ * echo n  > /proc/jz/imem 		// n = [0,...,10], allocate memory, 2^n pages
+ * echo xxxxxxxx > /proc/jz/imem	// free buffer which addr is xxxxxxxx
+ * echo FF > /proc/jz/ipu 		// FF, free all buffers
+ * od -X /proc/jz/imem 			// return the allocated buffer address and the max order of free buffer
+ */
+
+//#define DEBUG_IMEM 1
+
+#define IMEM_MAX_ORDER 10		/* max 2^10 * 4096 = 4MB */
+
+static unsigned int jz_imem_base;	/* physical base address of ipu memory */
+
+static unsigned int allocated_phys_addr = 0;
+
+/*
+ * Allocated buffer list
+ */
+typedef struct imem_list {
+	unsigned int phys_start;	/* physical start addr */
+	unsigned int phys_end;		/* physical end addr */
+	struct imem_list *next;
+} imem_list_t;
+
+static struct imem_list *imem_list_head = NULL; /* up sorted by phys_start */
+
+#ifdef DEBUG_IMEM
+static void dump_imem_list(void)
+{
+	struct imem_list *imem;
+
+	printk("*** dump_imem_list 0x%x ***\n", (u32)imem_list_head);
+	imem = imem_list_head;
+	while (imem) {
+		printk("imem=0x%x phys_start=0x%x phys_end=0x%x next=0x%x\n", (u32)imem, imem->phys_start, imem->phys_end, (u32)imem->next);
+		imem = imem->next;
+	}
+}
+#endif
+
+/* allocate 2^order pages inside the 4MB memory */
+static int imem_alloc(unsigned int order)
+{
+	int alloc_ok = 0;
+	unsigned int start, end;
+	unsigned int size = (1 << order) * PAGE_SIZE;
+	struct imem_list *imem, *imemn, *imemp;
+
+	allocated_phys_addr = 0;
+
+	start = jz_imem_base;
+	end = start + (1 << IMEM_MAX_ORDER) * PAGE_SIZE;
+
+	imem = imem_list_head;
+	while (imem) {
+		if ((imem->phys_start - start) >= size) {
+			/* we got a valid address range */
+			alloc_ok = 1;
+			break;
+		}
+
+		start = imem->phys_end + 1;
+		imem = imem->next;
+	}
+
+	if (!alloc_ok) {
+		if ((end - start) >= size)
+			alloc_ok = 1;
+	}
+
+	if (alloc_ok) {
+		end = start + size - 1;
+		allocated_phys_addr = start;
+
+		/* add to imem_list, up sorted by phys_start */
+		imemn = kmalloc(sizeof(struct imem_list), GFP_KERNEL);
+		if (!imemn) {
+			return -ENOMEM;
+		}
+		imemn->phys_start = start;
+		imemn->phys_end = end;
+		imemn->next = NULL;
+
+		if (!imem_list_head)
+			imem_list_head = imemn;
+		else {
+			imem = imemp = imem_list_head;
+			while (imem) {
+				if (start < imem->phys_start) {
+					break;
+				}
+
+				imemp = imem;
+				imem = imem->next;
+			}
+
+			if (imem == imem_list_head) {
+				imem_list_head = imemn;
+				imemn->next = imem;
+			}
+			else {
+				imemn->next = imemp->next;
+				imemp->next = imemn;
+			}
+		}
+	}
+
+#ifdef DEBUG_IMEM
+	dump_imem_list();
+#endif
+	return 0;
+}
+
+static void imem_free(unsigned int phys_addr)
+{
+	struct imem_list *imem, *imemp;
+
+	imem = imemp = imem_list_head;
+	while (imem) {
+		if (phys_addr == imem->phys_start) {
+			if (imem == imem_list_head) {
+				imem_list_head = imem->next;
+			}
+			else {
+				imemp->next = imem->next;
+			}
+
+			kfree(imem);
+			break;
+		}
+
+		imemp = imem;
+		imem = imem->next;
+	}
+
+#ifdef DEBUG_IMEM
+	dump_imem_list();
+#endif
+}
+
+static void imem_free_all(void)
+{
+	struct imem_list *imem;
+
+	imem = imem_list_head;
+	while (imem) {
+		kfree(imem);
+		imem = imem->next;
+	}
+
+	imem_list_head = NULL;
+
+	allocated_phys_addr = 0;
+
+#ifdef DEBUG_IMEM
+	dump_imem_list();
+#endif
+}
+
+/*
+ * Return the allocated buffer address and the max order of free buffer
+ */
+static int imem_read_proc(char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	unsigned int start_addr, end_addr, max_order, max_size;
+	struct imem_list *imem;
+
+	unsigned int *tmp = (unsigned int *)(page + len);
+
+	start_addr = jz_imem_base;
+	end_addr = start_addr + (1 << IMEM_MAX_ORDER) * PAGE_SIZE;
+
+	if (!imem_list_head)
+		max_size = end_addr - start_addr;
+	else {
+		max_size = 0;
+		imem = imem_list_head;
+		while (imem) {
+			if (max_size < (imem->phys_start - start_addr))
+				max_size = imem->phys_start - start_addr;
+
+			start_addr = imem->phys_end + 1;
+			imem = imem->next;
+		}
+
+		if (max_size < (end_addr - start_addr))
+			max_size = end_addr - start_addr;
+	}
+
+	if (max_size > 0) {
+		max_order = get_order(max_size);
+		if (((1 << max_order) * PAGE_SIZE) > max_size)
+		    max_order--;
+	}
+	else {
+		max_order = 0xffffffff;	/* No any free buffer */
+	}
+
+	*tmp++ = allocated_phys_addr;	/* address allocated by 'echo n > /proc/jz/imem' */
+	*tmp = max_order;		/* max order of current free buffers */
+
+	len += 2 * sizeof(unsigned int);
+
+	return len;
+}
+
+static int imem_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	unsigned int val;
+
+	val = simple_strtoul(buffer, 0, 16);
+
+	if (val == 0xff) {
+		/* free all memory */
+		imem_free_all();
+		ipu_del_wired_entry();
+	} else if ((val >= 0) && (val <= IMEM_MAX_ORDER)) {
+		/* allocate 2^val pages */
+		imem_alloc(val);
+	} else {
+		/* free buffer which phys_addr is val */
+		imem_free(val);
+	}
+
+	return count;
+}
+
+/*
+ * /proc/jz/xxx entry
+ *
+ */
+static int __init jz_proc_init(void)
+{
+	struct proc_dir_entry *res;
+	unsigned int virt_addr, i;
+
+	proc_jz_root = proc_mkdir("jz", 0);
+
+	/* External Memory Controller */
+	res = create_proc_entry("emc", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = emc_read_proc;
+		res->write_proc = NULL;
+		res->data = NULL;
+	}
+
+	/* Power Management Controller */
+	res = create_proc_entry("pmc", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = pmc_read_proc;
+		res->write_proc = pmc_write_proc;
+		res->data = NULL;
+	}
+
+	/* Clock Generation Module */
+	res = create_proc_entry("cgm", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = cgm_read_proc;
+		res->write_proc = cgm_write_proc;
+		res->data = NULL;
+	}
+
+	/* Image process unit */
+	res = create_proc_entry("ipu", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = ipu_read_proc;
+		res->write_proc = ipu_write_proc;
+		res->data = NULL;
+	}
+
+	/* udc hotplug */
+	res = create_proc_entry("udc", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = udc_read_proc;
+		res->write_proc = NULL;
+		res->data = NULL;
+	}
+
+	/* mmc hotplug */
+	res = create_proc_entry("mmc", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = mmc_read_proc;
+		res->write_proc = NULL;
+		res->data = NULL;
+	}
+
+	/* show tlb */
+	res = create_proc_entry("tlb", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = tlb_read_proc;
+		res->write_proc = NULL;
+		res->data = NULL;
+	}
+
+	/*
+	 * Reserve a 4MB memory for IPU on JZ4750.
+	 */
+	jz_imem_base = (unsigned int)__get_free_pages(GFP_KERNEL, IMEM_MAX_ORDER);
+	if (jz_imem_base) {
+		/* imem (IPU memory management) */
+		res = create_proc_entry("imem", 0644, proc_jz_root);
+		if (res) {
+			res->read_proc = imem_read_proc;
+			res->write_proc = imem_write_proc;
+			res->data = NULL;
+		}
+
+		/* Set page reserved */
+		virt_addr = jz_imem_base;
+		for (i = 0; i < (1 << IMEM_MAX_ORDER); i++) {
+			SetPageReserved(virt_to_page((void *)virt_addr));
+			virt_addr += PAGE_SIZE;
+		}
+
+		/* Convert to physical address */
+		jz_imem_base = virt_to_phys((void *)jz_imem_base);
+
+		printk("Total %dMB memory at 0x%x was reserved for IPU\n",
+		       (unsigned int)((1 << IMEM_MAX_ORDER) * PAGE_SIZE)/1000000, jz_imem_base);
+	} else
+		printk("NOT enough memory for imem\n");
+
+	return 0;
+}
+
+__initcall(jz_proc_init);
--- linux-2.6.24.7.old/arch/mips/jz4750/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750/prom.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,198 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *    PROM library initialisation code, supports YAMON and U-Boot.
+ *
+ * Copyright 2000, 2001, 2006 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	ppopov@mvista.com or source@mvista.com
+ *
+ * This file was derived from Carsten Langgaard's
+ * arch/mips/mips-boards/xx files.
+ *
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+#include <asm/jzsoc.h>
+
+/* #define DEBUG_CMDLINE */
+
+int prom_argc;
+char **prom_argv, **prom_envp;
+
+char * prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
+
+void  prom_init_cmdline(void)
+{
+	char *cp;
+	int actr;
+
+	actr = 1; /* Always ignore argv[0] */
+
+	cp = &(arcs_cmdline[0]);
+	while(actr < prom_argc) {
+	        strcpy(cp, prom_argv[actr]);
+		cp += strlen(prom_argv[actr]);
+		*cp++ = ' ';
+		actr++;
+	}
+	if (cp != &(arcs_cmdline[0])) /* get rid of trailing space */
+		--cp;
+	if (prom_argc > 1)
+		*cp = '\0';
+
+}
+
+
+char *prom_getenv(char *envname)
+{
+#if 0
+	/*
+	 * Return a pointer to the given environment variable.
+	 * YAMON uses "name", "value" pairs, while U-Boot uses "name=value".
+	 */
+
+	char **env = prom_envp;
+	int i = strlen(envname);
+	int yamon = (*env && strchr(*env, '=') == NULL);
+
+	while (*env) {
+		if (yamon) {
+			if (strcmp(envname, *env++) == 0)
+				return *env;
+		} else {
+			if (strncmp(envname, *env, i) == 0 && (*env)[i] == '=')
+				return *env + i + 1;
+		}
+		env++;
+	}
+#endif
+	return NULL;
+}
+
+inline unsigned char str2hexnum(unsigned char c)
+{
+	if(c >= '0' && c <= '9')
+		return c - '0';
+	if(c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	if(c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	return 0; /* foo */
+}
+
+inline void str2eaddr(unsigned char *ea, unsigned char *str)
+{
+	int i;
+
+	for(i = 0; i < 6; i++) {
+		unsigned char num;
+
+		if((*str == '.') || (*str == ':'))
+			str++;
+		num = str2hexnum(*str++) << 4;
+		num |= (str2hexnum(*str++));
+		ea[i] = num;
+	}
+}
+
+int get_ethernet_addr(char *ethernet_addr)
+{
+        char *ethaddr_str;
+
+        ethaddr_str = prom_getenv("ethaddr");
+	if (!ethaddr_str) {
+	        printk("ethaddr not set in boot prom\n");
+		return -1;
+	}
+	str2eaddr(ethernet_addr, ethaddr_str);
+
+#if 0
+	{
+		int i;
+
+	printk("get_ethernet_addr: ");
+	for (i=0; i<5; i++)
+		printk("%02x:", (unsigned char)*(ethernet_addr+i));
+	printk("%02x\n", *(ethernet_addr+i));
+	}
+#endif
+
+	return 0;
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
+
+void __init prom_init(void)
+{
+	unsigned char *memsize_str;
+	unsigned long memsize;
+
+	prom_argc = (int) fw_arg0;
+	prom_argv = (char **) fw_arg1;
+	prom_envp = (char **) fw_arg2;
+
+	mips_machtype = MACH_INGENIC_JZ4750;
+
+	prom_init_cmdline();
+	memsize_str = prom_getenv("memsize");
+	if (!memsize_str) {
+		memsize = 0x04000000;
+	} else {
+		memsize = simple_strtol(memsize_str, NULL, 0);
+	}
+	add_memory_region(0, memsize, BOOT_MEM_RAM);
+}
+
+/* used by early printk */
+void prom_putchar(char c)
+{
+	volatile u8 *uart_lsr = (volatile u8 *)(UART0_BASE + OFF_LSR);
+	volatile u8 *uart_tdr = (volatile u8 *)(UART0_BASE + OFF_TDR);
+
+	/* Wait for fifo to shift out some bytes */
+	while ( !((*uart_lsr & (UARTLSR_TDRQ | UARTLSR_TEMT)) == 0x60) );
+
+	*uart_tdr = (u8)c;
+}
+
+const char *get_system_type(void)
+{
+	return "JZ4750";
+}
+
+EXPORT_SYMBOL(prom_getcmdline);
+EXPORT_SYMBOL(get_ethernet_addr);
+EXPORT_SYMBOL(str2eaddr);
--- linux-2.6.24.7.old/arch/mips/jz4750/reset.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750/reset.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,46 @@
+/*
+ * linux/arch/mips/jz4750/reset.c
+ *
+ * JZ4750 reset routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <yliu@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/reboot.h>
+#include <asm/system.h>
+#include <asm/jzsoc.h>
+
+void jz_restart(char *command)
+{
+	printk("Restarting after 4 ms\n");
+	REG_WDT_TCSR = WDT_TCSR_PRESCALE4 | WDT_TCSR_EXT_EN;
+	REG_WDT_TCNT = 0;
+	REG_WDT_TDR = JZ_EXTAL/1000;   /* reset after 4ms */
+	REG_TCU_TSCR = TCU_TSCR_WDTSC; /* enable wdt clock */
+	REG_WDT_TCER = WDT_TCER_TCEN;  /* wdt start */
+	while (1);
+}
+
+void jz_halt(void)
+{
+	printk(KERN_NOTICE "\n** You can safely turn off the power\n");
+
+	while (1)
+		__asm__(".set\tmips3\n\t"
+	                "wait\n\t"
+			".set\tmips0");
+}
+
+void jz_power_off(void)
+{
+	jz_halt();
+}
--- linux-2.6.24.7.old/arch/mips/jz4750/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750/setup.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,197 @@
+/*
+ * linux/arch/mips/jz4750/common/setup.c
+ *
+ * JZ4750 common setup routines.
+ *
+ * Copyright (C) 2006 Ingenic Semiconductor Inc.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/ioport.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_8250.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/pgtable.h>
+#include <asm/time.h>
+#include <asm/jzsoc.h>
+
+#ifdef CONFIG_PC_KEYB
+#include <asm/keyboard.h>
+#endif
+
+jz_clocks_t jz_clocks;
+
+extern char * __init prom_getcmdline(void);
+extern void __init jz_board_setup(void);
+extern void jz_restart(char *);
+extern void jz_halt(void);
+extern void jz_power_off(void);
+extern void jz_time_init(void);
+
+static void __init sysclocks_setup(void)
+{
+#ifndef CONFIG_MIPS_JZ_EMURUS /* FPGA */
+	jz_clocks.cclk = __cpm_get_cclk();
+	jz_clocks.hclk = __cpm_get_hclk();
+	jz_clocks.pclk = __cpm_get_pclk();
+	jz_clocks.mclk = __cpm_get_mclk();
+	jz_clocks.lcdclk = __cpm_get_lcdclk();
+	jz_clocks.pixclk = __cpm_get_pixclk();
+	jz_clocks.i2sclk = __cpm_get_i2sclk();
+	jz_clocks.usbclk = __cpm_get_usbclk();
+	jz_clocks.mscclk = __cpm_get_mscclk(0);
+	jz_clocks.extalclk = __cpm_get_extalclk();
+	jz_clocks.rtcclk = __cpm_get_rtcclk();
+#else
+
+#define FPGACLK 8000000
+
+	jz_clocks.cclk = FPGACLK;
+	jz_clocks.hclk = FPGACLK;
+	jz_clocks.pclk = FPGACLK;
+	jz_clocks.mclk = FPGACLK;
+	jz_clocks.lcdclk = FPGACLK;
+	jz_clocks.pixclk = FPGACLK;
+	jz_clocks.i2sclk = FPGACLK;
+	jz_clocks.usbclk = FPGACLK;
+	jz_clocks.mscclk = FPGACLK;
+	jz_clocks.extalclk = FPGACLK;
+	jz_clocks.rtcclk = FPGACLK;
+#endif
+
+	printk("CPU clock: %dMHz, System clock: %dMHz, Peripheral clock: %dMHz, Memory clock: %dMHz\n",
+	       (jz_clocks.cclk + 500000) / 1000000,
+	       (jz_clocks.hclk + 500000) / 1000000,
+	       (jz_clocks.pclk + 500000) / 1000000,
+	       (jz_clocks.mclk + 500000) / 1000000);
+}
+
+static void __init soc_cpm_setup(void)
+{
+	/* Start all module clocks
+	 */
+	__cpm_start_all();
+
+	/* Enable CKO to external memory */
+	__cpm_enable_cko();
+
+	/* CPU enters IDLE mode when executing 'wait' instruction */
+	__cpm_idle_mode();
+
+	/* Setup system clocks */
+	sysclocks_setup();
+}
+
+static void __init soc_harb_setup(void)
+{
+//	__harb_set_priority(0x00);  /* CIM>LCD>DMA>ETH>PCI>USB>CBB */
+//	__harb_set_priority(0x03);  /* LCD>CIM>DMA>ETH>PCI>USB>CBB */
+//	__harb_set_priority(0x0a);  /* ETH>LCD>CIM>DMA>PCI>USB>CBB */
+}
+
+static void __init soc_emc_setup(void)
+{
+}
+
+static void __init soc_dmac_setup(void)
+{
+	__dmac_enable_module(0);
+	__dmac_enable_module(1);
+}
+
+static void __init jz_soc_setup(void)
+{
+	soc_cpm_setup();
+	soc_harb_setup();
+	soc_emc_setup();
+	soc_dmac_setup();
+}
+
+static void __init jz_serial_setup(void)
+{
+#ifdef CONFIG_SERIAL_8250
+	struct uart_port s;
+	REG8(UART0_FCR) |= UARTFCR_UUE; /* enable UART module */
+	memset(&s, 0, sizeof(s));
+	s.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST;
+	s.iotype = SERIAL_IO_MEM;
+	s.regshift = 2;
+	s.uartclk = jz_clocks.extalclk ;
+
+	s.line = 0;
+	s.membase = (u8 *)UART0_BASE;
+	s.irq = IRQ_UART0;
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial ttyS0 setup failed!\n");
+	}
+
+	s.line = 1;
+	s.membase = (u8 *)UART1_BASE;
+	s.irq = IRQ_UART1;
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial ttyS1 setup failed!\n");
+	}
+
+	s.line = 2;
+	s.membase = (u8 *)UART2_BASE;
+	s.irq = IRQ_UART2;
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial ttyS2 setup failed!\n");
+	}
+
+	s.line = 3;
+	s.membase = (u8 *)UART3_BASE;
+	s.irq = IRQ_UART3;
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial ttyS3 setup failed!\n");
+	}
+#endif
+}
+
+void __init plat_mem_setup(void)
+{
+	char *argptr;
+
+	argptr = prom_getcmdline();
+
+	/* IO/MEM resources. Which will be the addtion value in `inX' and
+	 * `outX' macros defined in asm/io.h */
+	set_io_port_base(0);
+	ioport_resource.start	= 0x00000000;
+	ioport_resource.end	= 0xffffffff;
+	iomem_resource.start	= 0x00000000;
+	iomem_resource.end	= 0xffffffff;
+
+	_machine_restart = jz_restart;
+	_machine_halt = jz_halt;
+	pm_power_off = jz_power_off;
+
+	jz_soc_setup();
+	jz_serial_setup();
+	jz_board_setup();
+}
+
--- linux-2.6.24.7.old/arch/mips/jz4750/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750/time.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,156 @@
+/*
+ * linux/arch/mips/jz4750/time.c
+ *
+ * Setting up the clock on the JZ4750 boards.
+ *
+ * Copyright (C) 2008 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/clockchips.h>
+
+#include <asm/time.h>
+#include <asm/jzsoc.h>
+
+/* This is for machines which generate the exact clock. */
+
+#define JZ_TIMER_IRQ  IRQ_TCU0
+
+#define JZ_TIMER_CLOCK (JZ_EXTAL>>4) /* Jz timer clock frequency */
+
+static struct clocksource clocksource_jz; /* Jz clock source */
+static struct clock_event_device jz_clockevent_device; /* Jz clock event */
+
+void (*jz_timer_callback)(void);
+
+static irqreturn_t jz_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *cd = dev_id;
+
+	REG_TCU_TFCR = TCU_TFCR_OSTFCL; /* ACK timer */
+
+	if (jz_timer_callback)
+		jz_timer_callback();
+
+	cd->event_handler(cd);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction jz_irqaction = {
+	.handler	= jz_timer_interrupt,
+	.flags		= IRQF_DISABLED | IRQF_PERCPU | IRQF_TIMER,
+	.name		= "jz-timerirq",
+};
+
+
+cycle_t jz_get_cycles(void)
+{
+	/* convert jiffes to jz timer cycles */
+	return (cycle_t)( jiffies*((JZ_TIMER_CLOCK)/HZ) + REG_TCU_OSTCNT);
+}
+
+static struct clocksource clocksource_jz = {
+	.name 		= "jz_clocksource",
+	.rating		= 300,
+	.read		= jz_get_cycles,
+	.mask		= 0xFFFFFFFF,
+	.shift 		= 10,
+	.flags		= CLOCK_SOURCE_WATCHDOG,
+};
+
+static int __init jz_clocksource_init(void)
+{
+	clocksource_jz.mult = clocksource_hz2mult(JZ_TIMER_CLOCK, clocksource_jz.shift);
+	clocksource_register(&clocksource_jz);
+	return 0;
+}
+
+static int jz_set_next_event(unsigned long evt,
+				  struct clock_event_device *unused)
+{
+	return 0;
+}
+
+static void jz_set_mode(enum clock_event_mode mode,
+			struct clock_event_device *evt)
+{
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+                break;
+        case CLOCK_EVT_MODE_ONESHOT:
+        case CLOCK_EVT_MODE_UNUSED:
+        case CLOCK_EVT_MODE_SHUTDOWN:
+                break;
+        case CLOCK_EVT_MODE_RESUME:
+                break;
+        }
+}
+
+static struct clock_event_device jz_clockevent_device = {
+	.name		= "jz-clockenvent",
+	.features	= CLOCK_EVT_FEAT_PERIODIC,
+//	.features	= CLOCK_EVT_FEAT_ONESHOT, /* Jz4740 not support dynamic clock now */
+
+	/* .mult, .shift, .max_delta_ns and .min_delta_ns left uninitialized */
+	.rating		= 300,
+	.irq		= JZ_TIMER_IRQ,
+	.set_mode	= jz_set_mode,
+	.set_next_event	= jz_set_next_event,
+};
+
+static void __init jz_clockevent_init(void)
+{
+	struct clock_event_device *cd = &jz_clockevent_device;
+	unsigned int cpu = smp_processor_id();
+
+	cd->cpumask = cpumask_of_cpu(cpu);
+	clockevents_register_device(cd);
+}
+
+static void __init jz_timer_setup(void)
+{
+	jz_clocksource_init();	/* init jz clock source */
+	jz_clockevent_init();	/* init jz clock event */
+
+	/*
+	 * Make irqs happen for the system timer
+	 */
+	jz_irqaction.dev_id = &jz_clockevent_device;
+	setup_irq(JZ_TIMER_IRQ, &jz_irqaction);
+}
+
+
+void __init plat_time_init(void)
+{
+	unsigned int latch;
+
+	/* Init timer */
+	latch = (JZ_TIMER_CLOCK + (HZ>>1)) / HZ;
+
+	REG_TCU_OSTCSR = TCU_OSTCSR_PRESCALE16 | TCU_OSTCSR_EXT_EN;
+	REG_TCU_OSTCNT = 0;
+	REG_TCU_OSTDR = latch;
+
+	REG_TCU_TMCR = TCU_TMCR_OSTMCL; /* unmask match irq */
+	REG_TCU_TSCR = TCU_TSCR_OSTSC;  /* enable timer clock */
+	REG_TCU_TESR = TCU_TESR_OSTST;  /* start counting up */
+
+	jz_timer_setup();
+}
--- linux-2.6.24.7.old/arch/mips/jz4750d/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750d/Makefile	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,22 @@
+#
+# Makefile for the Ingenic JZ4750D.
+#
+
+# Object file lists.
+
+obj-y += prom.o irq.o time.o reset.o setup.o dma.o \
+	platform.o i2c.o
+
+obj-$(CONFIG_PROC_FS)		+= proc.o
+
+# board specific support
+
+obj-$(CONFIG_JZ4750D_FUWA1)	+= board-fuwa1.o
+
+# PM support
+
+obj-$(CONFIG_PM_LEGACY)         +=pm.o
+
+# CPU Frequency scaling support
+
+obj-$(CONFIG_CPU_FREQ_JZ)       +=cpufreq.o
--- linux-2.6.24.7.old/arch/mips/jz4750d/board-fuwa1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750d/board-fuwa1.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,72 @@
+/*
+ * linux/arch/mips/jz4750d/board-fuwa1.c
+ *
+ * JZ4750D FUWA1 board setup routines.
+ *
+ * Copyright (c) 2006-2008  Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+
+#include <asm/jzsoc.h>
+
+extern void (*jz_timer_callback)(void);
+
+static void dancing(void)
+{
+	static unsigned char slash[] = "\\|/-";
+//	static volatile unsigned char *p = (unsigned char *)0xb6000058;
+	static volatile unsigned char *p = (unsigned char *)0xb6000016;
+	static unsigned int count = 0;
+	*p = slash[count++];
+	count &= 3;
+}
+
+static void fuwa1_timer_callback(void)
+{
+	static unsigned long count = 0;
+
+	if ((++count) % 50 == 0) {
+		dancing();
+		count = 0;
+	}
+}
+
+static void __init board_cpm_setup(void)
+{
+	/* Stop unused module clocks here.
+	 * We have started all module clocks at arch/mips/jz4750d/setup.c.
+	 */
+}
+
+static void __init board_gpio_setup(void)
+{
+	/*
+	 * Initialize SDRAM pins
+	 */
+}
+
+void __init jz_board_setup(void)
+{
+	printk("JZ4750D FUWA1 board setup\n");
+
+	board_cpm_setup();
+	board_gpio_setup();
+
+	jz_timer_callback = fuwa1_timer_callback;
+}
--- linux-2.6.24.7.old/arch/mips/jz4750d/cpufreq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750d/cpufreq.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,601 @@
+/*
+ * linux/arch/mips/jz4750d/cpufreq.c
+ *
+ * cpufreq driver for JZ4750D
+ *
+ * Copyright (c) 2006-2008  Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <linux/cpufreq.h>
+
+#include <asm/jzsoc.h>
+#include <asm/processor.h>
+
+#define dprintk(msg...) cpufreq_debug_printk(CPUFREQ_DEBUG_DRIVER, \
+						"cpufreq-jz4750d", msg)
+
+#undef CHANGE_PLL
+
+#define PLL_UNCHANGED 0
+#define PLL_GOES_UP   1
+#define PLL_GOES_DOWN 2
+
+#define PLL_WAIT_500NS (500*(__cpm_get_cclk()/1000000000))
+
+/* Saved the boot-time parameters */
+static struct {
+	/* SDRAM parameters */
+	unsigned int mclk;  /* memory clock, KHz */
+	unsigned int tras;  /* RAS pulse width, cycles of mclk */
+	unsigned int rcd;   /* RAS to CAS Delay, cycles of mclk */
+	unsigned int tpc;   /* RAS Precharge time, cycles of mclk */
+	unsigned int trwl;  /* Write Precharge Time, cycles of mclk */
+	unsigned int trc;   /* RAS Cycle Time, cycles of mclk */
+	unsigned int rtcor; /* Refresh Time Constant */
+	unsigned int sdram_initialized;
+
+	/* LCD parameters */
+	unsigned int lcd_clk;    /* LCD clock, Hz */
+	unsigned int lcdpix_clk; /* LCD Pixel clock, Hz */
+	unsigned int lcd_clks_initialized;
+} boot_config;
+
+struct jz4750d_freq_percpu_info {
+	struct cpufreq_frequency_table table[7];
+};
+
+static struct jz4750d_freq_percpu_info jz4750d_freq_table;
+
+/*
+ * This contains the registers value for an operating point.
+ * If only part of a register needs to change then there is
+ * a mask value for that register.
+ * When going to a new operating point the current register
+ * value is ANDed with the ~mask and ORed with the new value.
+ */
+struct dpm_regs {
+	u32 cpccr;        /* Clock Freq Control Register */
+	u32 cpccr_mask;   /* Clock Freq Control Register mask */
+	u32 cppcr;        /* PLL1 Control Register */
+	u32 cppcr_mask;   /* PLL1 Control Register mask */
+	u32 pll_up_flag;  /* New PLL freq is higher than current or not */
+};
+
+extern jz_clocks_t jz_clocks;
+
+static void jz_update_clocks(void)
+{
+	/* Next clocks must be updated if we have changed
+	 * the PLL or divisors.
+	 */
+	jz_clocks.cclk = __cpm_get_cclk();
+	jz_clocks.hclk = __cpm_get_hclk();
+	jz_clocks.mclk = __cpm_get_mclk();
+	jz_clocks.pclk = __cpm_get_pclk();
+	jz_clocks.lcdclk = __cpm_get_lcdclk();
+	jz_clocks.pixclk = __cpm_get_pixclk();
+	jz_clocks.i2sclk = __cpm_get_i2sclk();
+	jz_clocks.usbclk = __cpm_get_usbclk();
+	jz_clocks.mscclk = __cpm_get_mscclk(0);
+}
+
+static void
+jz_init_boot_config(void)
+{
+	if (!boot_config.lcd_clks_initialized) {
+		/* the first time to scale pll */
+		boot_config.lcd_clk = __cpm_get_lcdclk();
+		boot_config.lcdpix_clk = __cpm_get_pixclk();
+		boot_config.lcd_clks_initialized = 1;
+	}
+
+	if (!boot_config.sdram_initialized) {
+		/* the first time to scale frequencies */
+		unsigned int dmcr, rtcor;
+		unsigned int tras, rcd, tpc, trwl, trc;
+
+		dmcr = REG_EMC_DMCR;
+		rtcor = REG_EMC_RTCOR;
+
+		tras = (dmcr >> 13) & 0x7;
+		rcd = (dmcr >> 11) & 0x3;
+		tpc = (dmcr >> 8) & 0x7;
+		trwl = (dmcr >> 5) & 0x3;
+		trc = (dmcr >> 2) & 0x7;
+
+		boot_config.mclk = __cpm_get_mclk() / 1000;
+		boot_config.tras = tras + 4;
+		boot_config.rcd = rcd + 1;
+		boot_config.tpc = tpc + 1;
+		boot_config.trwl = trwl + 1;
+		boot_config.trc = trc * 2 + 1;
+		boot_config.rtcor = rtcor;
+
+		boot_config.sdram_initialized = 1;
+	}
+}
+
+static void jz_update_dram_rtcor(unsigned int new_mclk)
+{
+	unsigned int rtcor;
+
+	new_mclk /= 1000;
+	rtcor = boot_config.rtcor * new_mclk / boot_config.mclk;
+	rtcor--;
+
+	if (rtcor < 1) rtcor = 1;
+	if (rtcor > 255) rtcor = 255;
+
+	REG_EMC_RTCOR = rtcor;
+	REG_EMC_RTCNT = rtcor;
+}
+
+static void jz_update_dram_dmcr(unsigned int new_mclk)
+{
+	unsigned int dmcr;
+	unsigned int tras, rcd, tpc, trwl, trc;
+	unsigned int valid_time, new_time; /* ns */
+
+	new_mclk /= 1000;
+	tras = boot_config.tras * new_mclk / boot_config.mclk;
+	rcd = boot_config.rcd * new_mclk / boot_config.mclk;
+	tpc = boot_config.tpc * new_mclk / boot_config.mclk;
+	trwl = boot_config.trwl * new_mclk / boot_config.mclk;
+	trc = boot_config.trc * new_mclk / boot_config.mclk;
+
+	/* Validation checking */
+	valid_time = (boot_config.tras * 1000000) / boot_config.mclk;
+	new_time = (tras * 1000000) / new_mclk;
+	if (new_time < valid_time) tras += 1;
+
+	valid_time = (boot_config.rcd * 1000000) / boot_config.mclk;
+	new_time = (rcd * 1000000) / new_mclk;
+	if (new_time < valid_time) rcd += 1;
+
+	valid_time = (boot_config.tpc * 1000000) / boot_config.mclk;
+	new_time = (tpc * 1000000) / new_mclk;
+	if (new_time < valid_time) tpc += 1;
+
+	valid_time = (boot_config.trwl * 1000000) / boot_config.mclk;
+	new_time = (trwl * 1000000) / new_mclk;
+	if (new_time < valid_time) trwl += 1;
+
+	valid_time = (boot_config.trc * 1000000) / boot_config.mclk;
+	new_time = (trc * 1000000) / new_mclk;
+	if (new_time < valid_time) trc += 2;
+
+	tras = (tras < 4) ? 4: tras;
+	tras = (tras > 11) ? 11: tras;
+	tras -= 4;
+
+	rcd = (rcd < 1) ? 1: rcd;
+	rcd = (rcd > 4) ? 4: rcd;
+	rcd -= 1;
+
+	tpc = (tpc < 1) ? 1: tpc;
+	tpc = (tpc > 8) ? 8: tpc;
+	tpc -= 1;
+
+	trwl = (trwl < 1) ? 1: trwl;
+	trwl = (trwl > 4) ? 4: trwl;
+	trwl -= 1;
+
+	trc = (trc < 1) ? 1: trc;
+	trc = (trc > 15) ? 15: trc;
+	trc /= 2;
+
+	dmcr = REG_EMC_DMCR;
+
+	dmcr &= ~(EMC_DMCR_TRAS_MASK | EMC_DMCR_RCD_MASK | EMC_DMCR_TPC_MASK | EMC_DMCR_TRWL_MASK | EMC_DMCR_TRC_MASK);
+	dmcr |= ((tras << EMC_DMCR_TRAS_BIT) | (rcd << EMC_DMCR_RCD_BIT) | (tpc << EMC_DMCR_TPC_BIT) | (trwl << EMC_DMCR_TRWL_BIT) | (trc << EMC_DMCR_TRC_BIT));
+
+	REG_EMC_DMCR = dmcr;
+}
+
+static void jz_update_dram_prev(unsigned int cur_mclk, unsigned int new_mclk)
+{
+	/* No risk, no fun: run with interrupts on! */
+	if (new_mclk > cur_mclk) {
+		/* We're going FASTER, so first update TRAS, RCD, TPC, TRWL
+		 * and TRC of DMCR before changing the frequency.
+		 */
+		jz_update_dram_dmcr(new_mclk);
+	} else {
+		/* We're going SLOWER: first update RTCOR value
+		 * before changing the frequency.
+		 */
+		jz_update_dram_rtcor(new_mclk);
+	}
+}
+
+static void jz_update_dram_post(unsigned int cur_mclk, unsigned int new_mclk)
+{
+	/* No risk, no fun: run with interrupts on! */
+	if (new_mclk > cur_mclk) {
+		/* We're going FASTER, so update RTCOR
+		 * after changing the frequency
+		 */
+		jz_update_dram_rtcor(new_mclk);
+	} else {
+		/* We're going SLOWER: so update TRAS, RCD, TPC, TRWL
+		 * and TRC of DMCR after changing the frequency.
+		 */
+		jz_update_dram_dmcr(new_mclk);
+	}
+}
+
+static void jz_scale_divisors(struct dpm_regs *regs)
+{
+	unsigned int cpccr;
+	unsigned int cur_mclk, new_mclk;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned int tmp = 0, wait = PLL_WAIT_500NS;
+
+	cpccr = REG_CPM_CPCCR;
+	cpccr &= ~((unsigned long)regs->cpccr_mask);
+	cpccr |= regs->cpccr;
+	cpccr |= CPM_CPCCR_CE;       /* update immediately */
+
+	cur_mclk = __cpm_get_mclk();
+	new_mclk = __cpm_get_pllout() / div[(cpccr & CPM_CPCCR_MDIV_MASK) >> CPM_CPCCR_MDIV_BIT];
+
+	/* Update some DRAM parameters before changing frequency */
+	jz_update_dram_prev(cur_mclk, new_mclk);
+
+	/* update register to change the clocks.
+	 * align this code to a cache line.
+	 */
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".align 5\n"
+		"sw %1,0(%0)\n\t"
+		"li %3,0\n\t"
+		"1:\n\t"
+		"bne %3,%2,1b\n\t"
+		"addi %3, 1\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set reorder\n\t"
+		:
+		: "r" (CPM_CPCCR), "r" (cpccr), "r" (wait), "r" (tmp));
+
+	/* Update some other DRAM parameters after changing frequency */
+	jz_update_dram_post(cur_mclk, new_mclk);
+}
+
+#ifdef CHANGE_PLL
+/* Maintain the LCD clock and pixel clock */
+static void jz_scale_lcd_divisors(struct dpm_regs *regs)
+{
+	unsigned int new_pll, new_lcd_div, new_lcdpix_div;
+	unsigned int cpccr;
+	unsigned int tmp = 0, wait = PLL_WAIT_500NS;
+
+	if (!boot_config.lcd_clks_initialized) return;
+
+	new_pll = __cpm_get_pllout();
+	new_lcd_div = new_pll / boot_config.lcd_clk;
+	new_lcdpix_div = new_pll / boot_config.lcdpix_clk;
+
+	if (new_lcd_div < 1)
+		new_lcd_div = 1;
+	if (new_lcd_div > 16)
+		new_lcd_div = 16;
+
+	if (new_lcdpix_div < 1)
+		new_lcdpix_div = 1;
+	if (new_lcdpix_div > 512)
+		new_lcdpix_div = 512;
+
+//	REG_CPM_CPCCR2 = new_lcdpix_div - 1;
+
+	cpccr = REG_CPM_CPCCR;
+	cpccr &= ~CPM_CPCCR_LDIV_MASK;
+	cpccr |= ((new_lcd_div - 1) << CPM_CPCCR_LDIV_BIT);
+	cpccr |= CPM_CPCCR_CE;       /* update immediately */
+
+	/* update register to change the clocks.
+	 * align this code to a cache line.
+	 */
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".align 5\n"
+		"sw %1,0(%0)\n\t"
+		"li %3,0\n\t"
+		"1:\n\t"
+		"bne %3,%2,1b\n\t"
+		"addi %3, 1\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set reorder\n\t"
+		:
+		: "r" (CPM_CPCCR), "r" (cpccr), "r" (wait), "r" (tmp));
+}
+
+static void jz_scale_pll(struct dpm_regs *regs)
+{
+	unsigned int cppcr;
+	unsigned int cur_mclk, new_mclk, new_pll;
+	int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	int od[] = {1, 2, 2, 4};
+
+	cppcr = REG_CPM_CPPCR;
+	cppcr &= ~(regs->cppcr_mask | CPM_CPPCR_PLLS | CPM_CPPCR_PLLEN | CPM_CPPCR_PLLST_MASK);
+	regs->cppcr &= ~CPM_CPPCR_PLLEN;
+	cppcr |= (regs->cppcr | 0xff);
+
+	/* Update some DRAM parameters before changing frequency */
+	new_pll = JZ_EXTAL * ((cppcr>>23)+2) / ((((cppcr>>18)&0x1f)+2) * od[(cppcr>>16)&0x03]);
+	cur_mclk = __cpm_get_mclk();
+	new_mclk = new_pll / div[(REG_CPM_CPCCR>>16) & 0xf];
+
+	/*
+	 * Update some SDRAM parameters
+	 */
+	jz_update_dram_prev(cur_mclk, new_mclk);
+
+	/*
+	 * Update PLL, align code to cache line.
+	 */
+	cppcr |= CPM_CPPCR_PLLEN;
+	__asm__ __volatile__(
+		".set noreorder\n\t"
+		".align 5\n"
+		"sw %1,0(%0)\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		".set reorder\n\t"
+		:
+		: "r" (CPM_CPPCR), "r" (cppcr));
+
+	/* Update some other DRAM parameters after changing frequency */
+	jz_update_dram_post(cur_mclk, new_mclk);
+}
+#endif
+
+static void jz4750d_transition(struct dpm_regs *regs)
+{
+	/*
+	 * Get and save some boot-time conditions.
+	 */
+	jz_init_boot_config();
+
+#ifdef CHANGE_PLL
+	/*
+	 * Disable LCD before scaling pll.
+	 * LCD and LCD pixel clocks should not be changed even if the PLL
+	 * output frequency has been changed.
+	 */
+	REG_LCD_CTRL &= ~LCD_CTRL_ENA;
+
+	/*
+	 * Stop module clocks before scaling PLL
+	 */
+	__cpm_stop_eth();
+	__cpm_stop_aic(1);
+	__cpm_stop_aic(2);
+#endif
+
+	/* ... add more as necessary */
+
+	if (regs->pll_up_flag == PLL_GOES_UP) {
+		/* the pll frequency is going up, so change dividors first */
+		jz_scale_divisors(regs);
+#ifdef CHANGE_PLL
+		jz_scale_pll(regs);
+#endif
+	}
+	else if (regs->pll_up_flag == PLL_GOES_DOWN) {
+		/* the pll frequency is going down, so change pll first */
+#ifdef CHANGE_PLL
+		jz_scale_pll(regs);
+#endif
+		jz_scale_divisors(regs);
+	}
+	else {
+		/* the pll frequency is unchanged, so change divisors only */
+		jz_scale_divisors(regs);
+	}
+
+#ifdef CHANGE_PLL
+	/*
+	 * Restart module clocks before scaling PLL
+	 */
+	__cpm_start_eth();
+	__cpm_start_aic(1);
+	__cpm_start_aic(2);
+
+	/* ... add more as necessary */
+
+	/* Scale the LCD divisors after scaling pll */
+	if (regs->pll_up_flag != PLL_UNCHANGED) {
+		jz_scale_lcd_divisors(regs);
+	}
+
+	/* Enable LCD controller */
+	REG_LCD_CTRL &= ~LCD_CTRL_DIS;
+	REG_LCD_CTRL |= LCD_CTRL_ENA;
+#endif
+
+	/* Update system clocks */
+	jz_update_clocks();
+}
+
+extern unsigned int idle_times;
+static unsigned int jz4750d_freq_get(unsigned int cpu)
+{
+	return  (__cpm_get_cclk() / 1000);
+}
+
+static unsigned int index_to_divisor(unsigned int index, struct dpm_regs *regs)
+{
+	int n2FR[33] = {
+		0, 0, 1, 2, 3, 0, 4, 0, 5, 0, 0, 0, 6, 0, 0, 0,
+		7, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0,
+		9
+	};
+	int div[4] = {1, 2, 2, 2}; /* divisors of I:S:P:M */
+	unsigned int div_of_cclk, new_freq, i;
+
+	regs->pll_up_flag = PLL_UNCHANGED;
+	regs->cpccr_mask = CPM_CPCCR_CDIV_MASK | CPM_CPCCR_HDIV_MASK | CPM_CPCCR_PDIV_MASK | CPM_CPCCR_MDIV_MASK;
+
+	new_freq = jz4750d_freq_table.table[index].frequency;
+
+	do {
+		div_of_cclk = __cpm_get_pllout() / (1000 * new_freq);
+	} while (div_of_cclk==0);
+
+	if(div_of_cclk == 1 || div_of_cclk == 2 || div_of_cclk == 4) {
+		for(i = 1; i<4; i++) {
+			div[i] = 3;
+		}
+	} else {
+		for(i = 1; i<4; i++) {
+			div[i] = 2;
+		}
+	}
+
+	for(i = 0; i<4; i++) {
+		div[i] *= div_of_cclk;
+	}
+
+	dprintk("divisors of I:S:P:M = %d:%d:%d:%d\n", div[0], div[1], div[2], div[3]);
+
+	regs->cpccr =
+		(n2FR[div[0]] << CPM_CPCCR_CDIV_BIT) |
+		(n2FR[div[1]] << CPM_CPCCR_HDIV_BIT) |
+		(n2FR[div[2]] << CPM_CPCCR_PDIV_BIT) |
+		(n2FR[div[3]] << CPM_CPCCR_MDIV_BIT);
+
+	return  div_of_cclk;
+}
+
+static void jz4750d_set_cpu_divider_index(unsigned int cpu, unsigned int index)
+{
+	unsigned long divisor, old_divisor;
+	struct cpufreq_freqs freqs;
+	struct dpm_regs regs;
+
+	old_divisor = __cpm_get_pllout() /  __cpm_get_cclk();
+	divisor = index_to_divisor(index, &regs);
+
+	freqs.old = __cpm_get_cclk() / 1000;
+	freqs.new =  __cpm_get_pllout() / (1000 * divisor);
+	freqs.cpu = cpu;
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+	if (old_divisor != divisor)
+		jz4750d_transition(&regs);
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+}
+
+static int jz4750d_freq_target(struct cpufreq_policy *policy,
+			  unsigned int target_freq,
+			  unsigned int relation)
+{
+	unsigned int new_index = 0;
+
+	if (cpufreq_frequency_table_target(policy,
+					   &jz4750d_freq_table.table[0],
+					   target_freq, relation, &new_index))
+		return -EINVAL;
+
+	jz4750d_set_cpu_divider_index(policy->cpu, new_index);
+
+	dprintk("new frequency is %d KHz (REG_CPM_CPCCR:0x%x)\n", __cpm_get_cclk() / 1000, REG_CPM_CPCCR);
+
+	return 0;
+}
+
+static int jz4750d_freq_verify(struct cpufreq_policy *policy)
+{
+	return cpufreq_frequency_table_verify(policy,
+					      &jz4750d_freq_table.table[0]);
+}
+
+static int __init jz4750d_cpufreq_driver_init(struct cpufreq_policy *policy)
+{
+
+	struct cpufreq_frequency_table *table =	&jz4750d_freq_table.table[0];
+	unsigned int MAX_FREQ;
+
+	dprintk(KERN_INFO "Jz4750d cpufreq driver\n");
+
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	policy->cur = MAX_FREQ = __cpm_get_cclk() / 1000; /* in kHz. Current and max frequency is determined by u-boot */
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+
+	policy->cpuinfo.min_freq = MAX_FREQ/8;
+	policy->cpuinfo.max_freq = MAX_FREQ;
+	policy->cpuinfo.transition_latency = 100000; /* in 10^(-9) s = nanoseconds */
+
+	table[0].index = 0;
+	table[0].frequency = MAX_FREQ/8;
+	table[1].index = 1;
+	table[1].frequency = MAX_FREQ/6;
+	table[2].index = 2;
+	table[2].frequency = MAX_FREQ/4;
+	table[3].index = 3;
+	table[3].frequency = MAX_FREQ/3;
+	table[4].index = 4;
+	table[4].frequency = MAX_FREQ/2;
+	table[5].index = 5;
+	table[5].frequency = MAX_FREQ;
+	table[6].index = 6;
+	table[6].frequency = CPUFREQ_TABLE_END;
+
+#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
+	cpufreq_frequency_table_get_attr(table, policy->cpu); /* for showing /sys/devices/system/cpu/cpuX/cpufreq/stats/ */
+#endif
+
+	return  cpufreq_frequency_table_cpuinfo(policy, table);
+}
+
+static struct cpufreq_driver cpufreq_jz4750d_driver = {
+//	.flags		= CPUFREQ_STICKY,
+	.init		= jz4750d_cpufreq_driver_init,
+	.verify		= jz4750d_freq_verify,
+	.target		= jz4750d_freq_target,
+	.get		= jz4750d_freq_get,
+	.name		= "jz4750d",
+};
+
+static int __init jz4750d_cpufreq_init(void)
+{
+	return cpufreq_register_driver(&cpufreq_jz4750d_driver);
+}
+
+static void __exit jz4750d_cpufreq_exit(void)
+{
+	cpufreq_unregister_driver(&cpufreq_jz4750d_driver);
+}
+
+module_init(jz4750d_cpufreq_init);
+module_exit(jz4750d_cpufreq_exit);
+
+MODULE_AUTHOR("Regen <lhhuang@ingenic.cn>");
+MODULE_DESCRIPTION("cpufreq driver for Jz4750d");
+MODULE_LICENSE("GPL");
--- linux-2.6.24.7.old/arch/mips/jz4750d/dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750d/dma.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,822 @@
+/*
+ * linux/arch/mips/jz4750d/dma.c
+ *
+ * Support functions for the JZ4750D internal DMA channels.
+ * No-descriptor transfer only.
+ * Descriptor transfer should also call jz_request_dma() to get a free
+ * channel and call jz_free_dma() to free the channel. And driver should
+ * build the DMA descriptor and setup the DMA channel by itself.
+ *
+ * Copyright (C) 2006 - 2008 Ingenic Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/soundcard.h>
+
+#include <asm/system.h>
+#include <asm/addrspace.h>
+#include <asm/jzsoc.h>
+
+/*
+ * A note on resource allocation:
+ *
+ * All drivers needing DMA channels, should allocate and release them
+ * through the public routines `jz_request_dma()' and `jz_free_dma()'.
+ *
+ * In order to avoid problems, all processes should allocate resources in
+ * the same sequence and release them in the reverse order.
+ *
+ * So, when allocating DMAs and IRQs, first allocate the DMA, then the IRQ.
+ * When releasing them, first release the IRQ, then release the DMA. The
+ * main reason for this order is that, if you are requesting the DMA buffer
+ * done interrupt, you won't know the irq number until the DMA channel is
+ * returned from jz_request_dma().
+ */
+
+struct jz_dma_chan jz_dma_table[MAX_DMA_NUM] = {
+	{dev_id:DMA_ID_BCH_ENC,}, /* DMAC0 channel 0, reserved for BCH */
+	{dev_id:-1,},		/* DMAC0 channel 1 */
+	{dev_id:-1,},		/* DMAC0 channel 2 */
+	{dev_id:-1,},		/* DMAC0 channel 3 */
+	{dev_id:-1,},		/* DMAC1 channel 0 */
+	{dev_id:-1,},		/* DMAC1 channel 1 */
+	{dev_id:-1,},		/* DMAC1 channel 2 */
+	{dev_id:-1,},		/* DMAC1 channel 3 */
+};
+
+// Device FIFO addresses and default DMA modes
+static const struct {
+	unsigned int fifo_addr;
+	unsigned int dma_mode;
+	unsigned int dma_source;
+} dma_dev_table[DMA_ID_MAX] = {
+	{0, DMA_AUTOINIT, DMAC_DRSR_RS_EXT}, /* External request with DREQn */
+	{0x18000000, DMA_AUTOINIT, DMAC_DRSR_RS_NAND}, /* NAND request */
+	{CPHYSADDR(BCH_DR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_BCH_ENC},
+	{CPHYSADDR(BCH_DR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_BCH_DEC},
+	{0, DMA_AUTOINIT, DMAC_DRSR_RS_AUTO},
+//	{CPHYSADDR(TSSI_FIFO), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_TSSIIN},
+	{CPHYSADDR(UART3_TDR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_UART3OUT},
+	{CPHYSADDR(UART3_RDR), DMA_8BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_UART3IN},
+	{CPHYSADDR(UART2_TDR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_UART2OUT},
+	{CPHYSADDR(UART2_RDR), DMA_8BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_UART2IN},
+	{CPHYSADDR(UART1_TDR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_UART1OUT},
+	{CPHYSADDR(UART1_RDR), DMA_8BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_UART1IN},
+	{CPHYSADDR(UART0_TDR), DMA_8BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_UART0OUT},
+	{CPHYSADDR(UART0_RDR), DMA_8BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_UART0IN},
+	{CPHYSADDR(SSI_DR(0)), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_SSI0OUT},
+	{CPHYSADDR(SSI_DR(0)), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_SSI0IN},
+	{CPHYSADDR(AIC_DR), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_AICOUT},
+	{CPHYSADDR(AIC_DR), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_AICIN},
+	{CPHYSADDR(MSC_TXFIFO(0)), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_MSC0OUT},
+	{CPHYSADDR(MSC_RXFIFO(0)), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_MSC0IN},
+	{0, DMA_AUTOINIT, DMAC_DRSR_RS_TCU},
+	{SADC_TSDAT, DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_SADC},/* Touch Screen Data Register */
+	{CPHYSADDR(MSC_TXFIFO(1)), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_MSC1OUT}, /* SSC1 TX */
+	{CPHYSADDR(MSC_RXFIFO(1)), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_MSC1IN},	/* SSC1 RX */
+	{CPHYSADDR(SSI_DR(1)), DMA_32BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_SSI1OUT},
+	{CPHYSADDR(SSI_DR(1)), DMA_32BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_SSI1IN},
+	{CPHYSADDR(PCM_DP), DMA_16BIT_TX_CMD | DMA_MODE_WRITE, DMAC_DRSR_RS_PMOUT},
+	{CPHYSADDR(PCM_DP), DMA_16BIT_RX_CMD | DMA_MODE_READ, DMAC_DRSR_RS_PMIN},
+	{},
+};
+
+
+int jz_dma_read_proc(char *buf, char **start, off_t fpos,
+			 int length, int *eof, void *data)
+{
+	int i, len = 0;
+	struct jz_dma_chan *chan;
+
+	for (i = 0; i < MAX_DMA_NUM; i++) {
+		if ((chan = get_dma_chan(i)) != NULL) {
+			len += sprintf(buf + len, "%2d: %s\n",
+				       i, chan->dev_str);
+		}
+	}
+
+	if (fpos >= len) {
+		*start = buf;
+		*eof = 1;
+		return 0;
+	}
+	*start = buf + fpos;
+	if ((len -= fpos) > length)
+		return length;
+	*eof = 1;
+	return len;
+}
+
+
+void dump_jz_dma_channel(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan;
+
+	if (dmanr > MAX_DMA_NUM)
+		return;
+	chan = &jz_dma_table[dmanr];
+
+	printk("DMA%d Registers:\n", dmanr);
+	printk("  DMACR  = 0x%08x\n", REG_DMAC_DMACR(chan->io/HALF_DMA_NUM));
+	printk("  DSAR   = 0x%08x\n", REG_DMAC_DSAR(dmanr));
+	printk("  DTAR   = 0x%08x\n", REG_DMAC_DTAR(dmanr));
+	printk("  DTCR   = 0x%08x\n", REG_DMAC_DTCR(dmanr));
+	printk("  DRSR   = 0x%08x\n", REG_DMAC_DRSR(dmanr));
+	printk("  DCCSR  = 0x%08x\n", REG_DMAC_DCCSR(dmanr));
+	printk("  DCMD  = 0x%08x\n", REG_DMAC_DCMD(dmanr));
+	printk("  DDA  = 0x%08x\n", REG_DMAC_DDA(dmanr));
+	printk("  DMADBR = 0x%08x\n", REG_DMAC_DMADBR(chan->io/HALF_DMA_NUM));
+}
+
+
+/**
+ * jz_request_dma - dynamically allcate an idle DMA channel to return
+ * @dev_id: the specified dma device id or DMA_ID_RAW_SET
+ * @dev_str: the specified dma device string name
+ * @irqhandler: the irq handler, or NULL
+ * @irqflags: the irq handler flags
+ * @irq_dev_id: the irq handler device id for shared irq
+ *
+ * Finds a free channel, and binds the requested device to it.
+ * Returns the allocated channel number, or negative on error.
+ * Requests the DMA done IRQ if irqhandler != NULL.
+ *
+*/
+/*int jz_request_dma(int dev_id, const char *dev_str,
+		   void (*irqhandler)(int, void *, struct pt_regs *),
+		   unsigned long irqflags,
+		   void *irq_dev_id)
+*/
+
+int jz_request_dma(int dev_id, const char *dev_str,
+		   irqreturn_t (*irqhandler)(int, void *),
+		   unsigned long irqflags,
+		   void *irq_dev_id)
+{
+	struct jz_dma_chan *chan;
+	int i, ret;
+
+	if (dev_id < 0 || dev_id >= DMA_ID_MAX)
+		return -EINVAL;
+
+ 	for (i = 0; i < MAX_DMA_NUM; i++) {
+		if (jz_dma_table[i].dev_id < 0)
+			break;
+	}
+	if (i == MAX_DMA_NUM)  /* no free channel */
+		return -ENODEV;
+
+	/* we got a free channel */
+	chan = &jz_dma_table[i];
+
+	if (irqhandler) {
+		chan->irq = IRQ_DMA_0 + i;	// allocate irq number
+		chan->irq_dev = irq_dev_id;
+		if ((ret = request_irq(chan->irq, irqhandler, irqflags,
+				       dev_str, chan->irq_dev))) {
+			chan->irq = -1;
+			chan->irq_dev = NULL;
+			return ret;
+		}
+	} else {
+		chan->irq = -1;
+		chan->irq_dev = NULL;
+	}
+
+	// fill it in
+	chan->io = i;
+	chan->dev_id = dev_id;
+	chan->dev_str = dev_str;
+	chan->fifo_addr = dma_dev_table[dev_id].fifo_addr;
+	chan->mode = dma_dev_table[dev_id].dma_mode;
+	chan->source = dma_dev_table[dev_id].dma_source;
+
+	if (i < HALF_DMA_NUM)
+		REG_DMAC_DMACKE(0) = 1 << i;
+	else
+		REG_DMAC_DMACKE(1) = 1 << (i - HALF_DMA_NUM);
+
+	return i;
+}
+
+void jz_free_dma(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan) {
+		printk("Trying to free DMA%d\n", dmanr);
+		return;
+	}
+
+	disable_dma(dmanr);
+	if (chan->irq)
+		free_irq(chan->irq, chan->irq_dev);
+
+	chan->irq = -1;
+	chan->irq_dev = NULL;
+	chan->dev_id = -1;
+}
+
+void jz_set_dma_dest_width(int dmanr, int nbit)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+	       	return;
+
+	chan->mode &= ~DMAC_DCMD_DWDH_MASK;
+	switch (nbit) {
+	case 8:
+		chan->mode |= DMAC_DCMD_DWDH_8;
+		break;
+	case 16:
+		chan->mode |= DMAC_DCMD_DWDH_16;
+		break;
+	case 32:
+		chan->mode |= DMAC_DCMD_DWDH_32;
+		break;
+	}
+}
+
+void jz_set_dma_src_width(int dmanr, int nbit)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+	       	return;
+
+	chan->mode &= ~DMAC_DCMD_SWDH_MASK;
+	switch (nbit) {
+	case 8:
+		chan->mode |= DMAC_DCMD_SWDH_8;
+		break;
+	case 16:
+		chan->mode |= DMAC_DCMD_SWDH_16;
+		break;
+	case 32:
+		chan->mode |= DMAC_DCMD_SWDH_32;
+		break;
+	}
+}
+
+void jz_set_dma_block_size(int dmanr, int nbyte)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	chan->mode &= ~DMAC_DCMD_DS_MASK;
+	switch (nbyte) {
+	case 1:
+		chan->mode |= DMAC_DCMD_DS_8BIT;
+		break;
+	case 2:
+		chan->mode |= DMAC_DCMD_DS_16BIT;
+		break;
+	case 4:
+		chan->mode |= DMAC_DCMD_DS_32BIT;
+		break;
+	case 16:
+		chan->mode |= DMAC_DCMD_DS_16BYTE;
+		break;
+	case 32:
+		chan->mode |= DMAC_DCMD_DS_32BYTE;
+		break;
+	}
+}
+
+unsigned int jz_get_dma_command(int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	return chan->mode;
+}
+
+/**
+ * jz_set_dma_mode - do the raw settings for the specified DMA channel
+ * @dmanr: the specified DMA channel
+ * @mode: dma operate mode, DMA_MODE_READ or DMA_MODE_WRITE
+ * @dma_mode: dma raw mode
+ * @dma_source: dma raw request source
+ * @fifo_addr: dma raw device fifo address
+ *
+ * Ensure call jz_request_dma(DMA_ID_RAW_SET, ...) first, then call
+ * jz_set_dma_mode() rather than set_dma_mode() if you work with
+ * and external request dma device.
+ *
+ * NOTE: Don not dynamically allocate dma channel if one external request
+ *       dma device will occupy this channel.
+*/
+int jz_set_dma_mode(unsigned int dmanr, unsigned int mode,
+		    unsigned int dma_mode, unsigned int dma_source,
+		    unsigned int fifo_addr)
+{
+	int dev_id, i;
+	struct jz_dma_chan *chan;
+
+	if (dmanr > MAX_DMA_NUM)
+		return -ENODEV;
+	for (i = 0; i < MAX_DMA_NUM; i++) {
+		if (jz_dma_table[i].dev_id < 0)
+			break;
+	}
+	if (i == MAX_DMA_NUM)
+		return -ENODEV;
+
+	chan = &jz_dma_table[dmanr];
+	dev_id = chan->dev_id;
+	if (dev_id > 0) {
+		printk(KERN_DEBUG "%s sets the allocated DMA channel %d!\n",
+		       __FUNCTION__, dmanr);
+		return -ENODEV;
+	}
+
+	/* clone it from the dynamically allocated. */
+	if (i != dmanr) {
+		chan->irq = jz_dma_table[i].irq;
+		chan->irq_dev = jz_dma_table[i].irq_dev;
+		chan->dev_str = jz_dma_table[i].dev_str;
+		jz_dma_table[i].irq = 0;
+		jz_dma_table[i].irq_dev = NULL;
+		jz_dma_table[i].dev_id = -1;
+	}
+	chan->dev_id = DMA_ID_RAW_SET;
+	chan->io = dmanr;
+	chan->fifo_addr = fifo_addr;
+	chan->mode = dma_mode;
+	chan->source = dma_source;
+
+	set_dma_mode(dmanr, dma_mode);
+
+	return dmanr;
+}
+
+void enable_dma(unsigned int dmanr)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	REG_DMAC_DCCSR(dmanr) &= ~(DMAC_DCCSR_HLT | DMAC_DCCSR_TT | DMAC_DCCSR_AR);
+	REG_DMAC_DCCSR(dmanr) |= DMAC_DCCSR_NDES; /* No-descriptor transfer */
+	__dmac_enable_channel(dmanr);
+	if (chan->irq)
+		__dmac_channel_enable_irq(dmanr);
+}
+
+#define DMA_DISABLE_POLL 0x10000
+
+void disable_dma(unsigned int dmanr)
+{
+	int i;
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	if (!__dmac_channel_enabled(dmanr))
+		return;
+
+	for (i = 0; i < DMA_DISABLE_POLL; i++)
+		if (__dmac_channel_transmit_end_detected(dmanr))
+			break;
+#if 0
+	if (i == DMA_DISABLE_POLL)
+		printk(KERN_INFO "disable_dma: poll expired!\n");
+#endif
+
+	__dmac_disable_channel(dmanr);
+	if (chan->irq)
+		__dmac_channel_disable_irq(dmanr);
+}
+
+/* Note: DMA_MODE_MASK is simulated by sw */
+void set_dma_mode(unsigned int dmanr, unsigned int mode)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+	mode &= DMA_MODE_MASK;
+	if (mode == DMA_MODE_READ) {
+		chan->mode |= DMAC_DCMD_DAI;
+		chan->mode &= ~DMAC_DCMD_SAI;
+	} else if (mode == DMA_MODE_WRITE) {
+		chan->mode |= DMAC_DCMD_SAI;
+		chan->mode &= ~DMAC_DCMD_DAI;
+	} else {
+		printk(KERN_DEBUG "set_dma_mode() just supports DMA_MODE_READ or DMA_MODE_WRITE!\n");
+	}
+	REG_DMAC_DCMD(chan->io) = chan->mode & ~DMA_MODE_MASK;
+	REG_DMAC_DRSR(chan->io) = chan->source;
+}
+
+void set_dma_addr(unsigned int dmanr, unsigned int phyaddr)
+{
+	unsigned int mode;
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	mode = chan->mode & DMA_MODE_MASK;
+	if (mode == DMA_MODE_READ) {
+		REG_DMAC_DSAR(chan->io) = chan->fifo_addr;
+		REG_DMAC_DTAR(chan->io) = phyaddr;
+	} else if (mode == DMA_MODE_WRITE) {
+		REG_DMAC_DSAR(chan->io) = phyaddr;
+		REG_DMAC_DTAR(chan->io) = chan->fifo_addr;
+	} else
+		printk(KERN_DEBUG "Driver should call set_dma_mode() ahead set_dma_addr()!\n");
+}
+
+void set_dma_count(unsigned int dmanr, unsigned int bytecnt)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	int dma_ds[] = {4, 1, 2, 16, 32};
+	unsigned int ds;
+
+	if (!chan)
+	       	return;
+
+       	ds = (chan->mode & DMAC_DCMD_DS_MASK) >> DMAC_DCMD_DS_BIT;
+	REG_DMAC_DTCR(chan->io) = bytecnt / dma_ds[ds]; // transfer count
+}
+
+unsigned int get_dma_residue(unsigned int dmanr)
+{
+	unsigned int count, ds;
+	int dma_ds[] = {4, 1, 2, 16, 32};
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+	if (!chan)
+		return 0;
+
+	ds = (chan->mode & DMAC_DCMD_DS_MASK) >> DMAC_DCMD_DS_BIT;
+	count = REG_DMAC_DTCR(chan->io);
+	count = count * dma_ds[ds];
+
+	return count;
+}
+
+void jz_set_oss_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	switch (audio_fmt) {
+	case AFMT_U8:
+		/* burst mode : 32BIT */
+		break;
+	case AFMT_S16_LE:
+		/* burst mode : 16BYTE */
+		if (mode == DMA_MODE_READ) {
+			chan->mode = DMA_AIC_32_16BYTE_RX_CMD | DMA_MODE_READ;
+			chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCMD_DAI;
+			chan->mode &= ~DMAC_DCMD_SAI;
+		} else if (mode == DMA_MODE_WRITE) {
+			chan->mode = DMA_AIC_32_16BYTE_TX_CMD | DMA_MODE_WRITE;
+			//chan->mode = DMA_AIC_16BYTE_TX_CMD | DMA_MODE_WRITE;
+			chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCMD_SAI;
+			chan->mode &= ~DMAC_DCMD_DAI;
+		} else
+			printk("oss_dma_burst_mode() just supports DMA_MODE_READ or DMA_MODE_WRITE!\n");
+
+		REG_DMAC_DCMD(chan->io) = chan->mode & ~DMA_MODE_MASK;
+		REG_DMAC_DRSR(chan->io) = chan->source;
+		break;
+	}
+}
+
+void jz_set_alsa_dma(unsigned int dmanr, unsigned int mode, unsigned int audio_fmt)
+{
+	struct jz_dma_chan *chan = get_dma_chan(dmanr);
+
+	if (!chan)
+		return;
+
+	switch (audio_fmt) {
+	case 8:
+		/* SNDRV_PCM_FORMAT_S8 burst mode : 32BIT */
+		break;
+	case 16:
+		/* SNDRV_PCM_FORMAT_S16_LE burst mode : 16BYTE */
+		if (mode == DMA_MODE_READ) {
+			chan->mode = DMA_AIC_16BYTE_RX_CMD | DMA_MODE_READ;
+			chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCMD_DAI;
+			chan->mode &= ~DMAC_DCMD_SAI;
+		} else if (mode == DMA_MODE_WRITE) {
+			chan->mode = DMA_AIC_16BYTE_TX_CMD | DMA_MODE_WRITE;
+			chan->mode |= mode & ~(DMAC_DCMD_SAI | DMAC_DCMD_DAI);
+			mode &= DMA_MODE_MASK;
+			chan->mode |= DMAC_DCMD_SAI;
+			chan->mode &= ~DMAC_DCMD_DAI;
+		} else
+			printk("alsa_dma_burst_mode() just supports DMA_MODE_READ or DMA_MODE_WRITE!\n");
+
+		REG_DMAC_DCMD(chan->io) = chan->mode & ~DMA_MODE_MASK;
+		REG_DMAC_DRSR(chan->io) = chan->source;
+		break;
+	}
+}
+
+//#define JZ4750D_DMAC_TEST_ENABLE
+#undef JZ4750D_DMAC_TEST_ENABLE
+
+#ifdef JZ4750D_DMAC_TEST_ENABLE
+
+/*
+ * DMA test: external address <--> external address
+ */
+#define TEST_DMA_SIZE  16*1024
+
+static jz_dma_desc *dma_desc;
+
+static int dma_chan;
+static dma_addr_t dma_desc_phys_addr;
+static unsigned int dma_src_addr, dma_src_phys_addr, dma_dst_addr, dma_dst_phys_addr;
+
+static int dma_check_result(void *src, void *dst, int size)
+{
+	unsigned int addr1, addr2, i, err = 0;
+
+	addr1 = (unsigned int)src;
+	addr2 = (unsigned int)dst;
+
+	for (i = 0; i < size; i += 4) {
+		if (*(volatile unsigned int *)addr1 != *(volatile unsigned int *)addr2) {
+			err++;
+			printk("wrong data at 0x%08x: src 0x%08x  dst 0x%08x\n", addr2, *(volatile unsigned int *)addr1, *(volatile unsigned int *)addr2);
+		}
+		addr1 += 4;
+		addr2 += 4;
+	}
+	printk("check DMA result err=%d\n", err);
+	return err;
+}
+
+static irqreturn_t jz4750d_dma_irq(int irq, void *dev_id)
+{
+	printk("jz4750d_dma_irq %d\n", irq);
+
+
+	if (__dmac_channel_transmit_halt_detected(dma_chan)) {
+		printk("DMA HALT\n");
+		REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+		__dmac_channel_clear_transmit_halt(dma_chan);
+	}
+
+	if (__dmac_channel_address_error_detected(dma_chan)) {
+		printk("DMA ADDR ERROR\n");
+		REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+		REG_DMAC_DSAR(dma_chan) = 0; /* clear source address register */
+		REG_DMAC_DTAR(dma_chan) = 0; /* clear target address register */
+		__dmac_channel_clear_address_error(dma_chan);
+	}
+
+	if (__dmac_channel_descriptor_invalid_detected(dma_chan)) {
+		REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+		printk("DMA DESC INVALID\n");
+		__dmac_channel_clear_descriptor_invalid(dma_chan);
+	}
+
+	if (__dmac_channel_count_terminated_detected(dma_chan)) {
+		printk("DMA CT\n");
+		__dmac_channel_clear_count_terminated(dma_chan);
+	}
+
+	if (__dmac_channel_transmit_end_detected(dma_chan)) {
+		REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+		printk("DMA TT\n");
+		__dmac_channel_clear_transmit_end(dma_chan);
+		dump_jz_dma_channel(dma_chan);
+		dma_check_result((void *)dma_src_addr, (void *)dma_dst_addr, TEST_DMA_SIZE);
+	}
+
+	return IRQ_HANDLED;
+}
+
+void dma_nodesc_test(void)
+{
+	unsigned int addr, i;
+
+	printk("dma_nodesc_test\n");
+
+	/* Request DMA channel and setup irq handler */
+	dma_chan = jz_request_dma(DMA_ID_AUTO, "auto", jz4750d_dma_irq,
+				  IRQF_DISABLED, NULL);
+	if (dma_chan < 0) {
+		printk("Setup irq failed\n");
+		return;
+	}
+
+	printk("Requested DMA channel = %d\n", dma_chan);
+
+	/* Allocate DMA buffers */
+	dma_src_addr = __get_free_pages(GFP_KERNEL, 2); /* 16KB */
+	dma_dst_addr = __get_free_pages(GFP_KERNEL, 2); /* 16KB */
+
+	dma_src_phys_addr = CPHYSADDR(dma_src_addr);
+	dma_dst_phys_addr = CPHYSADDR(dma_dst_addr);
+
+	printk("Buffer addresses: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+	       dma_src_addr, dma_src_phys_addr, dma_dst_addr, dma_dst_phys_addr);
+
+	/* Prepare data for source buffer */
+	addr = (unsigned int)dma_src_addr;
+	for (i = 0; i < TEST_DMA_SIZE; i += 4) {
+		*(volatile unsigned int *)addr = addr;
+		addr += 4;
+	}
+	dma_cache_wback((unsigned long)dma_src_addr, TEST_DMA_SIZE);
+
+	/* Init target buffer */
+	memset((void *)dma_dst_addr, 0, TEST_DMA_SIZE);
+	dma_cache_wback((unsigned long)dma_dst_addr, TEST_DMA_SIZE);
+
+	/* Init DMA module */
+	printk("Starting DMA\n");
+	REG_DMAC_DMACR(dma_chan/HALF_DMA_NUM) = 0;
+	REG_DMAC_DCCSR(dma_chan) = 0;
+	REG_DMAC_DRSR(dma_chan) = DMAC_DRSR_RS_AUTO;
+	REG_DMAC_DSAR(dma_chan) = dma_src_phys_addr;
+	REG_DMAC_DTAR(dma_chan) = dma_dst_phys_addr;
+	REG_DMAC_DTCR(dma_chan) = 512;
+	REG_DMAC_DCMD(dma_chan) = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_32BYTE | DMAC_DCMD_TIE;
+	REG_DMAC_DCCSR(dma_chan) = DMAC_DCCSR_NDES | DMAC_DCCSR_EN;
+	REG_DMAC_DMACR(dma_chan/HALF_DMA_NUM) = DMAC_DMACR_DMAE; /* global DMA enable bit */
+
+	printk("DMA started. IMR=%08x\n", REG_INTC_IMR);
+
+	/* wait a long time, ensure transfer end */
+	printk("wait 3s...\n");
+	mdelay(3000);		/* wait 3s */
+
+	REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+	/* free buffers */
+	printk("free DMA buffers\n");
+	free_pages(dma_src_addr, 2);
+	free_pages(dma_dst_addr, 2);
+
+	if (dma_desc)
+		free_pages((unsigned int)dma_desc, 0);
+
+	/* free dma */
+	jz_free_dma(dma_chan);
+}
+
+void dma_desc_test(void)
+{
+	unsigned int next, addr, i;
+	static jz_dma_desc *desc;
+
+	printk("dma_desc_test\n");
+
+	/* Request DMA channel and setup irq handler */
+	dma_chan = jz_request_dma(DMA_ID_AUTO, "auto", jz4750d_dma_irq,
+				  IRQF_DISABLED, NULL);
+	if (dma_chan < 0) {
+		printk("Setup irq failed\n");
+		return;
+	}
+
+	printk("Requested DMA channel = %d\n", dma_chan);
+
+	/* Allocate DMA buffers */
+	dma_src_addr = __get_free_pages(GFP_KERNEL, 2); /* 16KB */
+	dma_dst_addr = __get_free_pages(GFP_KERNEL, 2); /* 16KB */
+
+	dma_src_phys_addr = CPHYSADDR(dma_src_addr);
+	dma_dst_phys_addr = CPHYSADDR(dma_dst_addr);
+
+	printk("Buffer addresses: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+	       dma_src_addr, dma_src_phys_addr, dma_dst_addr, dma_dst_phys_addr);
+
+	/* Prepare data for source buffer */
+	addr = (unsigned int)dma_src_addr;
+	for (i = 0; i < TEST_DMA_SIZE; i += 4) {
+		*(volatile unsigned int *)addr = addr;
+		addr += 4;
+	}
+	dma_cache_wback((unsigned long)dma_src_addr, TEST_DMA_SIZE);
+
+	/* Init target buffer */
+	memset((void *)dma_dst_addr, 0, TEST_DMA_SIZE);
+	dma_cache_wback((unsigned long)dma_dst_addr, TEST_DMA_SIZE);
+
+	/* Allocate DMA descriptors */
+	dma_desc = (jz_dma_desc *)__get_free_pages(GFP_KERNEL, 0);
+	dma_desc_phys_addr = CPHYSADDR((unsigned long)dma_desc);
+
+	printk("DMA descriptor address: 0x%08x  0x%08x\n", (u32)dma_desc, dma_desc_phys_addr);
+
+	/* Setup DMA descriptors */
+	desc = dma_desc;
+	next = (dma_desc_phys_addr + (sizeof(jz_dma_desc))) >> 4;
+
+	desc->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_32BYTE | DMAC_DCMD_DES_V | DMAC_DCMD_DES_VM | DMAC_DCMD_DES_VIE | DMAC_DCMD_TIE | DMAC_DCMD_LINK;
+	desc->dsadr = dma_src_phys_addr;    /* DMA source address */
+	desc->dtadr = dma_dst_phys_addr;    /* DMA target address */
+	desc->ddadr = (next << 24) + 128;    /* size: 128*32 bytes = 4096 bytes */
+
+	desc++;
+	next = (dma_desc_phys_addr + 2*(sizeof(jz_dma_desc))) >> 4;
+
+	desc->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_16BYTE | DMAC_DCMD_DES_V | DMAC_DCMD_DES_VM | DMAC_DCMD_DES_VIE | DMAC_DCMD_TIE | DMAC_DCMD_LINK;
+	desc->dsadr = dma_src_phys_addr + 4096;	/* DMA source address */
+	desc->dtadr = dma_dst_phys_addr + 4096;	/* DMA target address */
+	desc->ddadr = (next << 24) + 256;    /* size: 256*16 bytes = 4096 bytes */
+
+	desc++;
+	next = (dma_desc_phys_addr + 3*(sizeof(jz_dma_desc))) >> 4;
+
+	desc->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_16BYTE | DMAC_DCMD_DES_V | DMAC_DCMD_DES_VM | DMAC_DCMD_DES_VIE | DMAC_DCMD_TIE | DMAC_DCMD_LINK;
+	desc->dsadr = dma_src_phys_addr + 8192;	/* DMA source address */
+	desc->dtadr = dma_dst_phys_addr + 8192;	/* DMA target address */
+	desc->ddadr = (next << 24) + 256;    /* size: 256*16 bytes = 4096 bytes */
+
+	desc++;
+	next = (dma_desc_phys_addr + 4*(sizeof(jz_dma_desc))) >> 4;
+
+	desc->dcmd = DMAC_DCMD_SAI | DMAC_DCMD_DAI | DMAC_DCMD_RDIL_IGN | DMAC_DCMD_SWDH_32 | DMAC_DCMD_DWDH_32 | DMAC_DCMD_DS_32BIT | DMAC_DCMD_DES_V | DMAC_DCMD_DES_VM | DMAC_DCMD_DES_VIE | DMAC_DCMD_TIE;
+	desc->dsadr = dma_src_phys_addr + 12*1024;	/* DMA source address */
+	desc->dtadr = dma_dst_phys_addr + 12*1024;	/* DMA target address */
+	desc->ddadr = (next << 24) + 1024;    /* size: 1024*4 bytes = 4096 bytes */
+
+	dma_cache_wback((unsigned long)dma_desc, 4*(sizeof(jz_dma_desc)));
+
+	/* Setup DMA descriptor address */
+	REG_DMAC_DDA(dma_chan) = dma_desc_phys_addr;
+
+	/* Setup request source */
+	REG_DMAC_DRSR(dma_chan) = DMAC_DRSR_RS_AUTO;
+
+	/* Setup DMA channel control/status register */
+	REG_DMAC_DCCSR(dma_chan) = DMAC_DCCSR_EN;	/* descriptor transfer, clear status, start channel */
+
+	/* Enable DMA */
+	REG_DMAC_DMACR(dma_chan/HALF_DMA_NUM) = DMAC_DMACR_DMAE;
+
+	/* DMA doorbell set -- start DMA now ... */
+	REG_DMAC_DMADBSR(dma_chan/HALF_DMA_NUM) = 1 << dma_chan;
+
+	printk("DMA started. IMR=%08x\n", REG_INTC_IMR);
+	/* wait a long time, ensure transfer end */
+	printk("wait 3s...\n");
+	mdelay(3000);		/* wait 3s */
+
+	REG_DMAC_DCCSR(dma_chan) &= ~DMAC_DCCSR_EN;  /* disable DMA */
+	/* free buffers */
+	printk("free DMA buffers\n");
+	free_pages(dma_src_addr, 2);
+	free_pages(dma_dst_addr, 2);
+
+	if (dma_desc)
+		free_pages((unsigned int)dma_desc, 0);
+
+	/* free dma */
+	jz_free_dma(dma_chan);
+}
+
+#endif
+
+//EXPORT_SYMBOL_NOVERS(jz_dma_table);
+EXPORT_SYMBOL(jz_dma_table);
+EXPORT_SYMBOL(jz_request_dma);
+EXPORT_SYMBOL(jz_free_dma);
+EXPORT_SYMBOL(jz_set_dma_src_width);
+EXPORT_SYMBOL(jz_set_dma_dest_width);
+EXPORT_SYMBOL(jz_set_dma_block_size);
+EXPORT_SYMBOL(jz_set_dma_mode);
+EXPORT_SYMBOL(set_dma_mode);
+EXPORT_SYMBOL(jz_set_oss_dma);
+EXPORT_SYMBOL(jz_set_alsa_dma);
+EXPORT_SYMBOL(set_dma_addr);
+EXPORT_SYMBOL(set_dma_count);
+EXPORT_SYMBOL(get_dma_residue);
+EXPORT_SYMBOL(enable_dma);
+EXPORT_SYMBOL(disable_dma);
+EXPORT_SYMBOL(dump_jz_dma_channel);
--- linux-2.6.24.7.old/arch/mips/jz4750d/i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750d/i2c.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,273 @@
+/*
+ * linux/arch/mips/jz4750d/i2c.c
+ *
+ * Jz4750D I2C routines.
+ *
+ * Copyright (C) 2005,2006 Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <asm/addrspace.h>
+
+#include <asm/jzsoc.h>
+
+/* I2C protocol */
+#define I2C_READ	1
+#define I2C_WRITE	0
+
+#define TIMEOUT         1000
+
+/*
+ * I2C bus protocol basic routines
+ */
+static int i2c_put_data(unsigned char data)
+{
+	unsigned int timeout = TIMEOUT*10;
+
+	__i2c_write(data);
+	__i2c_set_drf();
+	while (__i2c_check_drf() != 0);
+	while (!__i2c_transmit_ended());
+	while (!__i2c_received_ack() && timeout)
+		timeout--;
+
+	if (timeout)
+		return 0;
+	else
+		return -ETIMEDOUT;
+}
+
+#ifdef CONFIG_JZ_TPANEL_ATA2508
+static int i2c_put_data_nack(unsigned char data)
+{
+	unsigned int timeout = TIMEOUT*10;
+
+	__i2c_write(data);
+	__i2c_set_drf();
+	while (__i2c_check_drf() != 0);
+	while (!__i2c_transmit_ended());
+	while (timeout--);
+		return 0;
+}
+#endif
+
+static int i2c_get_data(unsigned char *data, int ack)
+{
+	int timeout = TIMEOUT*10;
+
+	if (!ack)
+		__i2c_send_nack();
+	else
+		__i2c_send_ack();
+
+	while (__i2c_check_drf() == 0 && timeout)
+		timeout--;
+
+	if (timeout) {
+		if (!ack)
+			__i2c_send_stop();
+		*data = __i2c_read();
+		__i2c_clear_drf();
+		return 0;
+	} else
+		return -ETIMEDOUT;
+}
+
+/*
+ * I2C interface
+ */
+void i2c_open(void)
+{
+	__i2c_set_clk(jz_clocks.extalclk, 10000); /* default 10 KHz */
+	__i2c_enable();
+}
+
+void i2c_close(void)
+{
+	udelay(300); /* wait for STOP goes over. */
+	__i2c_disable();
+}
+
+void i2c_setclk(unsigned int i2cclk)
+{
+	__i2c_set_clk(jz_clocks.extalclk, i2cclk);
+}
+
+int i2c_lseek(unsigned char device, unsigned char offset)
+{
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_err;
+	if (i2c_put_data(offset) < 0)
+		goto address_err;
+	return 0;
+ device_err:
+	printk(KERN_DEBUG "No I2C device (0x%02x) installed.\n", device);
+	__i2c_send_stop();
+	return -ENODEV;
+ address_err:
+	printk(KERN_DEBUG "No I2C device (0x%02x) response.\n", device);
+	__i2c_send_stop();
+	return -EREMOTEIO;
+}
+
+int i2c_read(unsigned char device, unsigned char *buf,
+	       unsigned char address, int count)
+{
+	int cnt = count;
+	int timeout = 5;
+
+L_try_again:
+
+	if (timeout < 0)
+		goto L_timeout;
+
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_werr;
+	if (i2c_put_data(address) < 0)
+		goto address_err;
+
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_READ ) < 0)
+		goto device_rerr;
+	__i2c_send_ack();	/* Master sends ACK for continue reading */
+	while (cnt) {
+		if (cnt == 1) {
+			if (i2c_get_data(buf, 0) < 0)
+				break;
+		} else {
+			if (i2c_get_data(buf, 1) < 0)
+				break;
+		}
+		cnt--;
+		buf++;
+	}
+
+	__i2c_send_stop();
+	return count - cnt;
+ device_rerr:
+ device_werr:
+ address_err:
+	timeout --;
+	__i2c_send_stop();
+	goto L_try_again;
+
+L_timeout:
+	__i2c_send_stop();
+	printk("Read I2C device 0x%2x failed.\n", device);
+	return -ENODEV;
+}
+
+int i2c_write(unsigned char device, unsigned char *buf,
+		unsigned char address, int count)
+{
+	int cnt = count;
+	int cnt_in_pg;
+	int timeout = 5;
+	unsigned char *tmpbuf;
+	unsigned char tmpaddr;
+
+	__i2c_send_nack();	/* Master does not send ACK, slave sends it */
+
+ W_try_again:
+	if (timeout < 0)
+		goto W_timeout;
+
+	cnt = count;
+	tmpbuf = (unsigned char *)buf;
+	tmpaddr = address;
+
+ start_write_page:
+	cnt_in_pg = 0;
+	__i2c_send_start();
+	if (i2c_put_data( (device << 1) | I2C_WRITE ) < 0)
+		goto device_err;
+#ifdef CONFIG_JZ_TPANEL_ATA2508
+	if (address == 0xff) {
+		if (i2c_put_data_nack(tmpaddr) < 0)
+			goto address_err;
+		while (cnt) {
+			if (++cnt_in_pg > 8) {
+				__i2c_send_stop();
+				mdelay(1);
+				tmpaddr += 8;
+				goto start_write_page;
+			}
+			if (i2c_put_data_nack(*tmpbuf) < 0)
+				break;
+			cnt--;
+			tmpbuf++;
+		}
+	}
+	else {
+
+		if (i2c_put_data(tmpaddr) < 0)
+			goto address_err;
+		while (cnt) {
+			if (++cnt_in_pg > 8) {
+				__i2c_send_stop();
+				mdelay(1);
+				tmpaddr += 8;
+				goto start_write_page;
+			}
+			if (i2c_put_data(*tmpbuf) < 0)
+				break;
+			cnt--;
+			tmpbuf++;
+		}
+	}
+#else
+	if (i2c_put_data(tmpaddr) < 0)
+		goto address_err;
+	while (cnt) {
+		if (++cnt_in_pg > 8) {
+			__i2c_send_stop();
+			mdelay(1);
+			tmpaddr += 8;
+			goto start_write_page;
+		}
+		if (i2c_put_data(*tmpbuf) < 0)
+			break;
+		cnt--;
+		tmpbuf++;
+	}
+#endif
+	__i2c_send_stop();
+	return count - cnt;
+ device_err:
+ address_err:
+	timeout--;
+	__i2c_send_stop();
+	goto W_try_again;
+
+ W_timeout:
+	printk(KERN_DEBUG "Write I2C device 0x%2x failed.\n", device);
+	__i2c_send_stop();
+	return -ENODEV;
+}
+
+EXPORT_SYMBOL(i2c_open);
+EXPORT_SYMBOL(i2c_close);
+EXPORT_SYMBOL(i2c_setclk);
+EXPORT_SYMBOL(i2c_read);
+EXPORT_SYMBOL(i2c_write);
--- linux-2.6.24.7.old/arch/mips/jz4750d/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750d/irq.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,299 @@
+/*
+ * linux/arch/mips/jz4750d/irq.c
+ *
+ * JZ4750D interrupt routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <lhhuang@ingenic.cn>
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/jzsoc.h>
+
+/*
+ * INTC irq type
+ */
+
+static void enable_intc_irq(unsigned int irq)
+{
+	__intc_unmask_irq(irq);
+}
+
+static void disable_intc_irq(unsigned int irq)
+{
+	__intc_mask_irq(irq);
+}
+
+static void mask_and_ack_intc_irq(unsigned int irq)
+{
+	__intc_mask_irq(irq);
+	__intc_ack_irq(irq);
+}
+
+static void end_intc_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		enable_intc_irq(irq);
+	}
+}
+
+static unsigned int startup_intc_irq(unsigned int irq)
+{
+	enable_intc_irq(irq);
+	return 0;
+}
+
+static void shutdown_intc_irq(unsigned int irq)
+{
+	disable_intc_irq(irq);
+}
+
+static struct irq_chip intc_irq_type = {
+	.typename = "INTC",
+	.startup = startup_intc_irq,
+	.shutdown = shutdown_intc_irq,
+	.enable = enable_intc_irq,
+	.disable = disable_intc_irq,
+	.ack = mask_and_ack_intc_irq,
+	.end = end_intc_irq,
+};
+
+/*
+ * GPIO irq type
+ */
+
+static void enable_gpio_irq(unsigned int irq)
+{
+	unsigned int intc_irq;
+
+	if (irq < (IRQ_GPIO_0 + 32)) {
+		intc_irq = IRQ_GPIO0;
+	}
+	else if (irq < (IRQ_GPIO_0 + 64)) {
+		intc_irq = IRQ_GPIO1;
+	}
+	else if (irq < (IRQ_GPIO_0 + 96)) {
+		intc_irq = IRQ_GPIO2;
+	}
+	else if (irq < (IRQ_GPIO_0 + 128)) {
+		intc_irq = IRQ_GPIO3;
+	}
+	else if (irq < (IRQ_GPIO_0 + 160)) {
+		intc_irq = IRQ_GPIO4;
+	}
+	else {
+		intc_irq = IRQ_GPIO5;
+	}
+
+	enable_intc_irq(intc_irq);
+	__gpio_unmask_irq(irq - IRQ_GPIO_0);
+}
+
+static void disable_gpio_irq(unsigned int irq)
+{
+	__gpio_mask_irq(irq - IRQ_GPIO_0);
+}
+
+static void mask_and_ack_gpio_irq(unsigned int irq)
+{
+	__gpio_mask_irq(irq - IRQ_GPIO_0);
+	__gpio_ack_irq(irq - IRQ_GPIO_0);
+}
+
+static void end_gpio_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		enable_gpio_irq(irq);
+	}
+}
+
+static unsigned int startup_gpio_irq(unsigned int irq)
+{
+	enable_gpio_irq(irq);
+	return 0;
+}
+
+static void shutdown_gpio_irq(unsigned int irq)
+{
+	disable_gpio_irq(irq);
+}
+
+static struct irq_chip gpio_irq_type = {
+	.typename = "GPIO",
+	.startup = startup_gpio_irq,
+	.shutdown = shutdown_gpio_irq,
+	.enable = enable_gpio_irq,
+	.disable = disable_gpio_irq,
+	.ack = mask_and_ack_gpio_irq,
+	.end = end_gpio_irq,
+};
+
+/*
+ * DMA irq type
+ */
+
+static void enable_dma_irq(unsigned int irq)
+{
+	unsigned int intc_irq;
+
+	if ( irq < (IRQ_DMA_0 + HALF_DMA_NUM) ) 	/* DMAC Group 0 irq */
+		intc_irq = IRQ_DMAC0;
+	else if ( irq < (IRQ_DMA_0 + MAX_DMA_NUM) ) 	/* DMAC Group 1 irq */
+		intc_irq = IRQ_DMAC1;
+	else {
+		printk("%s, unexpected dma irq #%d\n", __FILE__, irq);
+		return;
+	}
+	__intc_unmask_irq(intc_irq);
+	__dmac_channel_enable_irq(irq - IRQ_DMA_0);
+}
+
+static void disable_dma_irq(unsigned int irq)
+{
+	__dmac_channel_disable_irq(irq - IRQ_DMA_0);
+}
+
+static void mask_and_ack_dma_irq(unsigned int irq)
+{
+	unsigned int intc_irq;
+
+	if ( irq < (IRQ_DMA_0 + HALF_DMA_NUM) ) 	/* DMAC Group 0 irq */
+		intc_irq = IRQ_DMAC0;
+	else if ( irq < (IRQ_DMA_0 + MAX_DMA_NUM) ) 	/* DMAC Group 1 irq */
+		intc_irq = IRQ_DMAC1;
+	else {
+		printk("%s, unexpected dma irq #%d\n", __FILE__, irq);
+		return ;
+	}
+	__intc_ack_irq(intc_irq);
+	__dmac_channel_ack_irq(irq-IRQ_DMA_0); /* needed?? add 20080506, Wolfgang */
+	__dmac_channel_disable_irq(irq - IRQ_DMA_0);
+}
+
+static void end_dma_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		enable_dma_irq(irq);
+	}
+}
+
+static unsigned int startup_dma_irq(unsigned int irq)
+{
+	enable_dma_irq(irq);
+	return 0;
+}
+
+static void shutdown_dma_irq(unsigned int irq)
+{
+	disable_dma_irq(irq);
+}
+
+static struct irq_chip dma_irq_type = {
+	.typename = "DMA",
+	.startup = startup_dma_irq,
+	.shutdown = shutdown_dma_irq,
+	.enable = enable_dma_irq,
+	.disable = disable_dma_irq,
+	.ack = mask_and_ack_dma_irq,
+	.end = end_dma_irq,
+};
+
+//----------------------------------------------------------------------
+
+void __init arch_init_irq(void)
+{
+	int i;
+
+	clear_c0_status(0xff04); /* clear ERL */
+	set_c0_status(0x0400);   /* set IP2 */
+
+	/* Set up INTC irq
+	 */
+	for (i = 0; i < 32; i++) {
+		disable_intc_irq(i);
+		irq_desc[i].chip = &intc_irq_type;
+	}
+
+	/* Set up DMAC irq
+	 */
+	for (i = 0; i < NUM_DMA; i++) {
+		disable_dma_irq(IRQ_DMA_0 + i);
+		irq_desc[IRQ_DMA_0 + i].chip = &dma_irq_type;
+	}
+
+	/* Set up GPIO irq
+	 */
+	for (i = 0; i < NUM_GPIO; i++) {
+		disable_gpio_irq(IRQ_GPIO_0 + i);
+		irq_desc[IRQ_GPIO_0 + i].chip = &gpio_irq_type;
+	}
+}
+
+static int plat_real_irq(int irq)
+{
+	switch (irq) {
+	case IRQ_GPIO0:
+		irq = __gpio_group_irq(0) + IRQ_GPIO_0;
+		break;
+	case IRQ_GPIO1:
+		irq = __gpio_group_irq(1) + IRQ_GPIO_0 + 32;
+		break;
+	case IRQ_GPIO2:
+		irq = __gpio_group_irq(2) + IRQ_GPIO_0 + 64;
+		break;
+	case IRQ_GPIO3:
+		irq = __gpio_group_irq(3) + IRQ_GPIO_0 + 96;
+		break;
+	case IRQ_GPIO4:
+		irq = __gpio_group_irq(4) + IRQ_GPIO_0 + 128;
+		break;
+	case IRQ_GPIO5:
+		irq = __gpio_group_irq(5) + IRQ_GPIO_0 + 160;
+		break;
+	case IRQ_DMAC0:
+	case IRQ_DMAC1:
+		irq = __dmac_get_irq() + IRQ_DMA_0;
+		break;
+	}
+
+	return irq;
+}
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	int irq = 0;
+	static unsigned long intc_ipr = 0;
+
+	intc_ipr |= REG_INTC_IPR;
+
+	if (!intc_ipr)	return;
+
+	irq = ffs(intc_ipr) - 1;
+	intc_ipr &= ~(1<<irq);
+
+	irq = plat_real_irq(irq);
+	do_IRQ(irq);
+}
--- linux-2.6.24.7.old/arch/mips/jz4750d/platform.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750d/platform.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,141 @@
+/*
+ * Platform device support for Jz4740 SoC.
+ *
+ * Copyright 2007, <yliu@ingenic.cn>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/resource.h>
+
+#include <asm/jzsoc.h>
+#if 0
+/* OHCI (USB full speed host controller) */
+static struct resource jz_usb_ohci_resources[] = {
+	[0] = {
+		.start		= CPHYSADDR(UHC_BASE), // phys addr for ioremap
+		.end		= CPHYSADDR(UHC_BASE) + 0x10000 - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_UHC,
+		.end		= IRQ_UHC,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+/* The dmamask must be set for OHCI to work */
+static u64 ohci_dmamask = ~(u32)0;
+
+static struct platform_device jz_usb_ohci_device = {
+	.name		= "jz-ohci",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &ohci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(jz_usb_ohci_resources),
+	.resource	= jz_usb_ohci_resources,
+};
+#endif
+/*** LCD controller ***/
+static struct resource jz_lcd_resources[] = {
+	[0] = {
+		.start          = CPHYSADDR(LCD_BASE),
+		.end            = CPHYSADDR(LCD_BASE) + 0x10000 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start          = IRQ_LCD,
+		.end            = IRQ_LCD,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static u64 jz_lcd_dmamask = ~(u32)0;
+
+static struct platform_device jz_lcd_device = {
+	.name           = "jz-lcd",
+	.id             = 0,
+	.dev = {
+		.dma_mask               = &jz_lcd_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(jz_lcd_resources),
+	.resource       = jz_lcd_resources,
+};
+
+/* UDC (USB gadget controller) */
+static struct resource jz_usb_gdt_resources[] = {
+	[0] = {
+		.start		= CPHYSADDR(UDC_BASE),
+		.end		= CPHYSADDR(UDC_BASE) + 0x10000 - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_UDC,
+		.end		= IRQ_UDC,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static u64 udc_dmamask = ~(u32)0;
+
+static struct platform_device jz_usb_gdt_device = {
+	.name		= "jz-udc",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &udc_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(jz_usb_gdt_resources),
+	.resource	= jz_usb_gdt_resources,
+};
+
+/** MMC/SD controller **/
+static struct resource jz_mmc_resources[] = {
+	[0] = {
+		.start          = CPHYSADDR(MSC_BASE),
+		.end            = CPHYSADDR(MSC_BASE) + 0x10000 - 1,
+		.flags          = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start          = IRQ_MSC0,
+		.end            = IRQ_MSC0,
+		.flags          = IORESOURCE_IRQ,
+	}
+};
+
+static u64 jz_mmc_dmamask =  ~(u32)0;
+
+static struct platform_device jz_mmc_device = {
+	.name = "jz-mmc",
+	.id = 0,
+	.dev = {
+		.dma_mask               = &jz_mmc_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(jz_mmc_resources),
+	.resource       = jz_mmc_resources,
+};
+
+/* All */
+static struct platform_device *jz_platform_devices[] __initdata = {
+//	&jz_usb_ohci_device,
+	&jz_lcd_device,
+	&jz_usb_gdt_device,
+	&jz_mmc_device,
+};
+
+static int __init jz_platform_init(void)
+{
+	return platform_add_devices(jz_platform_devices, ARRAY_SIZE(jz_platform_devices));
+}
+
+arch_initcall(jz_platform_init);
--- linux-2.6.24.7.old/arch/mips/jz4750d/pm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750d/pm.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,461 @@
+/*
+ * linux/arch/mips/jz4750d/common/pm.c
+ *
+ * JZ4750D Power Management Routines
+ *
+ * Copyright (C) 2006 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/pm.h>
+#include <linux/pm_legacy.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/sysctl.h>
+
+#include <asm/cacheops.h>
+#include <asm/jzsoc.h>
+
+#undef DEBUG
+//#define DEBUG
+#ifdef DEBUG
+#define dprintk(x...)	printk(x)
+#else
+#define dprintk(x...)
+#endif
+
+#define GPIO_PORT_NUM   6
+
+/*
+ * __gpio_as_sleep set all pins to pull-disable, and set all pins as input
+ * except sdram and the pins which can be used as CS1_N to CS4_N for chip select.
+ */
+#define __gpio_as_sleep()	              \
+do {	                                      \
+	REG_GPIO_PXFUNC(1) = ~0x03ff7fff;     \
+	REG_GPIO_PXSELC(1) = ~0x03ff7fff;     \
+	REG_GPIO_PXDIRC(1) = ~0x03ff7fff;     \
+	REG_GPIO_PXPES(1)  =  0xffffffff;     \
+	REG_GPIO_PXFUNC(2) = ~0x01e00000;     \
+	REG_GPIO_PXSELC(2) = ~0x01e00000;     \
+	REG_GPIO_PXDIRC(2) = ~0x01e00000;     \
+	REG_GPIO_PXPES(2)  =  0xffffffff;     \
+	REG_GPIO_PXFUNC(3) =  0xffffffff;     \
+	REG_GPIO_PXSELC(3) =  0xffffffff;     \
+	REG_GPIO_PXDIRC(3) =  0xffffffff;     \
+	REG_GPIO_PXPES(3)  =  0xffffffff;     \
+	REG_GPIO_PXFUNC(4) =  0xffffffff;     \
+	REG_GPIO_PXSELC(4) =  0xffffffff;     \
+	REG_GPIO_PXDIRC(4) =  0xffffffff;     \
+	REG_GPIO_PXPES(4)  =  0xffffffff;     \
+	REG_GPIO_PXFUNC(5) =  0xffffffff;     \
+	REG_GPIO_PXSELC(5) =  0xffffffff;     \
+	REG_GPIO_PXDIRC(5) =  0xffffffff;     \
+	REG_GPIO_PXPES(5)  =  0xffffffff;     \
+} while (0)
+
+static int jz_pm_do_hibernate(void)
+{
+	printk("Put CPU into hibernate mode.\n");
+
+	/* Mask all interrupts */
+	REG_INTC_IMSR = 0xffffffff;
+
+	/*
+	 * RTC Wakeup or 1Hz interrupt can be enabled or disabled
+	 * through  RTC driver's ioctl (linux/driver/char/rtc_jz.c).
+	 */
+
+	/* Set minimum wakeup_n pin low-level assertion time for wakeup: 100ms */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HWFCR = (100 << RTC_HWFCR_BIT);
+
+	/* Set reset pin low-level assertion time after wakeup: must  > 60ms */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HRCR = (60 << RTC_HRCR_BIT); /* 60 ms */
+
+	/* Scratch pad register to be reserved */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HSPR = 0x12345678;
+
+	/* clear wakeup status register */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HWRSR = 0x0;
+
+	/* Put CPU to power down mode */
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	REG_RTC_HCR = RTC_HCR_PD;
+
+	while (!(REG_RTC_RCR & RTC_RCR_WRDY));
+	while(1);
+
+	/* We can't get here */
+	return 0;
+}
+
+/* NOTES:
+ * 1: Pins that are floated (NC) should be set as input and pull-enable.
+ * 2: Pins that are pull-up or pull-down by outside should be set as input
+ *    and pull-disable.
+ * 3: Pins that are connected to a chip except sdram and nand flash
+ *    should be set as input and pull-disable, too.
+ */
+static void jz_board_do_sleep(unsigned long *ptr)
+{
+	unsigned char i;
+
+        /* Print messages of GPIO registers for debug */
+	for(i=0;i<GPIO_PORT_NUM;i++) {
+		dprintk("run dat:%x pin:%x fun:%x sel:%x dir:%x pull:%x msk:%x trg:%x\n",        \
+			REG_GPIO_PXDAT(i),REG_GPIO_PXPIN(i),REG_GPIO_PXFUN(i),REG_GPIO_PXSEL(i), \
+			REG_GPIO_PXDIR(i),REG_GPIO_PXPE(i),REG_GPIO_PXIM(i),REG_GPIO_PXTRG(i));
+	}
+
+        /* Save GPIO registers */
+	for(i = 1; i < GPIO_PORT_NUM; i++) {
+		*ptr++ = REG_GPIO_PXFUN(i);
+		*ptr++ = REG_GPIO_PXSEL(i);
+		*ptr++ = REG_GPIO_PXDIR(i);
+		*ptr++ = REG_GPIO_PXPE(i);
+		*ptr++ = REG_GPIO_PXIM(i);
+		*ptr++ = REG_GPIO_PXDAT(i);
+		*ptr++ = REG_GPIO_PXTRG(i);
+	}
+
+        /*
+         * Set all pins to pull-disable, and set all pins as input except
+         * sdram and the pins which can be used as CS1_N to CS4_N for chip select.
+         */
+        __gpio_as_sleep();
+
+        /*
+	 * Set proper status for GPC21 to GPC24 which can be used as CS1_N to CS4_N.
+	 * Keep the pins' function used for chip select(CS) here according to your
+         * system to avoid chip select crashing with sdram when resuming from sleep mode.
+         */
+
+#if defined(CONFIG_JZ4750D_APUS)
+        /* GPB25/CS1_N is used as chip select for nand flash, shouldn't be change. */
+
+        /* GPB26/CS2_N is connected to nand flash, needn't be changed. */
+
+        /* GPB28/CS3_N is used as cs8900's chip select, shouldn't be changed. */
+
+	/* GPB27/CS4_N is used as NOR's chip select, shouldn't be changed. */
+#endif
+
+ 	/*
+         * Enable pull for NC pins here according to your system
+	 */
+
+#if defined(CONFIG_JZ4750D_APUS)
+#endif
+
+	/*
+         * If you must set some GPIOs as output to high level or low level,
+         * you can set them here, using:
+         * __gpio_as_output(n);
+         * __gpio_set_pin(n); or  __gpio_clear_pin(n);
+	 */
+
+#if defined(CONFIG_JZ4750D_APUS)
+	/* GPC7 which is used as AMPEN_N should be set to high to disable audio amplifier */
+	__gpio_as_output(32*2+7);
+	__gpio_set_pin(32*2+7);
+#endif
+
+#ifdef DEBUG
+        /* Keep uart function for printing debug message */
+	__gpio_as_uart0();
+	__gpio_as_uart1();
+	__gpio_as_uart2();
+	__gpio_as_uart3();
+
+        /* Print messages of GPIO registers for debug */
+	for(i=0;i<GPIO_PORT_NUM;i++) {
+		dprintk("sleep dat:%x pin:%x fun:%x sel:%x dir:%x pull:%x msk:%x trg:%x\n",      \
+			REG_GPIO_PXDAT(i),REG_GPIO_PXPIN(i),REG_GPIO_PXFUN(i),REG_GPIO_PXSEL(i), \
+			REG_GPIO_PXDIR(i),REG_GPIO_PXPE(i),REG_GPIO_PXIM(i),REG_GPIO_PXTRG(i));
+	}
+#endif
+}
+
+static void jz_board_do_resume(unsigned long *ptr)
+{
+	unsigned char i;
+
+	/* Restore GPIO registers */
+	for(i = 1; i < GPIO_PORT_NUM; i++) {
+		 REG_GPIO_PXFUNS(i) = *ptr;
+		 REG_GPIO_PXFUNC(i) = ~(*ptr++);
+
+		 REG_GPIO_PXSELS(i) = *ptr;
+		 REG_GPIO_PXSELC(i) = ~(*ptr++);
+
+		 REG_GPIO_PXDIRS(i) = *ptr;
+		 REG_GPIO_PXDIRC(i) = ~(*ptr++);
+
+		 REG_GPIO_PXPES(i) = *ptr;
+		 REG_GPIO_PXPEC(i) = ~(*ptr++);
+
+		 REG_GPIO_PXIMS(i)=*ptr;
+		 REG_GPIO_PXIMC(i)=~(*ptr++);
+
+		 REG_GPIO_PXDATS(i)=*ptr;
+		 REG_GPIO_PXDATC(i)=~(*ptr++);
+
+		 REG_GPIO_PXTRGS(i)=*ptr;
+		 REG_GPIO_PXTRGC(i)=~(*ptr++);
+	}
+
+        /* Print messages of GPIO registers for debug */
+	for(i=0;i<GPIO_PORT_NUM;i++) {
+		dprintk("resume dat:%x pin:%x fun:%x sel:%x dir:%x pull:%x msk:%x trg:%x\n",     \
+			REG_GPIO_PXDAT(i),REG_GPIO_PXPIN(i),REG_GPIO_PXFUN(i),REG_GPIO_PXSEL(i), \
+			REG_GPIO_PXDIR(i),REG_GPIO_PXPE(i),REG_GPIO_PXIM(i),REG_GPIO_PXTRG(i));
+	}
+}
+
+
+
+static int jz_pm_do_sleep(void)
+{
+	unsigned long delta;
+	unsigned long nfcsr = REG_EMC_NFCSR;
+	unsigned long opcr = REG_CPM_OPCR;
+	unsigned long imr = REG_INTC_IMR;
+	unsigned long sadc = REG_SADC_ENA;
+	unsigned long sleep_gpio_save[7*(GPIO_PORT_NUM-1)];
+
+	printk("Put CPU into sleep mode.\n");
+
+	/* Preserve current time */
+	delta = xtime.tv_sec - REG_RTC_RSR;
+
+        /* Disable nand flash */
+	REG_EMC_NFCSR = ~0xff;
+
+        /* stop sadc */
+	REG_SADC_ENA &= ~0x7;
+	while((REG_SADC_ENA & 0x7) != 0);
+ 	udelay(100);
+
+        /*stop udc and usb*/
+	__cpm_suspend_uhcphy();
+	__cpm_suspend_udcphy();
+
+	/* Sleep on-board modules */
+	jz_board_do_sleep(sleep_gpio_save);
+
+	/* Mask all interrupts */
+	REG_INTC_IMSR = 0xffffffff;
+
+	/* Just allow following interrupts to wakeup the system.
+	 * Note: modify this according to your system.
+	 */
+
+	/* enable RTC alarm */
+	__intc_unmask_irq(IRQ_RTC);
+#if 0
+        /* make system wake up after n seconds by RTC alarm */
+	unsigned int v, n;
+	n = 10;
+	while (!__rtc_write_ready());
+	__rtc_enable_alarm();
+	while (!__rtc_write_ready());
+	__rtc_enable_alarm_irq();
+ 	while (!__rtc_write_ready());
+ 	v = __rtc_get_second();
+ 	while (!__rtc_write_ready());
+ 	__rtc_set_alarm_second(v+n);
+#endif
+
+	/* WAKEUP key */
+	__gpio_as_irq_rise_edge(GPIO_WAKEUP);
+	__gpio_unmask_irq(GPIO_WAKEUP);
+	__intc_unmask_irq(IRQ_GPIO0 - (GPIO_WAKEUP/32));  /* unmask IRQ_GPIOn depends on GPIO_WAKEUP */
+
+	/* disable externel clock Oscillator in sleep mode */
+	__cpm_disable_osc_in_sleep();
+	/* select 32K crystal as RTC clock in sleep mode */
+	__cpm_select_rtcclk_rtc();
+
+ 	/* Enter SLEEP mode */
+	REG_CPM_LCR &= ~CPM_LCR_LPM_MASK;
+	REG_CPM_LCR |= CPM_LCR_LPM_SLEEP;
+	__asm__(".set\tmips3\n\t"
+		"wait\n\t"
+		".set\tmips0");
+
+	/* Restore to IDLE mode */
+	REG_CPM_LCR &= ~CPM_LCR_LPM_MASK;
+	REG_CPM_LCR |= CPM_LCR_LPM_IDLE;
+
+        /* Restore nand flash control register */
+	REG_EMC_NFCSR = nfcsr;
+
+	/* Restore interrupts */
+	REG_INTC_IMSR = imr;
+	REG_INTC_IMCR = ~imr;
+
+	/* Restore sadc */
+	REG_SADC_ENA = sadc;
+
+	/* Resume on-board modules */
+	jz_board_do_resume(sleep_gpio_save);
+
+	/* Restore Oscillator and Power Control Register */
+	REG_CPM_OPCR = opcr;
+
+	/* Restore current time */
+	xtime.tv_sec = REG_RTC_RSR + delta;
+
+	return 0;
+}
+
+/* Put CPU to HIBERNATE mode */
+int jz_pm_hibernate(void)
+{
+	return jz_pm_do_hibernate();
+}
+
+#ifndef CONFIG_JZ_POWEROFF
+static irqreturn_t pm_irq_handler (int irq, void *dev_id)
+{
+	return IRQ_HANDLED;
+}
+#endif
+
+/* Put CPU to SLEEP mode */
+int jz_pm_sleep(void)
+{
+	int retval;
+
+#ifndef CONFIG_JZ_POWEROFF
+	if ((retval = request_irq (IRQ_GPIO_0 + GPIO_WAKEUP, pm_irq_handler, IRQF_DISABLED,
+				   "PM", NULL))) {
+		printk ("PM could not get IRQ for GPIO_WAKEUP\n");
+		return retval;
+	}
+#endif
+
+	pm_send_all(PM_SUSPEND, (void *)3);
+	retval = jz_pm_do_sleep();
+	pm_send_all(PM_RESUME, (void *)0);
+
+#ifndef CONFIG_JZ_POWEROFF
+	free_irq (IRQ_GPIO_0 + GPIO_WAKEUP, NULL);
+#endif
+
+	return retval;
+}
+
+#if 0
+/* Deprecated ,was used by dpm */
+void jz_pm_idle(void)
+{
+	local_irq_disable();
+	if (!need_resched()) {
+		local_irq_enable();
+		cpu_wait();
+	}
+}
+#endif
+
+
+#ifdef CONFIG_SYSCTL
+
+/*
+ * Use a temporary sysctl number. Horrid, but will be cleaned up in 2.6
+ * when all the PM interfaces exist nicely.
+ */
+#define CTL_PM_SUSPEND   1
+#define CTL_PM_HIBERNATE 2
+
+/*----------------------------------------------------------------------------
+ * Power Management sleep sysctl proc interface
+ *
+ * A write to /proc/sys/pm/suspend invokes this function
+ * which initiates a sleep.
+ *--------------------------------------------------------------------------*/
+static int sysctl_jz_pm_sleep(void)
+{
+	return jz_pm_sleep();
+}
+
+/*----------------------------------------------------------------------------
+ * Power Management sleep sysctl proc interface
+ *
+ * A write to /proc/sys/pm/hibernate invokes this function
+ * which initiates a poweroff.
+ *--------------------------------------------------------------------------*/
+static int sysctl_jz_pm_hibernate(void)
+{
+	return jz_pm_hibernate();
+}
+
+static struct ctl_table pm_table[] =
+{
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "suspend",
+		.data		= NULL,
+		.maxlen		= 0,
+		.mode		= 0600,
+		.proc_handler	= &sysctl_jz_pm_sleep,
+	},
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "hibernate",
+		.data		= NULL,
+		.maxlen		= 0,
+		.mode		= 0600,
+		.proc_handler	= &sysctl_jz_pm_hibernate,
+	},
+	{ .ctl_name = 0}
+};
+
+static struct ctl_table pm_dir_table[] =
+{
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "pm",
+		.mode		= 0555,
+		.child		= pm_table,
+	},
+	{ .ctl_name = 0}
+};
+
+#endif /* CONFIG_SYSCTL */
+
+/*
+ * Initialize power interface
+ */
+static int __init jz_pm_init(void)
+{
+	printk("Power Management for JZ\n");
+
+#ifdef CONFIG_SYSCTL
+	register_sysctl_table(pm_dir_table);
+#endif
+
+	return 0;
+}
+
+module_init(jz_pm_init);
--- linux-2.6.24.7.old/arch/mips/jz4750d/proc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750d/proc.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,877 @@
+/*
+ * linux/arch/mips/jz4750d/proc.c
+ *
+ * /proc/jz/ procfs for jz4750d on-chip modules.
+ *
+ * Copyright (C) 2006 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/sysctl.h>
+#include <linux/proc_fs.h>
+#include <linux/page-flags.h>
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+#include <asm/jzsoc.h>
+
+//#define DEBUG 1
+#undef DEBUG
+
+
+struct proc_dir_entry *proc_jz_root;
+
+
+/*
+ * EMC Modules
+ */
+static int emc_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+
+	len += sprintf (page+len, "SMCR(0-5): 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", REG_EMC_SMCR0, REG_EMC_SMCR1, REG_EMC_SMCR2, REG_EMC_SMCR3, REG_EMC_SMCR4);
+	len += sprintf (page+len, "SACR(0-5): 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n", REG_EMC_SACR0, REG_EMC_SACR1, REG_EMC_SACR2, REG_EMC_SACR3, REG_EMC_SACR4);
+	len += sprintf (page+len, "DMCR:      0x%08x\n", REG_EMC_DMCR);
+	len += sprintf (page+len, "RTCSR:     0x%04x\n", REG_EMC_RTCSR);
+	len += sprintf (page+len, "RTCOR:     0x%04x\n", REG_EMC_RTCOR);
+	return len;
+}
+
+/*
+ * Power Manager Module
+ */
+static int pmc_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	unsigned long lcr = REG_CPM_LCR;
+	unsigned long clkgr = REG_CPM_CLKGR;
+
+	len += sprintf (page+len, "Low Power Mode : %s\n",
+			((lcr & CPM_LCR_LPM_MASK) == (CPM_LCR_LPM_IDLE)) ?
+			"IDLE" : (((lcr & CPM_LCR_LPM_MASK) == (CPM_LCR_LPM_SLEEP)) ?
+				  "SLEEP" : "HIBERNATE"));
+	len += sprintf (page+len, "Doze Mode      : %s\n",
+			(lcr & CPM_LCR_DOZE_ON) ? "on" : "off");
+	if (lcr & CPM_LCR_DOZE_ON)
+		len += sprintf (page+len, "     duty      : %d\n", (int)((lcr & CPM_LCR_DOZE_DUTY_MASK) >> CPM_LCR_DOZE_DUTY_BIT));
+	len += sprintf (page+len, "IPU            : %s\n",
+			(clkgr & CPM_CLKGR_IPU) ? "stopped" : "running");
+	len += sprintf (page+len, "DMAC           : %s\n",
+			(clkgr & CPM_CLKGR_DMAC) ? "stopped" : "running");
+	len += sprintf (page+len, "UHC            : %s\n",
+			(clkgr & CPM_CLKGR_UHC) ? "stopped" : "running");
+	len += sprintf (page+len, "UDC            : %s\n",
+			(clkgr & CPM_CLKGR_UDC) ? "stopped" : "running");
+	len += sprintf (page+len, "LCD            : %s\n",
+			(clkgr & CPM_CLKGR_LCD) ? "stopped" : "running");
+	len += sprintf (page+len, "CIM            : %s\n",
+			(clkgr & CPM_CLKGR_CIM) ? "stopped" : "running");
+	len += sprintf (page+len, "SADC           : %s\n",
+			(clkgr & CPM_CLKGR_SADC) ? "stopped" : "running");
+	len += sprintf (page+len, "MSC0           : %s\n",
+			(clkgr & CPM_CLKGR_MSC0) ? "stopped" : "running");
+	len += sprintf (page+len, "MSC1           : %s\n",
+			(clkgr & CPM_CLKGR_MSC1) ? "stopped" : "running");
+	len += sprintf (page+len, "AIC1           : %s\n",
+			(clkgr & CPM_CLKGR_AIC1) ? "stopped" : "running");
+	len += sprintf (page+len, "AIC2           : %s\n",
+			(clkgr & CPM_CLKGR_AIC2) ? "stopped" : "running");
+	len += sprintf (page+len, "SSI0           : %s\n",
+			(clkgr & CPM_CLKGR_SSI0) ? "stopped" : "running");
+	len += sprintf (page+len, "SSI1           : %s\n",
+			(clkgr & CPM_CLKGR_SSI1) ? "stopped" : "running");
+	len += sprintf (page+len, "I2C            : %s\n",
+			(clkgr & CPM_CLKGR_I2C) ? "stopped" : "running");
+	len += sprintf (page+len, "RTC            : %s\n",
+			(clkgr & CPM_CLKGR_RTC) ? "stopped" : "running");
+	len += sprintf (page+len, "TCU            : %s\n",
+			(clkgr & CPM_CLKGR_TCU) ? "stopped" : "running");
+	len += sprintf (page+len, "UART1          : %s\n",
+			(clkgr & CPM_CLKGR_UART1) ? "stopped" : "running");
+	len += sprintf (page+len, "UART0          : %s\n",
+			(clkgr & CPM_CLKGR_UART0) ? "stopped" : "running");
+	return len;
+}
+
+static int pmc_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	REG_CPM_CLKGR = simple_strtoul(buffer, 0, 16);
+	return count;
+}
+
+/*
+ * Clock Generation Module
+ */
+#define TO_MHZ(x) (x/1000000),(x%1000000)/10000
+#define TO_KHZ(x) (x/1000),(x%1000)/10
+
+static int cgm_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	unsigned int cppcr = REG_CPM_CPPCR;  /* PLL Control Register */
+	unsigned int cpccr = REG_CPM_CPCCR;  /* Clock Control Register */
+	unsigned int div[] = {1, 2, 3, 4, 6, 8, 12, 16, 24, 32};
+	unsigned int od[4] = {1, 2, 2, 4};
+
+	len += sprintf (page+len, "CPPCR          : 0x%08x\n", cppcr);
+	len += sprintf (page+len, "CPCCR          : 0x%08x\n", cpccr);
+	len += sprintf (page+len, "PLL            : %s\n",
+			(cppcr & CPM_CPPCR_PLLEN) ? "ON" : "OFF");
+	len += sprintf (page+len, "m:n:o          : %d:%d:%d\n",
+			__cpm_get_pllm() + 2,
+			__cpm_get_plln() + 2,
+			od[__cpm_get_pllod()]
+		);
+	len += sprintf (page+len, "C:H:M:P        : %d:%d:%d:%d\n",
+			div[__cpm_get_cdiv()],
+			div[__cpm_get_hdiv()],
+			div[__cpm_get_mdiv()],
+			div[__cpm_get_pdiv()]
+		);
+	len += sprintf (page+len, "PLL Freq        : %3d.%02d MHz\n", TO_MHZ(__cpm_get_pllout()));
+	len += sprintf (page+len, "CCLK            : %3d.%02d MHz\n", TO_MHZ(__cpm_get_cclk()));
+	len += sprintf (page+len, "HCLK            : %3d.%02d MHz\n", TO_MHZ(__cpm_get_hclk()));
+	len += sprintf (page+len, "MCLK            : %3d.%02d MHz\n", TO_MHZ(__cpm_get_mclk()));
+	len += sprintf (page+len, "PCLK            : %3d.%02d MHz\n", TO_MHZ(__cpm_get_pclk()));
+	len += sprintf (page+len, "LCDCLK          : %3d.%02d MHz\n", TO_MHZ(__cpm_get_lcdclk()));
+	len += sprintf (page+len, "PIXCLK          : %3d.%02d KHz\n", TO_KHZ(__cpm_get_pixclk()));
+	len += sprintf (page+len, "I2SCLK          : %3d.%02d MHz\n", TO_MHZ(__cpm_get_i2sclk()));
+	len += sprintf (page+len, "USBCLK          : %3d.%02d MHz\n", TO_MHZ(__cpm_get_usbclk()));
+	len += sprintf (page+len, "MSC0CLK         : %3d.%02d MHz\n", TO_MHZ(__cpm_get_mscclk(0)));
+	len += sprintf (page+len, "MSC1CLK         : %3d.%02d MHz\n", TO_MHZ(__cpm_get_mscclk(1)));
+	len += sprintf (page+len, "EXTALCLK0       : %3d.%02d MHz\n", TO_MHZ(__cpm_get_extalclk0()));
+	len += sprintf (page+len, "EXTALCLK(by CPM): %3d.%02d MHz\n", TO_MHZ(__cpm_get_extalclk()));
+	len += sprintf (page+len, "RTCCLK          : %3d.%02d MHz\n", TO_MHZ(__cpm_get_rtcclk()));
+
+	return len;
+}
+
+static int cgm_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	REG_CPM_CPCCR = simple_strtoul(buffer, 0, 16);
+	return count;
+}
+
+
+/* USAGE:
+ * echo n  > /proc/jz/ipu 	// n = [1,...,9], alloc mem, 2^n pages.
+ * echo FF > /proc/jz/ipu 	// 255, free all buffer
+ * echo xxxx > /proc/jz/ipu 	// free buffer which addr is xxxx
+ * echo llll > /proc/jz/ipu 	// add_wired_entry(l,l,l,l)
+ * echo 0  > /proc/jz/ipu 	// debug, print ipu_buf
+ * od -X /proc/jz/ipu 		// read mem addr
+ */
+
+typedef struct _ipu_buf {
+	unsigned int addr;	/* phys addr */
+	unsigned int page_shift;
+} ipu_buf_t;
+
+#define IPU_BUF_MAX 		4 	/* 4 buffers */
+
+static struct _ipu_buf ipu_buf[IPU_BUF_MAX];
+static int ipu_buf_cnt = 0;
+static unsigned char g_asid=0;
+
+extern void local_flush_tlb_all(void);
+
+/* CP0 hazard avoidance. */
+#define BARRIER __asm__ __volatile__(".set noreorder\n\t" \
+				     "nop; nop; nop; nop; nop; nop;\n\t" \
+				     ".set reorder\n\t")
+void show_tlb(void)
+{
+#define ASID_MASK 0xFF
+
+        unsigned long flags;
+        unsigned int old_ctx;
+	unsigned int entry;
+	unsigned int entrylo0, entrylo1, entryhi;
+	unsigned int pagemask;
+
+	local_irq_save(flags);
+
+	/* Save old context */
+	old_ctx = (read_c0_entryhi() & 0xff);
+
+	printk("TLB content:\n");
+	entry = 0;
+	while(entry < 32) {
+		write_c0_index(entry);
+		BARRIER;
+		tlb_read();
+		BARRIER;
+		entryhi = read_c0_entryhi();
+		entrylo0 = read_c0_entrylo0();
+		entrylo1 = read_c0_entrylo1();
+		pagemask = read_c0_pagemask();
+		printk("%02d: ASID=%02d%s VA=0x%08x ", entry, entryhi & ASID_MASK, (entrylo0 & entrylo1 & 1) ? "(G)" : "   ", entryhi & ~ASID_MASK);
+		printk("PA0=0x%08x C0=%x %s%s%s\n", (entrylo0>>6)<<12, (entrylo0>>3) & 7, (entrylo0 & 4) ? "Dirty " : "", (entrylo0 & 2) ? "Valid " : "Invalid ", (entrylo0 & 1) ? "Global" : "");
+		printk("\t\t\t     PA1=0x%08x C1=%x %s%s%s\n", (entrylo1>>6)<<12, (entrylo1>>3) & 7, (entrylo1 & 4) ? "Dirty " : "", (entrylo1 & 2) ? "Valid " : "Invalid ", (entrylo1 & 1) ? "Global" : "");
+
+		printk("\t\tpagemask=0x%08x", pagemask);
+		printk("\tentryhi=0x%08x\n", entryhi);
+		printk("\t\tentrylo0=0x%08x", entrylo0);
+		printk("\tentrylo1=0x%08x\n", entrylo1);
+
+		entry++;
+	}
+	BARRIER;
+	write_c0_entryhi(old_ctx);
+
+	local_irq_restore(flags);
+}
+
+static void ipu_add_wired_entry(unsigned long pid,
+				unsigned long entrylo0, unsigned long entrylo1,
+				unsigned long entryhi, unsigned long pagemask)
+{
+	unsigned long flags;
+	unsigned long wired;
+	unsigned long old_pagemask;
+	unsigned long old_ctx;
+	struct task_struct *g, *p;
+
+	/* We will lock an 4MB page size entry to map the 4MB reserved IPU memory */
+	wired = read_c0_wired();
+	if (wired) return;
+
+	do_each_thread(g, p) {
+		if (p->pid == pid )
+			g_asid = p->mm->context[0];
+	} while_each_thread(g, p);
+
+
+	local_irq_save(flags);
+
+	entrylo0 = entrylo0 >> 6;   /* PFN */
+	entrylo0 |= 0x6 | (0 << 3); /* Write-through cacheable, dirty, valid */
+
+	/* Save old context and create impossible VPN2 value */
+	old_ctx = read_c0_entryhi() & 0xff;
+	old_pagemask = read_c0_pagemask();
+	wired = read_c0_wired();
+	write_c0_wired(wired + 1);
+	write_c0_index(wired);
+	BARRIER;
+	entryhi &= ~0xff;	/* new add, 20070906 */
+	entryhi |= g_asid;	/* new add, 20070906 */
+//	entryhi |= old_ctx;	/* new add, 20070906 */
+	write_c0_pagemask(pagemask);
+	write_c0_entryhi(entryhi);
+	write_c0_entrylo0(entrylo0);
+	write_c0_entrylo1(entrylo1);
+	BARRIER;
+	tlb_write_indexed();
+	BARRIER;
+
+	write_c0_entryhi(old_ctx);
+	BARRIER;
+	write_c0_pagemask(old_pagemask);
+	local_flush_tlb_all();
+	local_irq_restore(flags);
+#if defined(DEBUG)
+	printk("\nold_ctx=%03d\n", old_ctx);
+
+	show_tlb();
+#endif
+}
+
+static void ipu_del_wired_entry( void )
+{
+	unsigned long flags;
+	unsigned long wired;
+
+	local_irq_save(flags);
+	wired = read_c0_wired();
+	if ( wired > 0 ) {
+		write_c0_wired(wired - 1);
+	}
+	local_irq_restore(flags);
+}
+
+static inline void ipu_buf_get( unsigned int page_shift )
+{
+	unsigned char * virt_addr;
+	int i;
+	for ( i=0; i< IPU_BUF_MAX; ++i ) {
+		if ( ipu_buf[i].addr == 0 ) {
+			break;
+		}
+	}
+
+	if ( (ipu_buf_cnt = i) == IPU_BUF_MAX ) {
+		printk("Error, no free ipu buffer.\n");
+		return ;
+	}
+
+	virt_addr =  (unsigned char *)__get_free_pages(GFP_KERNEL, page_shift);
+
+	if ( virt_addr ) {
+		ipu_buf[ipu_buf_cnt].addr = (unsigned int)virt_to_phys((void *)virt_addr);
+		ipu_buf[ipu_buf_cnt].page_shift = page_shift;
+
+		for (i = 0; i < (1<<page_shift); i++) {
+			SetPageReserved(virt_to_page(virt_addr));
+			virt_addr += PAGE_SIZE;
+		}
+	}
+	else {
+		printk("get memory Failed.\n");
+	}
+}
+
+static inline void ipu_buf_free( unsigned int phys_addr )
+{
+	unsigned char * virt_addr, *addr;
+	int cnt, i;
+
+	if ( phys_addr == 0 )
+		return ;
+
+	for ( cnt=0; cnt<IPU_BUF_MAX; ++cnt )
+		if ( phys_addr == ipu_buf[cnt].addr )
+			break;
+
+	if ( cnt == IPU_BUF_MAX ) {	/* addr not in the ipu buffers */
+		printk("Invalid addr:0x%08x\n", (unsigned int)phys_addr);
+	}
+
+	virt_addr = (unsigned char *)phys_to_virt(ipu_buf[cnt].addr);
+	addr = virt_addr;
+	for (i = 0; i < (1<<ipu_buf[cnt].page_shift); i++) {
+		ClearPageReserved(virt_to_page(addr));
+		addr += PAGE_SIZE;
+	}
+
+	if ( cnt == 0 )
+		ipu_del_wired_entry();
+
+	free_pages((unsigned long )virt_addr, ipu_buf[cnt].page_shift);
+
+	ipu_buf[cnt].addr = 0;
+	ipu_buf[cnt].page_shift = 0;
+}
+
+static int ipu_read_proc (char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+
+	/* read as binary */
+	unsigned int * pint;
+	pint = (unsigned int *) (page+len);
+
+	if ( ipu_buf_cnt >= IPU_BUF_MAX ) {	/* failed alloc mem, rturn 0 */
+		printk("no free buffer.\n");
+		*pint = 0;
+	}
+	else
+		*pint = (unsigned int )ipu_buf[ipu_buf_cnt].addr; /* phys addr */
+	len += sizeof(unsigned int);
+
+#if defined(DEBUG)
+		show_tlb();
+#endif
+	return len;
+
+}
+
+static int ipu_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	unsigned int val ;
+	int cnt,i;
+	char buf[12];
+	unsigned long pid, entrylo0, entrylo1, entryhi, pagemask;
+#if defined(DEBUG)
+	printk("ipu write count=%u\n", count);
+#endif
+	if (count == (8*5+1)) {
+		for (i=0;i<12;i++) buf[i]=0;
+		strncpy(buf, buffer+8*0, 8);
+		pid = simple_strtoul(buf, 0, 16);
+		for (i=0;i<12;i++) buf[i]=0;
+		strncpy(buf, buffer+8*1, 8);
+		entrylo0 = simple_strtoul(buf, 0, 16);
+		for (i=0;i<12;i++) buf[i]=0;
+		strncpy(buf, buffer+8*2, 8);
+		entrylo1 = simple_strtoul(buf, 0, 16);
+		for (i=0;i<12;i++) buf[i]=0;
+		strncpy(buf, buffer+8*3, 8);
+		entryhi = simple_strtoul(buf, 0, 16);
+		for (i=0;i<12;i++) buf[i]=0;
+		strncpy(buf, buffer+8*4, 8);
+		pagemask = simple_strtoul(buf, 0, 16);
+
+#if defined(DEBUG)
+		printk("pid=0x%08x, entrylo0=0x%08x, entrylo1=0x%08x, entryhi=0x%08x, pagemask=0x%08x\n",
+		       pid, entrylo0, entrylo1, entryhi, pagemask);
+#endif
+		ipu_add_wired_entry( pid, entrylo0, entrylo1, entryhi, pagemask);
+		return 41;
+	}
+	else if ( count <= 8+1 ) {
+		for (i=0;i<12;i++) buf[i]=0;
+		strncpy(buf, buffer, 8);
+		val = simple_strtoul(buf, 0, 16);
+	} else if (count == 44) {
+		for (i = 0; i < 12; i++)
+			buf[i] = 0;
+		strncpy(buf, buffer, 10);
+		pid = simple_strtoul(buf, 0, 16);
+		for (i = 0; i < 12; i++)
+			buf[i] = 0;
+		strncpy(buf, buffer + 11, 10);
+		entryhi = simple_strtoul(buf, 0, 16);//vaddr
+		for (i = 0; i < 12; i++)
+			buf[i] = 0;
+		strncpy(buf, buffer + 22, 10);
+		entrylo0 = simple_strtoul(buf, 0, 16);//paddr
+		for (i = 0; i < 12; i++)
+			buf[i] = 0;
+		strncpy(buf, buffer + 33, 10);
+		pagemask = simple_strtoul(buf, 0, 16);
+		pagemask = 0x3ff << 13; /* Fixed to 4MB page size */
+		ipu_add_wired_entry(pid, entrylo0, 0, entryhi, pagemask);
+		return 44;
+	} else {
+		printk("ipu write count error, count=%d\n.", (unsigned int)count);
+		return -1;
+	}
+
+	/* val: 1-9, page_shift,  val>= 10: ipu_buf.addr */
+	if ( val == 0 ) {	/* debug, print ipu_buf info */
+		for ( cnt=0; cnt<IPU_BUF_MAX; ++cnt)
+			printk("ipu_buf[%d]: addr=0x%08x, page_shift=%d\n",
+			       cnt, ipu_buf[cnt].addr, ipu_buf[cnt].page_shift );
+#if defined(DEBUG)
+		show_tlb();
+#endif
+	}
+	else if ( 0< val && val < 10 ) {
+		ipu_buf_get(val);
+	}
+	else if ( val == 0xff ) { /* 255: free all ipu_buf */
+		for ( cnt=0; cnt<IPU_BUF_MAX; ++cnt ) {
+			ipu_buf_free(ipu_buf[cnt].addr);
+		}
+	}
+	else {
+		ipu_buf_free(val);
+	}
+
+	return count;
+}
+
+/*
+ * UDC hotplug
+ */
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+extern int jz_udc_active;	/* defined in drivers/char/jzchar/jz_udc_hotplug.c */
+#endif
+
+#ifndef GPIO_UDC_HOTPLUG
+#define GPIO_UDC_HOTPLUG 86
+#endif
+
+static int udc_read_proc(char *page, char **start, off_t off,
+			 int count, int *eof, void *data)
+{
+        int len = 0;
+
+	if (__gpio_get_pin(GPIO_UDC_HOTPLUG)) {
+
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+
+		/* Cable has connected, wait for disconnection. */
+		__gpio_as_irq_fall_edge(GPIO_UDC_HOTPLUG);
+
+		if (jz_udc_active)
+			len += sprintf (page+len, "CONNECT_CABLE\n");
+		else
+			len += sprintf (page+len, "CONNECT_POWER\n");
+#else
+		len += sprintf (page+len, "CONNECT\n");
+#endif
+	}
+	else {
+
+#ifdef CONFIG_JZ_UDC_HOTPLUG
+		/* Cable has disconnected, wait for connection. */
+		__gpio_as_irq_rise_edge(GPIO_UDC_HOTPLUG);
+#endif
+
+		len += sprintf (page+len, "REMOVE\n");
+	}
+
+        return len;
+}
+
+/*
+ * MMC/SD hotplug
+ */
+
+#ifndef MSC_HOTPLUG_PIN
+#define MSC_HOTPLUG_PIN 90
+#endif
+
+static int mmc_read_proc (char *page, char **start, off_t off,
+                          int count, int *eof, void *data)
+{
+        int len = 0;
+
+        if (__gpio_get_pin(MSC_HOTPLUG_PIN))
+                len += sprintf (page+len, "REMOVE\n");
+        else
+                len += sprintf (page+len, "INSERT\n");
+
+        return len;
+}
+
+/***********************************************************************
+ * IPU memory management (used by mplayer and other apps)
+ *
+ * We reserved 4MB memory for IPU
+ * The memory base address is jz_ipu_framebuf
+ */
+
+/* Usage:
+ *
+ * echo n  > /proc/jz/imem 		// n = [0,...,10], allocate memory, 2^n pages
+ * echo xxxxxxxx > /proc/jz/imem	// free buffer which addr is xxxxxxxx
+ * echo FF > /proc/jz/ipu 		// FF, free all buffers
+ * od -X /proc/jz/imem 			// return the allocated buffer address and the max order of free buffer
+ */
+
+//#define DEBUG_IMEM 1
+
+#define IMEM_MAX_ORDER 10		/* max 2^10 * 4096 = 4MB */
+
+static unsigned int jz_imem_base;	/* physical base address of ipu memory */
+
+static unsigned int allocated_phys_addr = 0;
+
+/*
+ * Allocated buffer list
+ */
+typedef struct imem_list {
+	unsigned int phys_start;	/* physical start addr */
+	unsigned int phys_end;		/* physical end addr */
+	struct imem_list *next;
+} imem_list_t;
+
+static struct imem_list *imem_list_head = NULL; /* up sorted by phys_start */
+
+#ifdef DEBUG_IMEM
+static void dump_imem_list(void)
+{
+	struct imem_list *imem;
+
+	printk("*** dump_imem_list 0x%x ***\n", (u32)imem_list_head);
+	imem = imem_list_head;
+	while (imem) {
+		printk("imem=0x%x phys_start=0x%x phys_end=0x%x next=0x%x\n", (u32)imem, imem->phys_start, imem->phys_end, (u32)imem->next);
+		imem = imem->next;
+	}
+}
+#endif
+
+/* allocate 2^order pages inside the 4MB memory */
+static int imem_alloc(unsigned int order)
+{
+	int alloc_ok = 0;
+	unsigned int start, end;
+	unsigned int size = (1 << order) * PAGE_SIZE;
+	struct imem_list *imem, *imemn, *imemp;
+
+	allocated_phys_addr = 0;
+
+	start = jz_imem_base;
+	end = start + (1 << IMEM_MAX_ORDER) * PAGE_SIZE;
+
+	imem = imem_list_head;
+	while (imem) {
+		if ((imem->phys_start - start) >= size) {
+			/* we got a valid address range */
+			alloc_ok = 1;
+			break;
+		}
+
+		start = imem->phys_end + 1;
+		imem = imem->next;
+	}
+
+	if (!alloc_ok) {
+		if ((end - start) >= size)
+			alloc_ok = 1;
+	}
+
+	if (alloc_ok) {
+		end = start + size - 1;
+		allocated_phys_addr = start;
+
+		/* add to imem_list, up sorted by phys_start */
+		imemn = kmalloc(sizeof(struct imem_list), GFP_KERNEL);
+		if (!imemn) {
+			return -ENOMEM;
+		}
+		imemn->phys_start = start;
+		imemn->phys_end = end;
+		imemn->next = NULL;
+
+		if (!imem_list_head)
+			imem_list_head = imemn;
+		else {
+			imem = imemp = imem_list_head;
+			while (imem) {
+				if (start < imem->phys_start) {
+					break;
+				}
+
+				imemp = imem;
+				imem = imem->next;
+			}
+
+			if (imem == imem_list_head) {
+				imem_list_head = imemn;
+				imemn->next = imem;
+			}
+			else {
+				imemn->next = imemp->next;
+				imemp->next = imemn;
+			}
+		}
+	}
+
+#ifdef DEBUG_IMEM
+	dump_imem_list();
+#endif
+	return 0;
+}
+
+static void imem_free(unsigned int phys_addr)
+{
+	struct imem_list *imem, *imemp;
+
+	imem = imemp = imem_list_head;
+	while (imem) {
+		if (phys_addr == imem->phys_start) {
+			if (imem == imem_list_head) {
+				imem_list_head = imem->next;
+			}
+			else {
+				imemp->next = imem->next;
+			}
+
+			kfree(imem);
+			break;
+		}
+
+		imemp = imem;
+		imem = imem->next;
+	}
+
+#ifdef DEBUG_IMEM
+	dump_imem_list();
+#endif
+}
+
+static void imem_free_all(void)
+{
+	struct imem_list *imem;
+
+	imem = imem_list_head;
+	while (imem) {
+		kfree(imem);
+		imem = imem->next;
+	}
+
+	imem_list_head = NULL;
+
+	allocated_phys_addr = 0;
+
+#ifdef DEBUG_IMEM
+	dump_imem_list();
+#endif
+}
+
+/*
+ * Return the allocated buffer address and the max order of free buffer
+ */
+static int imem_read_proc(char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	unsigned int start_addr, end_addr, max_order, max_size;
+	struct imem_list *imem;
+
+	unsigned int *tmp = (unsigned int *)(page + len);
+
+	start_addr = jz_imem_base;
+	end_addr = start_addr + (1 << IMEM_MAX_ORDER) * PAGE_SIZE;
+
+	if (!imem_list_head)
+		max_size = end_addr - start_addr;
+	else {
+		max_size = 0;
+		imem = imem_list_head;
+		while (imem) {
+			if (max_size < (imem->phys_start - start_addr))
+				max_size = imem->phys_start - start_addr;
+
+			start_addr = imem->phys_end + 1;
+			imem = imem->next;
+		}
+
+		if (max_size < (end_addr - start_addr))
+			max_size = end_addr - start_addr;
+	}
+
+	if (max_size > 0) {
+		max_order = get_order(max_size);
+		if (((1 << max_order) * PAGE_SIZE) > max_size)
+		    max_order--;
+	}
+	else {
+		max_order = 0xffffffff;	/* No any free buffer */
+	}
+
+	*tmp++ = allocated_phys_addr;	/* address allocated by 'echo n > /proc/jz/imem' */
+	*tmp = max_order;		/* max order of current free buffers */
+
+	len += 2 * sizeof(unsigned int);
+
+	return len;
+}
+
+static int imem_write_proc(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	unsigned int val;
+
+	val = simple_strtoul(buffer, 0, 16);
+
+	if (val == 0xff) {
+		/* free all memory */
+		imem_free_all();
+	}
+	else if ((val >= 0) && (val <= IMEM_MAX_ORDER)) {
+		/* allocate 2^val pages */
+		imem_alloc(val);
+	}
+	else {
+		/* free buffer which phys_addr is val */
+		imem_free(val);
+	}
+
+	return count;
+}
+
+/*
+ * /proc/jz/xxx entry
+ *
+ */
+static int __init jz_proc_init(void)
+{
+	struct proc_dir_entry *res;
+	unsigned int virt_addr, i;
+
+	proc_jz_root = proc_mkdir("jz", 0);
+
+	/* External Memory Controller */
+	res = create_proc_entry("emc", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = emc_read_proc;
+		res->write_proc = NULL;
+		res->data = NULL;
+	}
+
+	/* Power Management Controller */
+	res = create_proc_entry("pmc", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = pmc_read_proc;
+		res->write_proc = pmc_write_proc;
+		res->data = NULL;
+	}
+
+	/* Clock Generation Module */
+	res = create_proc_entry("cgm", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = cgm_read_proc;
+		res->write_proc = cgm_write_proc;
+		res->data = NULL;
+	}
+
+	/* Image process unit */
+	res = create_proc_entry("ipu", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = ipu_read_proc;
+		res->write_proc = ipu_write_proc;
+		res->data = NULL;
+	}
+
+	/* udc hotplug */
+	res = create_proc_entry("udc", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = udc_read_proc;
+		res->write_proc = NULL;
+		res->data = NULL;
+	}
+
+	/* mmc hotplug */
+	res = create_proc_entry("mmc", 0644, proc_jz_root);
+	if (res) {
+		res->read_proc = mmc_read_proc;
+		res->write_proc = NULL;
+		res->data = NULL;
+	}
+
+	/*
+	 * Reserve a 4MB memory for IPU on JZ4750D.
+	 */
+	jz_imem_base = (unsigned int)__get_free_pages(GFP_KERNEL, IMEM_MAX_ORDER);
+	if (jz_imem_base) {
+		/* imem (IPU memory management) */
+		res = create_proc_entry("imem", 0644, proc_jz_root);
+		if (res) {
+			res->read_proc = imem_read_proc;
+			res->write_proc = imem_write_proc;
+			res->data = NULL;
+		}
+
+		/* Set page reserved */
+		virt_addr = jz_imem_base;
+		for (i = 0; i < (1 << IMEM_MAX_ORDER); i++) {
+			SetPageReserved(virt_to_page((void *)virt_addr));
+			virt_addr += PAGE_SIZE;
+		}
+
+		/* Convert to physical address */
+		jz_imem_base = virt_to_phys((void *)jz_imem_base);
+
+		printk("Total %dMB memory at 0x%x was reserved for IPU\n",
+		       (unsigned int)((1 << IMEM_MAX_ORDER) * PAGE_SIZE)/1000000, jz_imem_base);
+	}
+
+	return 0;
+}
+
+__initcall(jz_proc_init);
--- linux-2.6.24.7.old/arch/mips/jz4750d/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750d/prom.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,198 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *    PROM library initialisation code, supports YAMON and U-Boot.
+ *
+ * Copyright 2000, 2001, 2006 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	ppopov@mvista.com or source@mvista.com
+ *
+ * This file was derived from Carsten Langgaard's
+ * arch/mips/mips-boards/xx files.
+ *
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+#include <asm/jzsoc.h>
+
+/* #define DEBUG_CMDLINE */
+
+int prom_argc;
+char **prom_argv, **prom_envp;
+
+char * prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
+
+void  prom_init_cmdline(void)
+{
+	char *cp;
+	int actr;
+
+	actr = 1; /* Always ignore argv[0] */
+
+	cp = &(arcs_cmdline[0]);
+	while(actr < prom_argc) {
+	        strcpy(cp, prom_argv[actr]);
+		cp += strlen(prom_argv[actr]);
+		*cp++ = ' ';
+		actr++;
+	}
+	if (cp != &(arcs_cmdline[0])) /* get rid of trailing space */
+		--cp;
+	if (prom_argc > 1)
+		*cp = '\0';
+
+}
+
+
+char *prom_getenv(char *envname)
+{
+#if 0
+	/*
+	 * Return a pointer to the given environment variable.
+	 * YAMON uses "name", "value" pairs, while U-Boot uses "name=value".
+	 */
+
+	char **env = prom_envp;
+	int i = strlen(envname);
+	int yamon = (*env && strchr(*env, '=') == NULL);
+
+	while (*env) {
+		if (yamon) {
+			if (strcmp(envname, *env++) == 0)
+				return *env;
+		} else {
+			if (strncmp(envname, *env, i) == 0 && (*env)[i] == '=')
+				return *env + i + 1;
+		}
+		env++;
+	}
+#endif
+	return NULL;
+}
+
+inline unsigned char str2hexnum(unsigned char c)
+{
+	if(c >= '0' && c <= '9')
+		return c - '0';
+	if(c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	if(c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	return 0; /* foo */
+}
+
+inline void str2eaddr(unsigned char *ea, unsigned char *str)
+{
+	int i;
+
+	for(i = 0; i < 6; i++) {
+		unsigned char num;
+
+		if((*str == '.') || (*str == ':'))
+			str++;
+		num = str2hexnum(*str++) << 4;
+		num |= (str2hexnum(*str++));
+		ea[i] = num;
+	}
+}
+
+int get_ethernet_addr(char *ethernet_addr)
+{
+        char *ethaddr_str;
+
+        ethaddr_str = prom_getenv("ethaddr");
+	if (!ethaddr_str) {
+	        printk("ethaddr not set in boot prom\n");
+		return -1;
+	}
+	str2eaddr(ethernet_addr, ethaddr_str);
+
+#if 0
+	{
+		int i;
+
+	printk("get_ethernet_addr: ");
+	for (i=0; i<5; i++)
+		printk("%02x:", (unsigned char)*(ethernet_addr+i));
+	printk("%02x\n", *(ethernet_addr+i));
+	}
+#endif
+
+	return 0;
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
+
+void __init prom_init(void)
+{
+	unsigned char *memsize_str;
+	unsigned long memsize;
+
+	prom_argc = (int) fw_arg0;
+	prom_argv = (char **) fw_arg1;
+	prom_envp = (char **) fw_arg2;
+
+	mips_machtype = MACH_INGENIC_JZ4750D;
+
+	prom_init_cmdline();
+	memsize_str = prom_getenv("memsize");
+	if (!memsize_str) {
+		memsize = 0x04000000;
+	} else {
+		memsize = simple_strtol(memsize_str, NULL, 0);
+	}
+	add_memory_region(0, memsize, BOOT_MEM_RAM);
+}
+
+/* used by early printk */
+void prom_putchar(char c)
+{
+	volatile u8 *uart_lsr = (volatile u8 *)(UART0_BASE + OFF_LSR);
+	volatile u8 *uart_tdr = (volatile u8 *)(UART0_BASE + OFF_TDR);
+
+	/* Wait for fifo to shift out some bytes */
+	while ( !((*uart_lsr & (UARTLSR_TDRQ | UARTLSR_TEMT)) == 0x60) );
+
+	*uart_tdr = (u8)c;
+}
+
+const char *get_system_type(void)
+{
+	return "JZ4750D";
+}
+
+EXPORT_SYMBOL(prom_getcmdline);
+EXPORT_SYMBOL(get_ethernet_addr);
+EXPORT_SYMBOL(str2eaddr);
--- linux-2.6.24.7.old/arch/mips/jz4750d/reset.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750d/reset.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,46 @@
+/*
+ * linux/arch/mips/jz4750/reset.c
+ *
+ * JZ4750 reset routines.
+ *
+ * Copyright (c) 2006-2007  Ingenic Semiconductor Inc.
+ * Author: <yliu@ingenic.cn>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/reboot.h>
+#include <asm/system.h>
+#include <asm/jzsoc.h>
+
+void jz_restart(char *command)
+{
+	printk("Restarting after 4 ms\n");
+	REG_WDT_TCSR = WDT_TCSR_PRESCALE4 | WDT_TCSR_EXT_EN;
+	REG_WDT_TCNT = 0;
+	REG_WDT_TDR = JZ_EXTAL/1000;   /* reset after 4ms */
+	REG_TCU_TSCR = TCU_TSCR_WDTSC; /* enable wdt clock */
+	REG_WDT_TCER = WDT_TCER_TCEN;  /* wdt start */
+	while (1);
+}
+
+void jz_halt(void)
+{
+	printk(KERN_NOTICE "\n** You can safely turn off the power\n");
+
+	while (1)
+		__asm__(".set\tmips3\n\t"
+	                "wait\n\t"
+			".set\tmips0");
+}
+
+void jz_power_off(void)
+{
+	jz_halt();
+}
--- linux-2.6.24.7.old/arch/mips/jz4750d/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750d/setup.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,199 @@
+/*
+ * linux/arch/mips/jz4750d/common/setup.c
+ *
+ * JZ4750D common setup routines.
+ *
+ * Copyright (C) 2006 Ingenic Semiconductor Inc.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/ioport.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_8250.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/pgtable.h>
+#include <asm/time.h>
+#include <asm/jzsoc.h>
+
+#ifdef CONFIG_PC_KEYB
+#include <asm/keyboard.h>
+#endif
+
+jz_clocks_t jz_clocks;
+
+extern char * __init prom_getcmdline(void);
+extern void __init jz_board_setup(void);
+extern void jz_restart(char *);
+extern void jz_halt(void);
+extern void jz_power_off(void);
+extern void jz_time_init(void);
+
+static void __init sysclocks_setup(void)
+{
+#ifndef CONFIG_MIPS_JZ_EMURUS /* FPGA */
+	jz_clocks.cclk = __cpm_get_cclk();
+	jz_clocks.hclk = __cpm_get_hclk();
+	jz_clocks.pclk = __cpm_get_pclk();
+	jz_clocks.mclk = __cpm_get_mclk();
+	jz_clocks.lcdclk = __cpm_get_lcdclk();
+	jz_clocks.pixclk = __cpm_get_pixclk();
+	jz_clocks.i2sclk = __cpm_get_i2sclk();
+	jz_clocks.usbclk = __cpm_get_usbclk();
+	jz_clocks.mscclk = __cpm_get_mscclk(0);
+	jz_clocks.extalclk = __cpm_get_extalclk();
+	jz_clocks.rtcclk = __cpm_get_rtcclk();
+#else
+
+#define FPGACLK 8000000
+
+	jz_clocks.cclk = FPGACLK;
+	jz_clocks.hclk = FPGACLK;
+	jz_clocks.pclk = FPGACLK;
+	jz_clocks.mclk = FPGACLK;
+	jz_clocks.lcdclk = FPGACLK;
+	jz_clocks.pixclk = FPGACLK;
+	jz_clocks.i2sclk = FPGACLK;
+	jz_clocks.usbclk = FPGACLK;
+	jz_clocks.mscclk = FPGACLK;
+	jz_clocks.extalclk = FPGACLK;
+	jz_clocks.rtcclk = FPGACLK;
+#endif
+
+	printk("CPU clock: %dMHz, System clock: %dMHz, Peripheral clock: %dMHz, Memory clock: %dMHz\n",
+	       (jz_clocks.cclk + 500000) / 1000000,
+	       (jz_clocks.hclk + 500000) / 1000000,
+	       (jz_clocks.pclk + 500000) / 1000000,
+	       (jz_clocks.mclk + 500000) / 1000000);
+}
+
+static void __init soc_cpm_setup(void)
+{
+	/* Start all module clocks
+	 */
+	__cpm_start_all();
+
+	/* Enable CKO to external memory */
+	__cpm_enable_cko();
+
+	/* CPU enters IDLE mode when executing 'wait' instruction */
+	__cpm_idle_mode();
+
+	/* Setup system clocks */
+	sysclocks_setup();
+}
+
+static void __init soc_harb_setup(void)
+{
+//	__harb_set_priority(0x00);  /* CIM>LCD>DMA>ETH>PCI>USB>CBB */
+//	__harb_set_priority(0x03);  /* LCD>CIM>DMA>ETH>PCI>USB>CBB */
+//	__harb_set_priority(0x0a);  /* ETH>LCD>CIM>DMA>PCI>USB>CBB */
+}
+
+static void __init soc_emc_setup(void)
+{
+}
+
+static void __init soc_dmac_setup(void)
+{
+	__dmac_enable_module(0);
+	__dmac_enable_module(1);
+}
+
+static void __init jz_soc_setup(void)
+{
+	soc_cpm_setup();
+	soc_harb_setup();
+	soc_emc_setup();
+	soc_dmac_setup();
+}
+
+static void __init jz_serial_setup(void)
+{
+#ifdef CONFIG_SERIAL_8250
+	struct uart_port s;
+	REG8(UART0_FCR) |= UARTFCR_UUE; /* enable UART module */
+	memset(&s, 0, sizeof(s));
+	s.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST;
+	s.iotype = SERIAL_IO_MEM;
+	s.regshift = 2;
+	s.uartclk = jz_clocks.extalclk ;
+
+	s.line = 0;
+	s.membase = (u8 *)UART0_BASE;
+	s.irq = IRQ_UART0;
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial ttyS0 setup failed!\n");
+	}
+
+	s.line = 1;
+	s.membase = (u8 *)UART1_BASE;
+	s.irq = IRQ_UART1;
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial ttyS1 setup failed!\n");
+	}
+
+	s.line = 2;
+	s.membase = (u8 *)UART2_BASE;
+	s.irq = IRQ_UART2;
+
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial ttyS2 setup failed!\n");
+	}
+/*
+	s.line = 3;
+	s.membase = (u8 *)UART3_BASE;
+	s.irq = IRQ_UART3;
+	if (early_serial_setup(&s) != 0) {
+		printk(KERN_ERR "Serial ttyS3 setup failed!\n");
+	}
+*/
+#endif
+}
+
+void __init plat_mem_setup(void)
+{
+	char *argptr;
+
+	argptr = prom_getcmdline();
+
+	/* IO/MEM resources. Which will be the addtion value in `inX' and
+	 * `outX' macros defined in asm/io.h */
+	set_io_port_base(0);
+	ioport_resource.start	= 0x00000000;
+	ioport_resource.end	= 0xffffffff;
+	iomem_resource.start	= 0x00000000;
+	iomem_resource.end	= 0xffffffff;
+
+	_machine_restart = jz_restart;
+	_machine_halt = jz_halt;
+	pm_power_off = jz_power_off;
+
+	jz_soc_setup();
+	jz_serial_setup();
+	jz_board_setup();
+}
+
--- linux-2.6.24.7.old/arch/mips/jz4750d/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.24.7/arch/mips/jz4750d/time.c	2009-04-12 18:13:57.000000000 +0200
@@ -0,0 +1,156 @@
+/*
+ * linux/arch/mips/jz4750d/time.c
+ *
+ * Setting up the clock on the JZ4750D boards.
+ *
+ * Copyright (C) 2008 Ingenic Semiconductor Inc.
+ * Author: <jlwei@ingenic.cn>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/clockchips.h>
+
+#include <asm/time.h>
+#include <asm/jzsoc.h>
+
+/* This is for machines which generate the exact clock. */
+
+#define JZ_TIMER_IRQ  IRQ_TCU0
+
+#define JZ_TIMER_CLOCK (JZ_EXTAL>>4) /* Jz timer clock frequency */
+
+static struct clocksource clocksource_jz; /* Jz clock source */
+static struct clock_event_device jz_clockevent_device; /* Jz clock event */
+
+void (*jz_timer_callback)(void);
+
+static irqreturn_t jz_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *cd = dev_id;
+
+	REG_TCU_TFCR = TCU_TFCR_OSTFCL; /* ACK timer */
+
+	if (jz_timer_callback)
+		jz_timer_callback();
+
+	cd->event_handler(cd);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction jz_irqaction = {
+	.handler	= jz_timer_interrupt,
+	.flags		= IRQF_DISABLED | IRQF_PERCPU | IRQF_TIMER,
+	.name		= "jz-timerirq",
+};
+
+
+cycle_t jz_get_cycles(void)
+{
+	/* convert jiffes to jz timer cycles */
+	return (cycle_t)( jiffies*((JZ_TIMER_CLOCK)/HZ) + REG_TCU_OSTCNT);
+}
+
+static struct clocksource clocksource_jz = {
+	.name 		= "jz_clocksource",
+	.rating		= 300,
+	.read		= jz_get_cycles,
+	.mask		= 0xFFFFFFFF,
+	.shift 		= 10,
+	.flags		= CLOCK_SOURCE_WATCHDOG,
+};
+
+static int __init jz_clocksource_init(void)
+{
+	clocksource_jz.mult = clocksource_hz2mult(JZ_TIMER_CLOCK, clocksource_jz.shift);
+	clocksource_register(&clocksource_jz);
+	return 0;
+}
+
+static int jz_set_next_event(unsigned long evt,
+				  struct clock_event_device *unused)
+{
+	return 0;
+}
+
+static void jz_set_mode(enum clock_event_mode mode,
+			struct clock_event_device *evt)
+{
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+                break;
+        case CLOCK_EVT_MODE_ONESHOT:
+        case CLOCK_EVT_MODE_UNUSED:
+        case CLOCK_EVT_MODE_SHUTDOWN:
+                break;
+        case CLOCK_EVT_MODE_RESUME:
+                break;
+        }
+}
+
+static struct clock_event_device jz_clockevent_device = {
+	.name		= "jz-clockenvent",
+	.features	= CLOCK_EVT_FEAT_PERIODIC,
+//	.features	= CLOCK_EVT_FEAT_ONESHOT, /* Jz4740 not support dynamic clock now */
+
+	/* .mult, .shift, .max_delta_ns and .min_delta_ns left uninitialized */
+	.rating		= 300,
+	.irq		= JZ_TIMER_IRQ,
+	.set_mode	= jz_set_mode,
+	.set_next_event	= jz_set_next_event,
+};
+
+static void __init jz_clockevent_init(void)
+{
+	struct clock_event_device *cd = &jz_clockevent_device;
+	unsigned int cpu = smp_processor_id();
+
+	cd->cpumask = cpumask_of_cpu(cpu);
+	clockevents_register_device(cd);
+}
+
+static void __init jz_timer_setup(void)
+{
+	jz_clocksource_init();	/* init jz clock source */
+	jz_clockevent_init();	/* init jz clock event */
+
+	/*
+	 * Make irqs happen for the system timer
+	 */
+	jz_irqaction.dev_id = &jz_clockevent_device;
+	setup_irq(JZ_TIMER_IRQ, &jz_irqaction);
+}
+
+
+void __init plat_time_init(void)
+{
+	unsigned int latch;
+
+	/* Init timer */
+	latch = (JZ_TIMER_CLOCK + (HZ>>1)) / HZ;
+
+	REG_TCU_OSTCSR = TCU_OSTCSR_PRESCALE16 | TCU_OSTCSR_EXT_EN;
+	REG_TCU_OSTCNT = 0;
+	REG_TCU_OSTDR = latch;
+
+	REG_TCU_TMCR = TCU_TMCR_OSTMCL; /* unmask match irq */
+	REG_TCU_TSCR = TCU_TSCR_OSTSC;  /* enable timer clock */
+	REG_TCU_TESR = TCU_TESR_OSTST;  /* start counting up */
+
+	jz_timer_setup();
+}
--- linux-2.6.24.7.old/arch/mips/kernel/cpu-probe.c	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/arch/mips/kernel/cpu-probe.c	2009-04-12 18:13:57.000000000 +0200
@@ -160,6 +160,7 @@
 	case CPU_25KF:
 	case CPU_PR4450:
 	case CPU_BCM3302:
+	case CPU_JZRISC:
 		cpu_wait = r4k_wait;
 		break;

@@ -860,6 +860,23 @@
	}
 }

+static inline void cpu_probe_ingenic(struct cpuinfo_mips *c, unsigned int cpu)
+{
+	decode_configs(c);
+	c->options &= ~MIPS_CPU_COUNTER; /* JZRISC does not implement the CP0 counter. */
+	switch (c->processor_id & 0xff00) {
+	case PRID_IMP_JZRISC:
+		c->cputype = CPU_JZRISC;
+		c->isa_level = MIPS_CPU_ISA_M32R1;
+		c->tlbsize = 32;
+		__cpu_name[cpu] = "Ingenic JZRISC";
+		break;
+	default:
+		panic("Unknown Ingenic Processor ID!");
+		break;
+	}
+}
+
 static inline void cpu_probe_broadcom(struct cpuinfo_mips *c, unsigned int cpu)
 {
	decode_configs(c);
@@ -909,6 +926,9 @@
	case PRID_COMP_NXP:
		cpu_probe_nxp(c, cpu);
		break;
+	case PRID_COMP_INGENIC:
+		cpu_probe_ingenic(c, cpu);
+		break;
	}

	BUG_ON(!__cpu_name[cpu]);
--- linux-2.6.24.7.old/arch/mips/mm/c-r4k.c	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/arch/mips/mm/c-r4k.c	2009-04-12 18:13:57.000000000 +0200
@@ -874,6 +874,36 @@
 		c->dcache.waybit = 0;
 		break;

+	case CPU_JZRISC:
+		config1 = read_c0_config1();
+		config1 = (config1 >> 22) & 0x07;
+		if (config1 == 0x07)
+			config1 = 10;
+		else
+			config1 = config1 + 11;
+		config1 += 2;
+		icache_size = (1 << config1);
+		c->icache.linesz = 32;
+		c->icache.ways = 4;
+		c->icache.waybit = __ffs(icache_size / c->icache.ways);
+
+		config1 = read_c0_config1();
+		config1 = (config1 >> 13) & 0x07;
+		if (config1 == 0x07)
+			config1 = 10;
+		else
+			config1 = config1 + 11;
+		config1 += 2;
+		dcache_size = (1 << config1);
+		c->dcache.linesz = 32;
+		c->dcache.ways = 4;
+		c->dcache.waybit = __ffs(dcache_size / c->dcache.ways);
+
+		c->dcache.flags = 0;
+		c->options |= MIPS_CPU_PREFETCH;
+
+		break;
+
 	default:
 		if (!(config & MIPS_CONF_M))
 			panic("Don't know how to probe P-caches on this cpu.");
--- linux-2.6.24.7.old/arch/mips/mm/cache.c	2008-05-07 01:22:34.000000000 +0200
+++ linux-2.6.24.7/arch/mips/mm/cache.c	2009-04-12 18:13:57.000000000 +0200
@@ -47,6 +47,8 @@
 void (*_dma_cache_inv)(unsigned long start, unsigned long size);

 EXPORT_SYMBOL(_dma_cache_wback_inv);
+EXPORT_SYMBOL(_dma_cache_wback);
+EXPORT_SYMBOL(_dma_cache_inv);

 #endif /* CONFIG_DMA_NONCOHERENT */

--- linux-2.6.24.7.old/arch/mips/mm/tlbex.c	2009-04-12 18:05:07.000000000 +0200
+++ linux-2.6.24.7/arch/mips/mm/tlbex.c	2009-04-12 18:13:57.000000000 +0200
@@ -981,6 +981,11 @@
 		tlbw(p);
 		break;

+	case CPU_JZRISC:
+		tlbw(p);
+		uasm_i_nop(p);
+		break;
+
 	default:
 		panic("No TLB refill handler yet (CPU type: %d)",
 		      current_cpu_data.cputype);
